<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只小喵喵的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-01T03:14:56.246Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试</title>
    <link href="http://yoursite.com/2019/09/01/%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/09/01/测试/</id>
    <published>2019-09-01T03:14:56.000Z</published>
    <updated>2019-09-01T03:14:56.246Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入了解ConcurrentHashMap</title>
    <link href="http://yoursite.com/2019/03/31/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3ConcurrentHashMap/"/>
    <id>http://yoursite.com/2019/03/31/深入了解ConcurrentHashMap/</id>
    <published>2019-03-31T09:59:08.000Z</published>
    <updated>2019-03-31T10:04:21.907Z</updated>
    
    <content type="html"><![CDATA[<p>转眼三月了 又到了樱花飘落的季节？昨天高中舍友翻出了当年小纸条拍给我看 没想到我还有那样疯狂杀马特的年纪啊</p><p>很多东西都变了 不变的是我的文笔和字还是这么烂 很多事都是第一次接触 给人一种很不真实的感觉 不再有人告诉你该怎么做 该好好学数学 学英语 做题 锻炼 吃有营养的食物… 连现在坐在这做对着电脑码bug 都给人一种很不可思议的感觉</p><p>这些都是一些废话 随口一说 今天有时间划水 想把上个礼拜看到的一个东东摸清楚——ConcurrentHashMap 说来惭愧 我之前似乎从来没见过这个类 第一眼看到百度了一下有了个大概的概念是用于并发的HashMap 天呐<strong>并发</strong>这块我真的是一点都不懂 持续利用搜索引擎打开新篇章(σﾟ∀ﾟ)σ…不 这回get了一个新技能 Ctrl Shift Alt + U 查看包 这图画的也太清晰了 可以说是相当方便了</p><p>Java提供了并发包java.util.concurrent 在用ConcurrentHashMap时可以看到引入的时候是<figure class="highlight plain"><figcaption><span>java.util.concurrent.ConcurrentHashMap; ```首先回顾一下它的祖辈 集合 顺便系统的复习一下吧</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;img src=&quot;深入了解ConcurrentHashMap/1.png&quot;&gt;</span><br><span class="line"></span><br><span class="line">util.Collection的三个直系子接口：Set，List，Queue</span><br><span class="line">Set为数字意义上的集合 没有重复项  List则为允许重复项的有序集合 Queue 接触的不多 队列 先进先出 主要是它的一个数据结构 这些直系子接口下能与支持并发挂上钩的 只有Vector（Vetor是个同步容器类）</span><br><span class="line"></span><br><span class="line">&gt; 题外话：为什么Vector我们总是不用呢？明明他是安全的 而且读取得也很快</span><br><span class="line">&gt; 是的 他安全，所以效率低 类似于StringBuffer 她和ArrayList是亲姐妹 但修改操作的效率却远低于ArrayList</span><br><span class="line">&gt; 另外分配内存时需要连续的存储空间 </span><br><span class="line">&gt; ArrayList的增长量默认0.5倍 而Vector是一倍</span><br><span class="line">&gt; 总得来说是个比较死板的List 也难怪大家都不爱用她了</span><br><span class="line"></span><br><span class="line">在这之前的推荐的线程安全的实现方式有Collections.synchronizedMap 和HashTable （但HashTable效率也比较低）今天的主角所在的concurrent包说来应该是个混血 虽然祖辈和集合有点联系 但它的结构来自于HashMap 父亲ConcurrentMap是从JDK5开始增加的线程安全的Map接口 </span><br><span class="line"></span><br><span class="line">**1.8之前**</span><br><span class="line"></span><br><span class="line">## 结构</span><br><span class="line"></span><br><span class="line">一个ConcurrentHashMap由一个个Segment组成 可以理解为一个Segment数组 Segment通过继承ReentrantLock 来实现加锁 每次锁住的是一个segment</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 2249069246763182397L;</span><br><span class="line">        final float loadFactor;</span><br><span class="line">        Segment(float lf) &#123; this.loadFactor = lf; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>concurrencyLevel</strong> 并发数目 即Segment个数 默认为16个 一旦初始化不能扩容 在一个三入参的构造方法里可以初始化这个值  注意，Java 需要它是 2 的幂次方，如果输入是类似 15则会自动调整到临近的2的幂次方 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>initialCapacity</strong> 初始容量 会平均分给每个Segment</p><p><strong>loadFactor</strong> 负载系数 这个我们稍后详细看看是什么来的</p><p>从他的结构就可以看出与HashTable相比 做并发操作时有了更多选择 因为HashTable只是竞争同一把锁 而ConcurrentHashMap默认会有十六个选择 这就是分离锁的作用 当一个线程访问其中一段数据的时候 其他段的数据也能被其他线程访问</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>这要首先讲讲HashMap的机制</p><p><img src="https://static001.geekbang.org/resource/image/1f/56/1f72306a9d8719c66790b56ef7977c56.png"></p><p>一个HashMap可以看做是key-value数组 但数组内部的形式上是链表组合的结构 通过计算哈希值决定了寻址 当得到一个地址并进入插入时 若发现这块存储地址已经被其他元素占用 就会找一块未被占用的存储地址 用链表的方式跟在后面</p><blockquote><p>在这解释为什么刚才说ConcurrentHashMap的concurrencyLevel会是2的幂次方 这和HashMap的数组初始化长度如出一辙  因为这样可以更好地减少key之间的碰撞  key经过计算之后获取的哈希值在寻址之前要与数组长度2^n-1做与运算（比如16长度则与1110做与运算） 若不满2^n位则有较大几率产生相同结果 比如哈希值为8（1000）和9（1001）与1110与运算结果相同 这就产生了碰撞 这会导致哈希值为9的这块地址无法存放元素 产生了浪费 也减慢了查询的效率</p></blockquote><p>初始的数组（也叫作桶bucket）+ 链表 组成了HashMap</p><p>当一个HashMap中元素越来越多，碰撞的几率也越来越高，就要对初始数组进行扩容 也就是resize操作 初始容量<strong>initialCapacity</strong>与负载因子<strong>loadFactor</strong>决定了它何时扩容 </p><p>初始时 initialCapacity = 0 当要塞元素时 执行resize 初始容量设置为 threshold 16</p><p>继续塞 当元素数量超过 initialCapacity <em> loadFactory = 16 </em> 0.75 = 12 时 执行resize 容量 -&gt; threshold = 2*16 = 32</p><p>当容量算出来之后会初始化一个新的长度的桶数组 将键值对重新映射到新的桶数组中</p><p>以上就是作为一个普通的HashMap所遇到的扩容问题 <strong>那么ConcurrentHashMap是如何操作扩容的呢？</strong> 不是整体扩容 而是对每个segment扩容 为了支持多线程 ConcurrentHashMap有个 <strong>sizeCtl</strong> 字段会在未初始化、初始化中和扩容中用不同的数字表示状态</p><p><strong>1.8之后</strong></p><p>JDK8后的ConcurrentHashMap可以说是脱胎换骨 但在了解变化之前要先来看看HashMap在1.8之后做了什么</p><p>HashMap 从原先的 <strong>数组 + 链表</strong> 变为 <strong>数组 + 链表 + 红黑树</strong> 当链表根的长度超过8时会转化为树  (๑Ő௰Ő๑)真是做梦都没想到我还能看到红黑树这么深奥的东东了？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若添加元素为8时会转化为树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若添加元素小于6时会从树转化为链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000012926727?w=1598&h=752"></p><p>参考原文：<a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/" target="_blank" rel="noopener">http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/</a></p><p>真是庆幸自己能看到这篇文章 大神讲解的十分详细 连图都是这么优美 相比我自己写的实在是太垃圾了 (((;꒪ꈊ꒪;)))另外关于红黑树大神也有一篇博客 真的强推！ 今天把这个放一下等周末有大把时间再来琢磨</p><p>回到主题ConcurrentHashMap在JDK1.8之后也沿袭了HashMap的结构 抛弃了Segment（但如今还是能在源码中看到Segment是为了保证序列化时的兼容 实际上已没有用处）初始化简化为懒加载 使用CAS</p><blockquote><p>说到懒加载 上一篇博客讲的单例就是非懒加载</p><p>懒加载：对象使用的时候才去创建。节省资源,但是不利于提前发现错误<br>非懒加载：容器启动时立马创建。消耗资源,有利于提前发现错误</p><p>错误非常关键，所以一般来说都用非懒加载的方式</p></blockquote><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>参考原文：<a href="https://blog.csdn.net/weixin_42636552/article/details/82383272" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42636552/article/details/82383272</a></p><p>CAS:Compare and Swap 意为比价交换 java.util.concurrent包中接住CAS实现了区别于synchronouse的一种乐观锁</p><p><strong>无锁的概念</strong></p><p>在谈论无锁概念时，总会关联起乐观派与悲观派，对于乐观派而言，他们认为事情总会往好的方向发展，总是认为坏的情况发生的概率特别小，可以无所顾忌地做事，但对于悲观派而已，他们总会认为发展事态如果不及时控制，以后就无法挽回了，即使无法挽回的局面几乎不可能发生。<br>这两种派系映射到并发编程中就如同加锁与无锁的策略，即加锁是一种悲观策略，无锁是一种乐观策略，因为对于加锁的并发程序来说，它们总是认为每次访问共享资源时总会发生冲突，因此必须对每一次数据操作实施加锁策略。<br>而无锁则总是假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，无锁策略则采用一种称为CAS的技术来保证线程执行的安全性，这项CAS技术就是无锁策略实现的关键，下面我们进一步了解CAS技术的奇妙之处。</p><p>CAS有三个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * V 需要更新的变量</span></span><br><span class="line"><span class="comment"> * E 预期值</span></span><br><span class="line"><span class="comment"> * N 新值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CAS(V, E, N)</span><br></pre></td></tr></table></figure><p>如果V == E，则将V设置为N。若V != E 这说明已经有其他线程做了更新，则当前线程什么都不做</p><p>由于CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作，这点从图中也可以看出来。基于这样的原理，CAS操作即使没有锁，同样知道其他线程对共享资源操作影响，并执行相应的处理措施。<strong>同时从这点也可以看出，由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说无锁操作天生免疫死锁。</strong></p><p>另外会不会发生这边写着V那边读的情况呢？是有可能的 但因为CAS是原语 （这一点将Compare and Swap放到有道词典里一搜就能知道）故不会产生不一致的问题</p><p>在没有锁的机制下，需要借助volatile原语来保证线程间的数据是可见 共享的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">//利用volatile为val和next设置同步锁 导致只有在获取变量的时候才能直接读取</span></span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 初始化tab也是一个cas操作</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 利用CAS 进行无锁线程操作 判断bin是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//对Node加悲观锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                <span class="comment">//链表操作</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            <span class="comment">//如果是树要采取红黑树的方法安排数据</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        <span class="comment">// 数目超过阈值 进行树化</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 还记得这个sizeCtl吗？ 小于0表示已经扩容 大于0表示还没扩容</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 这个翻译说是进入自旋状态 自旋锁 36讲有章节讲 之后再开一话</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//若CAS返回true 则做下面的操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用了前后三天时间写了这个博客 感觉越深入越感觉自己不会的有很多 在这之前我可能连HashMap的结构都不清楚 现在还遗留了很多未打开的话题 比如volatile 自旋锁与偏向锁 红黑树等等 开这篇博客的原因是从公司大哥代码里看到的 是从zookeeper中拿的数据放在了ConcurrentHashMap中 一边这边刷新数据赋值的同时当前系统可能有并发的读取 所以用了高效的ConcurrentHashMap </p><p>但要真的理解和掌握肯定不是这么粗粗地看一眼就学会的 手边有Java并发编程和Java36讲 在36讲刚出来的时候订阅却看不懂什么 现在居然也可以跟着慢慢磨懂了 还是挺开心的 另外我的写作水平有待加强 废话有点多 不够清晰 不加标点符号成了习惯看上去也有点费劲 我会慢慢改正的！有什么意见和建议欢迎留言呀！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转眼三月了 又到了樱花飘落的季节？昨天高中舍友翻出了当年小纸条拍给我看 没想到我还有那样疯狂杀马特的年纪啊&lt;/p&gt;
&lt;p&gt;很多东西都变了 不变的是我的文笔和字还是这么烂 很多事都是第一次接触 给人一种很不真实的感觉 不再有人告诉你该怎么做 该好好学数学 学英语 做题 锻炼 
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>记bug簿（长期更新）</title>
    <link href="http://yoursite.com/2019/03/03/%E8%AE%B0bug%E7%B0%BF%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/03/记bug簿（长期更新）/</id>
    <published>2019-03-03T02:30:57.000Z</published>
    <updated>2019-03-31T10:17:34.302Z</updated>
    
    <content type="html"><![CDATA[<p>开这篇blog的来源是因为工作中真的遇到了很多大大小小的问题，平时有空我都会记录下来，但由于又不是很重要或者很难的东西，（一切都源于我菜才会有这些问题），不想为这些分别立一篇，但还是有记录的价值的！（记录了自己成长哈哈哈）</p><p>我会按照内容来做标题，也会order by desc，这篇的开始为19/2/13，所以一些小问题以后就不会立一篇博客了，只有当我觉得很重要的东西才会不放在这里面。</p><p>另外每一个bug解决不可能完全不依赖搜索引擎，但是我会记录原文地址。</p><h2 id="Mysql-error-code-1366"><a href="#Mysql-error-code-1366" class="headerlink" title="Mysql error code 1366"></a>Mysql error code 1366</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### Error updating database.  Cause: java.sql.SQLException: Incorrect string value: &apos;\xE6\x9D\xA5\xE8\x87\xAA...&apos; for column &apos;content&apos; at row 1</span><br><span class="line">### The error may involve com.gkoudai.futureManage.Mapper.RedMsgMapper.insertSelective-Inline</span><br><span class="line">### The error occurred while setting parameters</span><br><span class="line">### SQL: insert into tb_exchange_notice      ( id,                       title,                       content,                       sort,                                     url,                                                   icon,                              old_id,                       exchange_name,                       is_show )       values ( ?,                       ?,                       ?,                       ?,                                     ?,                                                   ?,                              ?,                       ?,                       ? )</span><br><span class="line">### Cause: java.sql.SQLException: Incorrect string value: &apos;\xE6\x9D\xA5\xE8\x87\xAA...&apos; for column &apos;content&apos; at row 1</span><br><span class="line">; uncategorized SQLException; SQL state [HY000]; error code [1366]; Incorrect string value: &apos;\xE6\x9D\xA5\xE8\x87\xAA...&apos; for column &apos;content&apos; at row 1</span><br></pre></td></tr></table></figure><p>这里content设为text格式，字符编码应为utf-8，默认是latin不支持中文，会报1366错</p><h2 id="Mybatis-OrderBy问题"><a href="#Mybatis-OrderBy问题" class="headerlink" title="Mybatis OrderBy问题"></a>Mybatis OrderBy问题</h2><p>多条件排序</p><p>example.setOrderByClauser(“timestamp DESC, name ASC”);</p><h2 id="如何将一个bean的属性赋给另一个bean"><a href="#如何将一个bean的属性赋给另一个bean" class="headerlink" title="如何将一个bean的属性赋给另一个bean"></a>如何将一个bean的属性赋给另一个bean</h2><p>两个类的属性不一定全部相同，但希望相同的属性中能映射过去。</p><p>Spring的BeanUtils.copyProperties()方法</p><h2 id="如何判断一个元素在数组中"><a href="#如何判断一个元素在数组中" class="headerlink" title="如何判断一个元素在数组中"></a>如何判断一个元素在数组中</h2><p>indexOf()若大于零则存在</p><h2 id="IDEA中WebApplication-Exploded与Archive区别"><a href="#IDEA中WebApplication-Exploded与Archive区别" class="headerlink" title="IDEA中WebApplication:Exploded与Archive区别"></a>IDEA中WebApplication:Exploded与Archive区别</h2><p>原文：<a href="https://blog.csdn.net/ydk888888/article/details/77247725" target="_blank" rel="noopener">https://blog.csdn.net/ydk888888/article/details/77247725 </a></p><p>对这个问题的疑惑是当时有个同事交接给我项目时，用IDEA跑普通maven项目起不来，于是以为是artifacts配置的问题，设置的地方在IDEA右上角有个蓝色俄罗斯方块的文件夹-Project Settings-Artifacts，就产生了疑惑，WebApplication:Exploded和WebApplication:Archive有啥区别？</p><p><img src="/2019/03/03/记bug簿（长期更新）/111.png"></p><p>直接引用原博客的话：</p><p>选项中有web application exploded，这个是以文件夹形式（War Exploded）发布项目，选择这个，发布项目时就会自动生成文件夹在指定的output directory,</p><p>如果选web application archive，就是war包形式，每次都会重新打包全部的,将项目打成一个war包在指定位置；</p><h2 id="git-Warning-detached-HEAD"><a href="#git-Warning-detached-HEAD" class="headerlink" title="git Warning detached HEAD"></a>git Warning detached HEAD</h2><p>原文：<a href="https://www.jianshu.com/p/ae4857d2f868" target="_blank" rel="noopener">https://www.jianshu.com/p/ae4857d2f868</a></p><p>提交代码的时候遇到了Warning，没有贴原句，就拿这个原文中的复制过来，是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Warning: you are leaving 1 commit behind, not connected to</span><br><span class="line">any of your branches:</span><br><span class="line"></span><br><span class="line">  fef4501 interrationRecord page completed</span><br><span class="line"></span><br><span class="line">If you want to keep them by creating a new branch, this may be a good time</span><br><span class="line">to do so with:</span><br><span class="line"></span><br><span class="line"> git branch &lt;new-branch-name&gt; fef4501</span><br></pre></td></tr></table></figure><p>原本应该上传到master分支，但commit出现了这个Warning导致没有成功，当时也没来得及看这段话，只看到git提交记录中自己的那个分支上右侧tag显示了一个黄色的感叹号，且无法push，就急忙着checkout了线上master看发现果然没有自己commit的那条，返回本地分支自己辛辛苦苦写了两天的代码就没了，突然愣住，找了其他大佬说应该是找不回来了，于是看到这个warning，找到这篇简书。</p><p>按照步骤第一步输入,xxxx就是这个Warning里的版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git branch temp xxxx</span><br></pre></td></tr></table></figure><p>第二步切换工作分支并合并代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge temp</span><br></pre></td></tr></table></figure><p>最后删除temp分支</p><p>但是！我发现自己创的temp分支根本和这篇里的不一样，我只是创了一个temp 但并没有我原来的那个代码，以为这个方法也凉凉，但还是坚信代码能找回来！毕竟commit过，怎么会丢呢？</p><p>首先我们分析一下这个Warning，git把我们新的提交已经创好了一个版本号，但是实际上这个版本没有完全成功因为他说没有提交到任一分支，（奇怪我坚信自己肯定是选了，和平时操作一样），但这个编号为xxxx的commit实际上是肯定存在某个地方的，git也建议我们使用temp分支来解决这个问题，所以解决思路应该吗没问题</p><p>最后意识到自己在遇到这个Warning后又自己checkout了master分支又切回来多次，所以当下的git状态可能没有之前我commit的这条xxxx，所以创建temp分支会有语法错误，于是git log找到当时我提交的那个head 版本号，再reset回去，保险起见我在IDEA里右击-git-reset里退回（防止我自己敲错）然后再按照上面的步骤重新合并，成功！</p><p>花了差不多半个小时挽回了自己两天的代码…</p><h2 id="sublist"><a href="#sublist" class="headerlink" title="sublist()"></a>sublist()</h2><p>List中有个sublist方法的小标为左闭右开</p><h2 id="git-无法重输密码的问题"><a href="#git-无法重输密码的问题" class="headerlink" title="git 无法重输密码的问题"></a>git 无法重输密码的问题</h2><p>公司内网gitlab代码down不下来，因为一段时间没用gitlab，可能第一次输密码的时候错了，导致怎么都拉不下来代码，想重新输入又没有跳出来弹框，在外面用命令直接输出现Authentication failed。于是按照<a href="https://blog.csdn.net/qq_40028324/article/details/80883010" target="_blank" rel="noopener">https://blog.csdn.net/qq_40028324/article/details/80883010</a>将密码清空之后再输一次就成功了。</p><h2 id="log占位符"><a href="#log占位符" class="headerlink" title="log占位符"></a>log占位符</h2><p>研究大佬们代码发现他们log放参数的方法没有见过，是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&quot;xxxxxx:&#123;&#125;&quot;,obj.getXXX());</span><br></pre></td></tr></table></figure><p>这种大括号的占位符方式是log特有的，非常方便，多参数还可以加上序号区分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.log(Level.INFO,&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;&quot;,new Object[]&#123;&quot;刘利新&quot;,System.getProperty(&quot;line.separator&quot;),&quot;西安&quot;&#125;);</span><br></pre></td></tr></table></figure><p>来自<a href="https://blog.csdn.net/weiyanghuadi/article/details/9271447" target="_blank" rel="noopener">https://blog.csdn.net/weiyanghuadi/article/details/9271447</a></p><h2 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h2><p>Ctrl+Shift+Backspace，跳转到上次编辑的地方</p><p>F2 或 Shift+F2，高亮错误或警告快速定位</p><p>Alt+Shift+Up/Down，上/下移一行</p><h2 id="String-Date和Timestamp转化"><a href="#String-Date和Timestamp转化" class="headerlink" title="String Date和Timestamp转化"></a>String Date和Timestamp转化</h2><p>因为原文真的太详细了，实在不忍心复制黏贴下来，请查阅原文：<a href="https://www.cnblogs.com/qima/p/3652566.html" target="_blank" rel="noopener">https://www.cnblogs.com/qima/p/3652566.html</a></p><p>另外timestamp的单位为秒或毫秒</p><h2 id="数据库datetime类型的set方法"><a href="#数据库datetime类型的set方法" class="headerlink" title="数据库datetime类型的set方法"></a>数据库datetime类型的set方法</h2><p>datetime类型在java中导入用setTimestamp()方法</p><h2 id="util-Date与sql-Date转化"><a href="#util-Date与sql-Date转化" class="headerlink" title="util.Date与sql.Date转化"></a>util.Date与sql.Date转化</h2><p>数据库中拿到的Date是sql包的，赋给util.Date时会报错,转换方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlDate = new Timestamp(utilDate.getTime());</span><br><span class="line">utilDate = new Date(sqlDate.getTime());</span><br></pre></td></tr></table></figure><p>同时，两者均可被SimpleDateFormat格式化</p><h2 id="设置Date时间"><a href="#设置Date时间" class="headerlink" title="设置Date时间"></a>设置Date时间</h2><p>这边是设置Date时分秒为0的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date tradeDay = candleStick.getTradeDay();</span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.setTime(tradeDay);</span><br><span class="line">calendar.set(Calendar.HOUR,0);</span><br><span class="line">calendar.set(Calendar.MINUTE,0);</span><br><span class="line">calendar.set(Calendar.SECOND,0);</span><br></pre></td></tr></table></figure><h2 id="List与ArrayList的区别"><a href="#List与ArrayList的区别" class="headerlink" title="List与ArrayList的区别"></a>List与ArrayList的区别</h2><p><a href="https://www.cnblogs.com/zcscnn/p/7743507.html" target="_blank" rel="noopener">https://www.cnblogs.com/zcscnn/p/7743507.html</a></p><p>这些基础知识有些忘了，今天看代码时突然不明白为什么通常使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList()</span><br></pre></td></tr></table></figure><p>找到这篇博客复习了集合，ArrayList是List的实现类，而作为接口List的扩展性是很好的</p><h2 id="java8中stream，filter遍历代替for"><a href="#java8中stream，filter遍历代替for" class="headerlink" title="java8中stream，filter遍历代替for"></a>java8中stream，filter遍历代替for</h2><p>今天看代码又发现一处没见过的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;QuotesConfigTimeSubsection&gt; subsectionList = tradeTime.stream()</span><br><span class="line">        .filter(info -&gt; info.getStartMonth() &lt;= month &amp;&amp; info.getEndMonth() &gt;= month)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>了解了这种新特性的写法，看上去的确比for来的清爽的多</p><p>stream().filter可过滤一个满足某条件的集合并赋值，</p><p>stream().map可直接遍历一整个集合并赋值</p><p>另外还有filtermap还没用过</p><h2 id="sql中-Limit1的作用"><a href="#sql中-Limit1的作用" class="headerlink" title="sql中 Limit1的作用"></a>sql中 Limit1的作用</h2><p>在某些情况下,如果明知道查询结果只有一个,SQL语句中使用LIMIT 1会提高查询效率。 只要找到了对应的一条记录,就不会继续向下扫描了,效率会大大提高。</p><p>如果email是索引的话,就不需要加上LIMIT 1,如果是根据主键查询一条记录也不需要LIMIT 1,主键也是索引</p><p>当然，还有最简单的应用是只找出一个</p><h2 id="SpringBoot接收Date型入参和出参"><a href="#SpringBoot接收Date型入参和出参" class="headerlink" title="SpringBoot接收Date型入参和出参"></a>SpringBoot接收Date型入参和出参</h2><p>可以在JavaBean中对Date型数据加注解达到控制入参出参格式的作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">@JsonFormat(timezone = &quot;GMT+8&quot;,pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开这篇blog的来源是因为工作中真的遇到了很多大大小小的问题，平时有空我都会记录下来，但由于又不是很重要或者很难的东西，（一切都源于我菜才会有这些问题），不想为这些分别立一篇，但还是有记录的价值的！（记录了自己成长哈哈哈）&lt;/p&gt;
&lt;p&gt;我会按照内容来做标题，也会order
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>单例模式get</title>
    <link href="http://yoursite.com/2019/01/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fget/"/>
    <id>http://yoursite.com/2019/01/21/单例模式get/</id>
    <published>2019-01-21T12:06:06.000Z</published>
    <updated>2019-01-21T12:11:29.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式使用"><a href="#单例模式使用" class="headerlink" title="单例模式使用"></a>单例模式使用</h2><p>懒汉式：指全局的单例实例在第一次被使用时构建。</p><p>饿汉式：指全局的单例实例在类装载时构建。</p><p>直接来懒汉模式↓</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Single1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Single1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Single1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将构造器改为private的意义在于防止外部类直接调用<br>加同步锁的意义在于防止多个线程同时获取单例并判断是否为空之后都创新的对象</p><p><strong>双重检查（Double-Check）版本</strong></p><p>Version2代码相对于Version1代码的效率问题，其实是为了解决1%几率的问题，而使用了一个100%出现的防护盾。那有一个优化的思路，就是把100%出现的防护盾，也改为1%的几率出现，使之只出现在可能会导致多个实例出现的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 3 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single3 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Single3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Single3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这已经是一个比较完美的单例模式了，最近用大佬代码的时候看到了他这种用单例的方式，就找了<a href="https://www.cnblogs.com/dongyu666/p/6971783.html" target="_blank" rel="noopener">原文博客</a>学到了这种双重检查的方法</p><ul><li><p>第一个if (instance == null)，其实是为了解决Version2中的效率问题，只有instance为null的时候，才进入synchronized的代码段——大大减少了几率。</p></li><li><p>第二个if (instance == null)，则是跟Version2一样，是为了防止可能出现多个实例的情况。</p></li></ul><p>我以为就这样结束了？还有终极版本<strong>volatile</strong></p><p>为解决小概率会发生的原子性问题，</p><p>// Version 4 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (Single4.class) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    instance = <span class="keyword">new</span> Single4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式使用&quot;&gt;&lt;a href=&quot;#单例模式使用&quot; class=&quot;headerlink&quot; title=&quot;单例模式使用&quot;&gt;&lt;/a&gt;单例模式使用&lt;/h2&gt;&lt;p&gt;懒汉式：指全局的单例实例在第一次被使用时构建。&lt;/p&gt;
&lt;p&gt;饿汉式：指全局的单例实例在类装载时构建。&lt;/p
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="http://yoursite.com/2019/01/21/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/21/2018年终总结/</id>
    <published>2019-01-21T12:04:03.000Z</published>
    <updated>2019-01-21T12:05:04.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="年终总结"><a href="#年终总结" class="headerlink" title="年终总结"></a>年终总结</h2><p>hey 2018已经过去了9天了，南京今天下了大雪，从昨晚开始到现在还在下，我仿佛已经过了那个会好好欣赏雪的年纪？雪花很美，但是我只在意今天早上饶了路上班迟到以及鞋子袜子湿了一整天。</p><p>2018让我觉得走的太快，去年这个时候我大概在打包回家过寒假吧，那时候应该刚学完J2EE吧，消薄的一本小绿书，一个副业开滴滴的语速很快的程序员老哥是我们的外聘老师，还记得到期末课程设计的时候只剩下几个人能做的完老师布置得要求。当时感觉班上已经没有几个人还想学这门课了吧，我和男票早早地就完成了这边的作业，听说隔壁班的外聘老师很牛逼，在华为干过，我们就直接溜去了隔壁班听，接触了很多书本上没有的东西。现在想来，不过是一些新的工具，那时候才刚知道maven，强烈地感觉到学校里接触的东西太少了，也太老了</p><p>当时正处于迷茫期，不知道自己该不该考研，但又了解到很多新的东西自己还没学和用到，也不知道自己能不能做一个程序员。虽然没有真的学到什么深的地步吧，基本上也是三天打鱼两天晒网，但我很感谢有男票和我一块互相鼓励督促走了这么一路，起码没有把时间过得太浪费，当然也有很多个晚上我们是靠英雄联盟度过的，当时还为了一个限定的守卫皮肤不依不饶的求了好几个礼拜周末从早到晚做任务。</p><p>后来大四了，我这个班实习得比较早，被学校坑去培训机构后我就再也不相信学校能给我们校招推荐什么好单位了，早早地准备招聘，认真地在网上冲浪，了解行内现在流行的东西，在b站找视频，在论坛上贪婪地学习，另外也一起参加了一个现在觉得是无关紧要的比赛，有些艰难的拿了一个二等奖，之所以说无关紧要是因为选的题目当时完全不了解也没接触过，题目是基于分布式的运维管理平台？【完了 我已经忘记具体的名字了】天呐，选这个题目的时候我连分布式是什么意思都不知道，更别说运维了，我连linux都没学呢= =，但慢慢地这一年过来特别是实习了之后真的遇到了也懂了什么叫做分布式，我胡乱学的Python虽然可以用作比赛的一个小项目，用flask开发的，也知道了其实没什么人用它，java的地位还是不可动摇的，还了解了消息，那时候根本不了解什么是消息队列，【emm 我这一大段没啥语言逻辑，胡乱一打，胡乱一看就好，总之就是当时做了个没什么用的系统，但却是后来学习的敲门砖】</p><p>接下来就是实习，找实习我就基本上校招也去过，通过认识的学长介绍面试也去过，在这样一个小小的三流本科里，我面过的试比当时大多数人要多，大概有七八个吧，这对于6月份的在校大学生已经是很多了吧，一开始极度不自信和紧张，到后来也没那么胆怯了。</p><p>第一个工作我并不会把它作为我以后的工作经历，它将是我2018年最难受的经历之一，这是个校企合作的小外包公司，小到整个公司不如学校一间教室大【当然不是阶梯教室，连普通的小教室都不如】，老板加员工不到二十个人吧。当时一脸期待的我跟着同院的一批男生一块去复试，问了一些框架，第一次面试结结巴巴地但答得不是很糟糕吧，后来通知面试过了，就傻乎乎的去了，明确问了我的实习岗位是什么，答曰实习技术岗，去了之后让我做产品功能分析，座位在那位身兼数职的hr旁边，【还被一个“资深”程序媛嘲讽说坐角落就行，哼 我就是记仇】，而同行的男生都分配了开发的老哥们，唯独我正在下画原型图的工具，当时我就纳闷了，不是技术岗吗？为什么要我看功能需求又画原型的？？？问了之后身兼数职又怀了孕的hr带着公司老板把我拉到会议室，场景是这样的：<br>“我以后难道不敲代码了吗？”<br>“现在公司先这么安排，之后你的岗位事情做得出色了，想要有其他的需求呢，公司都是愿意培养的”<br>“不是说是技术岗吗？我和他们写的都一样，为什么只有我做UI？”<br>“女孩子做UI很吃香的，balabalabala…”<br>那天天气非常糟糕，心情也非常糟糕，下午吃了饭后和老爸商量了之后就直接去辞了，是的，我第一个实习岗位上了大半天的班就走了。</p><p>从第一份实习出来之后情绪很低落，男票是敢做敢说的性格，拿着我的简历到处投，一时之间我来不及低落，只能接受连环面试的轰炸。后来都通过了，毕竟是实习生的面试嘛，最后选了一家中等规模，不用加班，离学校近，做支付的公司。一开始也是被安排做产品，不知是考虑到我的性格不适合还是开发真的缺人打杂，我就顺利地被调去做我心仪的java，他们用自己原有的框架，且没有前后端分工，前端统一是jsp，后端统一是struts2，开发软件是一远古版本的eclipse，数据库是Oracle，当时我管不了这么多，觉得既然能敲代码就已经很感恩了，就高高兴兴地去了，入职三个月，唯一一个被安排的任务是，给22个品牌的汽车台账报表做导入导出与增删改查，且每个报表的格式都不一样，包含的内容也不太相同，却要塞进数据库同一张表里，除了22张报表是最麻烦的之外，其余的工作也都是在处理其他报表和调整报表的格式…其实花一个月就做好了，只是导师一直让我改，改了前后十几二十遍，我还是没能见到甲方看到初版，得到的回复都是你先这么做完，到时候等银行那边看了再协商【也难怪没人做了】上班环境有好有坏，好是非常整洁干净，桌子很大，坏在根本没人和我说话，在他们眼里我可能是个小孩子，我甚至不属于他们部门的人，更没有人教我做什么，我问他们有没有什么需要我做的或我可以了解的项目，看看文档也行，问过很多很多次，都没有，到最后就我全天开始上网冲浪学习其他东西依旧没人理我…于是一些机缘巧合我就又跳了槽</p><p>不，我觉得我并不是一个喜欢折腾的人，相反频繁地换工作让我自己也和难受，但当我意识到我的同龄人正在学习新的知识在你用struts2还整天游手好闲的时候的时候我就坐不住了，我只能靠换一个新的环境来让自己多练一些多学一些。好在第三份实习就是我要找的地方，我知道不能让自己闲下来，其他的管不了太多，可以说我没有明确的规划和方向，只是不能停下来就对了。这篇文章刚写到这，离开头的时候已经差了两个礼拜，中间一直有事情在忙，周末又回家，导致两周前的热情已经消散了，每一天写代码的时候都意识到自己有很多基础要好好扎实，并且要认识理解熟悉那些新的东西，讲道理我连Mybatis用起来还要一边看着百度，业务也是搞不清楚，来了两个多月了吧，能感觉到自己提升了不少，也感觉到自己不会的东西更多了，每一天都很紧迫地想要学习。当然一般遇到问题或不懂的应该问别人，但我又是一个非常胆小的人，能自己解决的就先自己解决，能不麻烦其他人就不麻烦其他人，能用钉钉或微信就绝对不开口，所以总是逮到人家很空闲的时候才敢悄悄问一两个问题，而这些问题可能是我酝酿了好几天的，也许我这个性格太怂了一点，是的我自己也很讨厌。</p><p>吧啦 也没啥想说的 新的一年的计划没有很具体，可以说是愿望吧，一是希望自己能够顺顺利利地度过实习期，学到不少东西，掌握手上用到的技术，二和一相关，希望家人能理解同意自己继续留在南京工作一两年，之后打算在25岁之前回到我的小三线城市找一个对口稳定的工作，三是希望自己存款破万，本来这应该是新年计划的，可是奈何公司组织了一趟深圳香港，给家里人也给自己买了点东西又加上房租和整牙的费用，导致现在离万元存款计划越来越远，吼如果存了万元就奖励自己去迪士尼玩，四是希望和男票开心地度过接下来的一年，待时机合适告诉爸妈自己有男朋友并且得到认可，嘻嘻(oﾟ▽ﾟ)o  ，噢还有五，给自己换一个好用点的电脑</p><p>|*´Å`)ﾉ 没有寒假了很不开心，已经算不清自己现在到底几岁了，感觉日子过得很快，没想到自己已经二十多岁了，哎，想放假</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;年终总结&quot;&gt;&lt;a href=&quot;#年终总结&quot; class=&quot;headerlink&quot; title=&quot;年终总结&quot;&gt;&lt;/a&gt;年终总结&lt;/h2&gt;&lt;p&gt;hey 2018已经过去了9天了，南京今天下了大雪，从昨晚开始到现在还在下，我仿佛已经过了那个会好好欣赏雪的年纪？雪花很美，
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>kafka浅谈</title>
    <link href="http://yoursite.com/2019/01/21/kafka%E6%B5%85%E8%B0%88/"/>
    <id>http://yoursite.com/2019/01/21/kafka浅谈/</id>
    <published>2019-01-21T12:02:28.000Z</published>
    <updated>2019-02-27T12:10:57.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>因为我遇到了Kafka，就记录Kafka的机制吧，先要了解一些概念：</p><p>1.producer &amp; consumer<br>​    消息生产者与消费者<br>2.broker<br>​    kafka集群中包含的服务器，每个broker是一个节点，也可以看做是消费者系统中的一个kafka进程<br>3.topic &amp; partition<br>​    topic相当于消息的key，属于消息的类别，一个topic包含一个或多个partition<br>4.replica<br>​    partition的副本<br>5.<strong>Zookeeper</strong><br>​    管理producer，broker，consumer的动态加入与离开，要用kafka必须启用Zookeeper</p><h3 id="Kafka的高可用性"><a href="#Kafka的高可用性" class="headerlink" title="Kafka的高可用性"></a>Kafka的高可用性</h3><p>Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制，每个partition不止直接给一个broker，而会生成自己的多个replica副本，所有的replica会选举出一个leader出来，所有的生产和消费与leader打交道，其余的replica就是follower。</p><p>写的时候，leader会负责把数据都同步到follower上，Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。<br>这么搞，就有所谓的<strong>高可用性</strong>了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的，如果这上面有某个 partition 的 leader，那么此时会从 follower 中<strong>重新选举</strong>一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p><p><strong>写数据</strong>的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p><p><strong>消费</strong>的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><h3 id="Kafka保证消息不被重复消费（保证消费的幂等性）"><a href="#Kafka保证消息不被重复消费（保证消费的幂等性）" class="headerlink" title="Kafka保证消息不被重复消费（保证消费的幂等性）"></a>Kafka保证消息不被重复消费（保证消费的幂等性）</h3><p>Kafka提供了两套consumer API，high-level API提供了更多的细节，offset能保证消息植被消费一次，每个消息被写的时候都有一个offset存在，代表消息的序号。当消费者消费了数据之后，每隔一段时间就会把自己消费过的消息的offset提交一下，若是要对系统做重启操作，就得冲上次消费到的offset来继续消费。</p><h3 id="Kafka保证消息可靠性（消息不会丢失）"><a href="#Kafka保证消息可靠性（消息不会丢失）" class="headerlink" title="Kafka保证消息可靠性（消息不会丢失）"></a>Kafka保证消息可靠性（消息不会丢失）</h3><p>既然有了offset，也知道offset会自动的刷给kafka，告诉它你已经消费了这些消息，但有一种情况可能是消费者虽自动提交了offset，但其实你刚准备处理这个消息，你还没来得及处理，自己就挂了，但此时kafka已经认为你消费过了。</p><p>那么可以关闭自动提交offset，当你认为处理完消息后再手动提交，但的确可能你处理完还没提交offset自己又挂了那就只能靠自己来保证了</p><p>文章中提到起码要设置下面四个参数：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置 <code>acks=all</code>：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kafka&quot;&gt;&lt;a href=&quot;#Kafka&quot; class=&quot;headerlink&quot; title=&quot;Kafka&quot;&gt;&lt;/a&gt;Kafka&lt;/h2&gt;&lt;p&gt;因为我遇到了Kafka，就记录Kafka的机制吧，先要了解一些概念：&lt;/p&gt;
&lt;p&gt;1.producer &amp;amp;
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="MQ" scheme="http://yoursite.com/tags/MQ/"/>
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>MQ入门</title>
    <link href="http://yoursite.com/2019/01/21/MQ%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/01/21/MQ入门/</id>
    <published>2019-01-21T11:58:03.000Z</published>
    <updated>2019-01-21T12:00:56.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mq"><a href="#Mq" class="headerlink" title="Mq"></a>Mq</h2><p>今天小菜鸡跟着<a href="https://doocs.github.io/advanced-java/#/?id=%e4%ba%92%e8%81%94%e7%bd%91-java-%e5%b7%a5%e7%a8%8b%e5%b8%88%e8%bf%9b%e9%98%b6%e7%9f%a5%e8%af%86%e5%ae%8c%e5%85%a8%e6%89%ab%e7%9b%b2" target="_blank" rel="noopener">Java进阶扫盲</a>好好了解了一下Mq，感觉人家分享的东西写的真的是好呀，我自己写的都是些啥呀，本来不想自己写了，但是害怕自己读了一遍会忘记，并且觉得自己写一遍理解得更好，所以还是想要重新来学习写一篇有关Mq的文章。</p><p>事实上我已经遇到了Activemq与Kafka，没有好好地思考其原理与优缺点，那么废话不多说开始吧。</p><h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><p>之前了解Activemq的时候粗略地了解了一下，当时只是觉得可能是因为处理速度比较快，另外还有一个词——解耦，ok，<strong>解耦</strong>是如何体现的呢？</p><p>倘若现在有一个消息生产者producer，有多个要获取这些消息的消费者，若使用调用接口的方式，producer发消息的同时万一遇到消费者挂了的情况呢？挂了要不要重发？这时候producer和其他需要消费的系统之间有高的耦合，这显然非常地麻烦。</p><p>于是 发布订阅的模式就解决了这一问题，producer只需要丢给Mq消息，消费者自行从Mq里订阅所需要的消息，同时这也解释了为什么用Mq肯定速度比较快，除了producer不需要考虑其他系统外，Mq可以<strong>异步</strong>地被多个消费者订阅。</p><p><strong>削峰</strong></p><p>生产中的消息不可能总是平缓地产生，有个什么活动或周末客户量较大很可能导致系统请求暴增，若依靠普通的基于MySQL不知道要多久，而先刷进Mq，一边等待数据库处理，等系统空闲比如深夜了没什么用户的时候，再慢慢处理Mq中的消息。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>并不是把一个大盒子的东西拆开来放进小盒子就完全没有弊端，万一Mq挂了消息丢了，或是消费者拿到消息后写数据库失败了呢，而且平白多了一个小盒子出来无疑是把整个过程复杂化了，对付这种一致性和可用性问题部分Mq有自己独到的优化方式。</p><h3 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>入门最早用Activemq，实际生产中RabbitMq和Kafka都是优选。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mq&quot;&gt;&lt;a href=&quot;#Mq&quot; class=&quot;headerlink&quot; title=&quot;Mq&quot;&gt;&lt;/a&gt;Mq&lt;/h2&gt;&lt;p&gt;今天小菜鸡跟着&lt;a href=&quot;https://doocs.github.io/advanced-java/#/?id=%e4%ba%92%
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="MQ" scheme="http://yoursite.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的key是否可以为null</title>
    <link href="http://yoursite.com/2018/12/16/HashMap%E7%9A%84key%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%B8%BAnull/"/>
    <id>http://yoursite.com/2018/12/16/HashMap的key是否可以为null/</id>
    <published>2018-12-16T02:58:03.000Z</published>
    <updated>2019-01-21T09:27:28.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap的key可以为null吗？"><a href="#HashMap的key可以为null吗？" class="headerlink" title="HashMap的key可以为null吗？"></a>HashMap的key可以为null吗？</h2><p>​    这问题太基础了，回答是<strong>可以</strong>，但不得不说很久时间不回顾，我已经忘了！前一段时间遇到的时候我想当然地以为不可以，可见当做考试记的东西忘得真的太容易了。</p><p>​    HashTable不可以而HashMap可以，HashMap可以存一个key为null的元素，若多个则后来的会覆盖原有的值，并且value均可为空。下面研究一下源码！这样就能加深印象了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>emm，粗粗地看一眼没有对key作null的限制，这个Node就是普通的Node，也没有对key做什么限制，这个hash()方法里返回为0，所以表示key为null时不会报错，是可行哒，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>并且get方法特别处理了值为null的情况</p><p>下面是HashTable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    先看到了value == null会抛空指针异常，下面取了key的hash值，如果此时key为null会有异常，因为他没有对null做特殊处理所以key为null的情况也是不允许的。</p><p>​    题外话看到下面做了个运算，这个&amp; 0x7FFFFFFF，32-bit 十六进制，代表int的最大正整数，二进制是全1。</p><p>​    吼啦  本文完 万恶的周五 让人一点学习的心思都没有 赶紧回宿舍啦</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HashMap的key可以为null吗？&quot;&gt;&lt;a href=&quot;#HashMap的key可以为null吗？&quot; class=&quot;headerlink&quot; title=&quot;HashMap的key可以为null吗？&quot;&gt;&lt;/a&gt;HashMap的key可以为null吗？&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Solr</title>
    <link href="http://yoursite.com/2018/12/16/Solr/"/>
    <id>http://yoursite.com/2018/12/16/Solr/</id>
    <published>2018-12-16T02:57:06.000Z</published>
    <updated>2019-01-21T09:29:16.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><p>​    是一个开源的搜索引擎工具，分布式搜索。说到分布式搜索几个字已经能大致了解他的优势和特点。在此要感谢公司的技术交流氛围，让我了解了不少新技术，但要是一直遇不到场景，难免会忘记，所以现在记录下来。</p><p>​    初印象是Solr的速度非常之快，他的原理大致为可以把关系型数据库的数据搬出来，基于数据的索引可进行增删改查（也是为什么它很快的一个原因），支持用户自定义的分词器，教程里写可以与Hadoop一起使用，但好吧我还不了解Hadoop…</p><p>​    上面说他把数据库的数据搬出来，Solr不仅支持查询，其实也是一个变相的数据库，没错他应该是算作NoSQL的，它是支持存储，可扩展的，处理大量数据的搜索引擎。</p><p>​    官方的教程已经非常详细，这边也不做多余的操作步骤，大概讲个流程。推荐教程，<a href="https://www.w3cschool.cn/solr_doc/solr_doc-1r4g2flx.html" target="_blank" rel="noopener">W3C</a>， <a href="https://www.yiibai.com/solr/apache_solr_terminology.html" target="_blank" rel="noopener">易百</a>，</p><p>​    导入数据需要在xml里配置数据库信息，开启Solr服务后有个可视化的仪表盘，可以看到Solr的占存、分片情况等，可以在查询面板里执行查询操作，有一些参数</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>q</td><td>这是<strong>Apache Solr</strong>的主要查询参数，文档根据它们与此参数中的术语的相似性来评分。</td></tr><tr><td>fq</td><td>这个参数表示<strong>Apache Solr</strong>的过滤器查询，将结果集限制为与此过滤器匹配的文档。查询结果被限制为仅搜索筛选器查询返回的结果。</td></tr><tr><td>start</td><td><code>start</code>参数表示页面的起始偏移量，此参数的默认值为<code>0</code>。</td></tr><tr><td>rows</td><td>这个参数表示每页要检索的文档的数量。此参数的默认值为<code>10</code>。</td></tr><tr><td>sort</td><td>这个参数指定由逗号分隔的字段列表，根据该列表对查询的结果进行排序。</td></tr><tr><td>fl</td><td>这个参数为结果集中的每个文档指定返回的字段列表。</td></tr><tr><td>wt</td><td>这个参数表示要查看响应结果的写入程序的类型。</td></tr></tbody></table><p>​    Solr索引（Document），它类似与关系型数据库表中的一条记录，可以包含多个字段（Field），每个字段包含name和value，通常文档都包含一个能唯一表示该数据的id字段，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">doc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span>company123<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"companycity"</span>&gt;</span>Atlanta<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"companystate"</span>&gt;</span>Georgia<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"companyname"</span>&gt;</span>Code Monkeys R Us, LLC<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"companydescription"</span>&gt;</span>we write lots of code<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"lastmodified"</span>&gt;</span>2013-06-01T15:26:37Z<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">doc</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Field座位构成Document的基本单元，除了name和value还有一些其他属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text_general"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Indexed：Indexed=true时，表示字段会加被Sorl处理加入到索引中，只有被索引的字段才能被搜索到。</li><li>Stored：Stored=true，字段值会以保存一份原始内容在在索引中，可以被搜索组件组件返回，考虑到性能问题，对于长文本就不适合存储在索引中。</li></ul><p><strong>核心（core）</strong>，封装单个物理索引。一个或多个组成集合的逻辑碎片(或片)。当数据量大的时候，需要分布式的solr，这时拆分后的数据就存放在一个个core中，一个collection下可以有一个或多个core，而core可以看做一个容器，是数据碎片所在的地方，但是担心一台机器里出故障，所以碎片有重复的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Solr&quot;&gt;&lt;a href=&quot;#Solr&quot; class=&quot;headerlink&quot; title=&quot;Solr&quot;&gt;&lt;/a&gt;Solr&lt;/h2&gt;&lt;p&gt;​    是一个开源的搜索引擎工具，分布式搜索。说到分布式搜索几个字已经能大致了解他的优势和特点。在此要感谢公司的技术交流氛
      
    
    </summary>
    
      <category term="搜索引擎" scheme="http://yoursite.com/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="搜索引擎" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="Solr" scheme="http://yoursite.com/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>关系型数据库与非关系型数据库</title>
    <link href="http://yoursite.com/2018/12/16/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/16/关系型数据库与非关系型数据库/</id>
    <published>2018-12-16T02:56:53.000Z</published>
    <updated>2019-01-21T09:30:46.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系型数据库与非关系型数据库"><a href="#关系型数据库与非关系型数据库" class="headerlink" title="关系型数据库与非关系型数据库"></a>关系型数据库与非关系型数据库</h2><p>​    先来了解一些概念，慢慢来：</p><p>​    <strong>NoSQL</strong></p><p>​    查百度真的是云里雾里的，好在知乎的老哥们说话都很好听，人家的名字叫<strong>Not Only SQL</strong>（不仅仅是SQL），缩写叫NoSQL，取名叫非关系型数据库，其他的我们等等再说</p><p>​    <strong>ACID</strong></p><p>​    事务的特性，【这可是我遇到的第一道面试题啊我怎么能忘了呢？】原子性、一致性、隔离性、持久性，照理来说关系型数据库都支持ACID，而NoSQL是让你在CAP（一致性，可用性，分区容忍度）中的任意两项做选择</p><p>​    <strong>面向对象与关系型</strong></p><p>​    好吧这个标题起的并不好，但我想用日常学和用的东西来理解什么是关系型，我们的Java是个面向对象的语言，关系型数据库也就是我们平时最常用的主流数据库，他们一般有固定的表结构、表与表的关系（对象间的关系）。关系数据库与SQL离不开，可以说关系数据库就是基于SQL而产生的，使用SQL语句使我们的认知与计算机所能理解的数据库衔接在一起。</p><p>​    【所以面向对象对应的就是关系型数据库…】</p><p>​    关系型数据库有很多优点呀比如易理解使用方便，毕竟操作起来是通过SQL的，我们通常把一个类的数据存在一张表里，那么为什么会发展出非关系型数据库呢？首先最严重的瓶颈是高并发与高频率，这个很好理解，比如网站每秒产生的数据量非常巨大，在海量的数据库表中做增删改查效率很低，还有一点就是难以扩展，比如当你有了很多数据之后，当我想对项目进行更新维护，难免要遇到数据迁移，或一个服务器内的这个数据库占得太大了，但我又没法方便快捷的对其进行升级与扩展，</p><p>​    那么NoSQL就衍生了，他以键值对存储，且结构不固定，没有固定的对象结构，你可以根据需要往同一个uid后面加上需要的与之相关的不同“字段”，那么其实一直学并用的关系型数据库的强大的SQL搜索能力是比NoSQL好得多，它不能像SQL一样通过where给很多条件进行多表查询，事实上他根本没有表的概念，但它的优点弥补了SQL几乎所有的缺点，事实上生产中我们应该避免过复杂的多表连接</p><p>​    上面说到传统关系型数据库支持ACID，特别是一致性，关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差，像微信微博等对消息高并发的应用来说一致性并没有这么重要，所以这就是“<strong>NoSQL是让你在CAP（一致性，可用性，分区容忍度）中的任意两项做选择</strong>”的意思</p><p>​    现在我已经理解了什么是关系型非关系型，比如关系型数据库有Oracle，MySQL，非关系型有redis，才疏学浅，其他的还不会用。</p><p>​    可能我言语间可能有强调非关系型数据库，因为看到的很多答案都是非关系型更好更快怎么样，这也许是这些回答的大佬们认为我们已经非常了解什么叫关系型吧，但其实这两个没有孰优孰劣，看到一篇文章中说这就像问轮船会不会取代汽车一样，现在NoSQL很火，那可能是因为我们需要他的时代来得相对晚一些，认为这是一个新的趋势，但完全替代还是不可能的，对不太需要后续增删改查的数据放进关系型数据库，对高并发需要扩展的数据采用非关系型数据库，对面向文档的数据存在MongoDB。</p><p>​    我真是太菜了呀，码这些字花了我好久时间啊哈哈！有哪里不对的还请指正呀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关系型数据库与非关系型数据库&quot;&gt;&lt;a href=&quot;#关系型数据库与非关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库与非关系型数据库&quot;&gt;&lt;/a&gt;关系型数据库与非关系型数据库&lt;/h2&gt;&lt;p&gt;​    先来了解一些概念，慢慢来：&lt;/p&gt;
      
    
    </summary>
    
      <category term="Nosql" scheme="http://yoursite.com/categories/Nosql/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>代码重构</title>
    <link href="http://yoursite.com/2018/12/16/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/"/>
    <id>http://yoursite.com/2018/12/16/代码重构/</id>
    <published>2018-12-16T02:56:35.000Z</published>
    <updated>2019-01-21T09:30:22.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h2><p>​    有一天部门里大哥跟我说要注意注释和优雅的代码，当然如果我知道怎么做的话我也很想写得非常清爽人性化。</p><h3 id="1-常量"><a href="#1-常量" class="headerlink" title="1.常量"></a>1.常量</h3><p>​    之前一个单位程序员的平均年龄有30+，用的东西也很古老但非常稳定，他们喜欢把常量都放在配置文件里，于是我也这么做并且我当时做的东西没有什么交互，所有功能都是我傻乎乎的用相似的代码模仿实现的。但现在我手上的是个springboot项目，观察里面的除了application.yml就没有其他的配置文件了，思考难道这种放在配置文件里的方式过时了吗？于是我现在把普通常量放在常量类里，而当我要调用别人接口的时候把url字符串放在枚举类中。</p><p>​    如果是常量类中，为了防止你的常量真真切切的为不会变的量，最好满足不会被继承的能力，即加final，但貌似也有其他方法如一般类加私有构造函数的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contants</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Contants</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String balabala = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    更优的方法是枚举，在之前我其实没实际接触过枚举，也是看到大哥的代码才知道枚举可以这么用，给枚举定个name和value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ContantsEnum&#123;</span><br><span class="line">    <span class="comment">//命名规则为第一个Bala为模块名，第二个是功能或方法名，XXX大写为常量名，我自己的规则哈也可以是别的</span></span><br><span class="line">    Bala_FunPrefix_XXX(<span class="string">"XXX"</span>,<span class="string">"https://balabala"</span>),</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContantsEnum(String name,String value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    感觉都说枚举更优是因为用起来很方便，直观吧。</p><h3 id="2-工具类"><a href="#2-工具类" class="headerlink" title="2.工具类"></a>2.工具类</h3><p>​    不想再重复劳动啦，那就自己写工具包吧，虽然写的时候真的要非常严谨，还要想好有哪些重载的方法，会遇到哪些参数，一旦有一点一句不清楚都要搞到清楚为止才敢往上写</p><p>​    提高代码的复用性，让IDEA旁边的黄色标记变少些，加油叭！</p><h3 id="3-长度"><a href="#3-长度" class="headerlink" title="3.长度"></a>3.长度</h3><p>​    这不仅有方法的长度还有类的长度，一个类里面已经装了七八个方法了，再写的时候就想想能不能分两个类，方法体不能太长也是不用说的了</p><p>最近在看《重构 改善及有代码的设计》，看到什么其他的再加</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代码重构&quot;&gt;&lt;a href=&quot;#代码重构&quot; class=&quot;headerlink&quot; title=&quot;代码重构&quot;&gt;&lt;/a&gt;代码重构&lt;/h2&gt;&lt;p&gt;​    有一天部门里大哥跟我说要注意注释和优雅的代码，当然如果我知道怎么做的话我也很想写得非常清爽人性化。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>我之所以做程序员</title>
    <link href="http://yoursite.com/2018/12/16/%E6%88%91%E4%B9%8B%E6%89%80%E4%BB%A5%E5%81%9A%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    <id>http://yoursite.com/2018/12/16/我之所以做程序员/</id>
    <published>2018-12-16T02:52:17.000Z</published>
    <updated>2019-03-03T02:47:37.216Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天还和往常一样早上没什么事的话打开v站和新闻翻翻，看到一个自己也很想问的帖子，<a href="https://www.v2ex.com/t/514101?p=1" target="_blank" rel="noopener">这个</a>，看了几个大佬们的博客，想起来自己有挺久不爱整博客了，仿佛也就刚建时一时兴起写了几篇，主要用途是像备忘录一样的东西，没什么要求也没什么标准，今天开始多一些生活和所见所闻叭。</p><p>​    这些天总体来说挺闲的，有很多想说的但是又有懒得缘故就没有记下来，也有一些新的东西叭。</p><h2 id="我之所以做程序员"><a href="#我之所以做程序员" class="headerlink" title="我之所以做程序员"></a>我之所以做程序员</h2><p>​    周一看到一篇文章标题实在是太吸引我了<a href="https://coolshell.cn/articles/6346.html" target="_blank" rel="noopener">【程序员因为女孩而美丽】</a>是在我一贯喜欢翻大佬们所有过去的文章时一眼看到的，看完后我立马想到身边刚放弃考研正在找工作但未果的小A，分享给了她(ﾉ”◑ ◑)ﾉ”(｡•́︿•̀｡)</p><p>​    -我为什么学这个呢？ -我是不是不适合做程序员我真的好菜啊。</p><p>​    大概每天下班的时候我都会有这种想法，好在我有个能听我说话也同样是程序员的男朋友，总是会鼓励我。</p><p>​    我选计算机其实是在一篮筐烂苹果里选了个比较好的。初中的时候刚开始成绩比较普通，后来遇到了个特别棒的老师，燃起了我对数学的激情，开始喜欢解大家都解不出来的难题，那个时候作业最后一题做到十二点钟睡觉还想着第二天起早和老爸一起讨论题目的日子真的特别难忘。在经历了艰苦又充实的初中后考了个当地最好的学校，在那之后我总是觉得自己的人生一路down，但可能那时候的拼劲影响了我选专业。我应该算比较内向的人，没人可以噼里啪啦的话就写日记吐槽给自己看，高中过得就好像一个白银选手不小心定级了钻石段位的感觉，过得比较浑浑噩噩，虽然也很认真地学习，却一点都没有了以前的快乐，<strong>不快乐的学习是不可能成功的！</strong>也阴差阳错去了文科班，本来英语和文言文就很差，去了之后感觉自己简直就是最差了，那感觉真的太可怕了。痛苦，痛苦到不想再体验一次了。</p><p>​    高考不出意外的考得很烂，因为到最后已经是被文科的课整的快崩溃了的边缘，当时感觉这辈子就要完了，从小到大都非常听话，除了学习也没有接触什么其他擅长的东西，觉得高考砸了一辈子都毁了的感觉。填志愿时第一次拿起了那本之前从来没翻过的招生册【一二本与三本专科是不同的招生册】，打开来是一些从来没听过名字的野鸡学院，专业也是非常单调，金融、经管、护理、师范，最后看到有个三本的计算机专业文理兼招，所以头三个选的都是计算机院的专业，当时只是一个原因：其他的都没意思，就这个有意思。</p><p>​    我接触计算机其实没什么天赋，时间也不长，家里的电脑除了用它来玩过游戏之外没干过别的，高一的时候进了一个人工智能的社团，但程度仅限于在面包板上连线路，复制一段老师给的现成的代码，改一下里面的数然后让小灯泡或小喇叭冒不同节奏的声响，但要理解他们简直是不可能的好嘛，我连自己功课都搞不定还来研究代码？</p><p>​    大学刚开始学c和java的时候我都能很快地入门吧，也不知道是不是其他人都不爱学反正我学的的确比他们好，大学第一个学期过二级和参加一些小竞赛，虽然学校不怎么样但老师也是有负责的，培养我们这群小废物还是很尽职尽责的，于是大一的时候经常上水课研究算法题，熬夜敲代码，有的时候到一两点。虽然熬夜对男生可能不算什么大事吧，但在女生宿舍我几乎就是个奇葩了，包括我还和班里男生一起打lol，深夜等大家睡了看惊悚片之类…不过很后悔自己爱上了打游戏，不然能省下不少时间学习。还有熬夜…后来开始慢慢地熬不了夜了，现在也维持着每天十一点多睡的习惯。</p><p>​    我开始慢慢喜欢敲代码吧，在为数不多的但是一个系所有16个女生里面，走到现在，唯一一个做开发的，感觉过得其实跟男孩子差不多。看到那篇文章里的很多分享，感同身受，找实习的过程比较艰辛，也许以后会更加艰辛，人家会自然而然觉得女生不行，尽管他们嘴上没说，但真的到我体会过来回想，会觉得非常不公平。</p><p>​    我知道刚实习跳来跳去不好，但在那些地方就是浪费时间，于是我出现在这里，一个网络公司，做java开发。大家还比较照顾我，尽管我还是那个一遇到问题心里就乱着急的萌新，做得东西还比较简单，总是遇到大大小小的bug，但每次自己找到哪错了和解决之后都很满足。</p><p>​    我还想学习，还想敲代码，因为很开心，就这样。也许有其他工作也会让我觉得快乐，但我正好碰到了一个还不错的，为什么不能试试呢？</p><h2 id="杂谈-12-14"><a href="#杂谈-12-14" class="headerlink" title="杂谈 12/14"></a>杂谈 12/14</h2><p>嘿哈，这里又是一个一天没有任务的逛知乎的实习生，想巴拉一些实习到现在的经历和感受。</p><p>​    前面也说过我是个渣渣本三的学计算机的，我的专业有点特殊，名字后面带了嵌入式，其实也就是校企合作的班级，算是试验班。学费比别人高一些，前三年学的课完全一样，差点就以为自己被坑了白多交钱了。直到大四才知道只有我们系和另两个抽出来的软工班，也就是院里面的一小部分学生可以提前出来实习，而且实习单位必须得是校企！</p><p>​    大四刚开始我们班上了六周课，补了一些数据库和网络通信方面的知识，就开始了长达四个月的被“安排”的日子。我们从学校被赶到培训机构（也算是大企业的培训机构）学习，这是我活到现在觉得最坑的事！原来我们多交的钱就是为了来这种地方培训！我不知道外面其他培训机构是什么样的，反正就我那个班去的地方真的很垃圾。老师以龟速从helloworld开始讲java基础，讲了两个月，接着又换了一个更差的老师从html，div+css开始讲网页设计。我并没有说基础不重要的意思，但是让一群就快要找实习了的CS班的人用龟速复习一堆比学校里学的还少的知识，还要每天做一堆明明就很简单的重复的作业，真的很侮辱人。我也第一次和学校老师反映这边的学习进度和老师都不ok，而第二天，机构这边的“老师”就知道我在他们背后打小报告了，开始“特别关注”我，第二周，院长跑到班上来考察我们的情况，看到我们班的嬉皮们在下面激烈鼓掌夸赞，我就明白了，自己还是太年轻。</p><p>​    其实我早该知道学校和机构这边就是合伙了把我们这群废物卖来补基础中的基础，我还妄想能学点新的东西，还妄想学校会顾忌自己抛出去的学生。<strong>有问题可以提意见的意思不是你真的可以提意见，而是你敢提意见吗</strong></p><p>​    很多人家里真的有矿，很多人真的不学习不努力也可以过得很好，做舔狗的下场并不是一无所有，而不做舔狗说不定会一无所有，当你发现你和周围的看法都不一样时，努力让自己换个环境就好了。但我也许现在一无所有，只能靠自己，防止自己堕入更差的环境中。</p><p>​    高中班主任有一次班会让我印象特别深，他说也许有很多人并没有大的目标和梦想，长大了就想做个普通人，上一个常白班，朝九晚五，回到家吃热的饭菜，周末好好休息，看个电影饭后散散步，即使是这样的生活，也需要你很努力很努力才能得到，并没有想象的这么简单。也许这是对我这样的家里没矿的人最真实的总结吧。</p><h2 id="今日乐子：Cookie的诞生"><a href="#今日乐子：Cookie的诞生" class="headerlink" title="今日乐子：Cookie的诞生"></a><strong>今日乐子：Cookie的诞生</strong></h2><p>刚出生的婴儿认为世界就是他能看到的东西组成的。你离开房间的时候，他觉得你消失了；你回来的时候，对他来说已经是一个全新的人。到四个月以后，它会在某个时间以上掉这个世界比他想象中更加稳定，每天早上喝晚上对他打招呼的你都是同一个人。也就是说婴儿们终于有Cookie了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    今天还和往常一样早上没什么事的话打开v站和新闻翻翻，看到一个自己也很想问的帖子，&lt;a href=&quot;https://www.v2ex.com/t/514101?p=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个&lt;/a&gt;，看了几个大佬们的博客
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>json型字符串取值</title>
    <link href="http://yoursite.com/2018/11/25/json%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%96%E5%80%BC/"/>
    <id>http://yoursite.com/2018/11/25/json型字符串取值/</id>
    <published>2018-11-25T02:48:07.000Z</published>
    <updated>2019-01-21T11:56:54.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="json型字符串取值"><a href="#json型字符串取值" class="headerlink" title="json型字符串取值"></a>json型字符串取值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        JSONObject object = JSON.parseObject(msg);</span><br><span class="line">        String resultMsg = object.getString(<span class="string">"data"</span>);</span><br><span class="line">        <span class="keyword">return</span> resultMsg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><p>​    都8012年了我还用这么原始的方法嘛，如果遇到了bean怎么办，有更好的工具：Gson和Jackson，这里只讲Gson。Gson提供了<code>fromJson()</code> 和<code>toJson()</code> 两个直接用于解析和生成的方法，前者实现<strong>反序列化</strong>，后者实现了<strong>序列化</strong>。</p><p>Serialization:序列化，使Java对象到Json字符串的过程。</p><p>Deserialization：反序列化，字符串转换成Java对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最简单的用法</span></span><br><span class="line"><span class="comment">//toJson：将对象转换为json字符串</span></span><br><span class="line">String jsonstr = <span class="keyword">new</span> Gson().toJson(user, User.class);</span><br><span class="line"><span class="comment">//fromJson：将就送字符串转化为对象</span></span><br><span class="line">User user = <span class="keyword">new</span> Gson().fromJson(jsonstr, User.class);</span><br></pre></td></tr></table></figure><p>​    但序列化和反序列化的过程中，期望的驼峰格式会被转成实际的下划线格式，解决这个问题可以用@SerializedName注解，在实体类定义属性的时候加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SerializedName</span>(<span class="string">"email_address"</span>)</span><br><span class="line"><span class="keyword">public</span> String emailAddress;</span><br></pre></td></tr></table></figure><p>​    如果接收的格式不止两种，还可加alternate参数，可以看做是给属性加多个“别称”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SerializedName</span>(value = <span class="string">"emailAddress"</span>, alternate = &#123;<span class="string">"email"</span>, <span class="string">"email_address"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> String emailAddress;</span><br></pre></td></tr></table></figure><p>​    除了Object，基本数据类型的json生成与解析也是可以的，只是意义不大。另外还可对List、Map、Set等，一一来研究：</p><p>​    <strong>温馨提示：如若需要频繁操作，直接创一个gson对象，以免不必要的资源浪费，但我比较懒，所以下面写的都是new Gson().balabala，后面我会总结一个工具类，这里就当个demo看看</strong></p><h3 id="List转化"><a href="#List转化" class="headerlink" title="List转化"></a>List转化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个带泛型的list，我们想把它转为json</span></span><br><span class="line">List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">list.add(user1);</span><br><span class="line">list.add(user2);</span><br><span class="line">list.add(user3);</span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> Gson().toJson(list);</span><br><span class="line"><span class="comment">//转回泛型list有点复杂，要用TypeToken</span></span><br><span class="line">List&lt;User&gt; resultlist = <span class="keyword">new</span> Gson().fromJson(str,<span class="keyword">new</span> TypeToken&lt;List&lt;User&gt;&gt;() &#123;&#125;.getType());</span><br></pre></td></tr></table></figure><h3 id="Map转化"><a href="#Map转化" class="headerlink" title="Map转化"></a>Map转化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个普通的Map，我们把key定义为string，value定义为一个Object</span></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"a"</span>,user1);</span><br><span class="line">map.put(<span class="string">"b"</span>,user2);</span><br><span class="line"><span class="comment">//把map转为json</span></span><br><span class="line">String str = <span class="keyword">new</span> Gson().toJson(map);</span><br><span class="line"><span class="comment">//换回map也要用TypeToken</span></span><br><span class="line">Map&lt;String, Object&gt; resultmap = <span class="keyword">new</span> Gson().fromJson(str,<span class="keyword">new</span> TypeToken&lt;Map&lt;String,Object&gt;&gt;() &#123;&#125;.getType());</span><br></pre></td></tr></table></figure><h3 id="Set转化"><a href="#Set转化" class="headerlink" title="Set转化"></a>Set转化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个简单的Set，里面存的是String</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">"bala"</span>);</span><br><span class="line">set.add(<span class="string">"balala"</span>);</span><br><span class="line"><span class="comment">//把set转为json</span></span><br><span class="line">String str = <span class="keyword">new</span> Gson().toJson(set);</span><br><span class="line"><span class="comment">//换回set</span></span><br><span class="line">Set&lt;String&gt; resultset = <span class="keyword">new</span> Gson().fromJson(str,<span class="keyword">new</span> TypeToken&lt;Set&lt;String&gt;&gt;() &#123;&#125;.getType());</span><br></pre></td></tr></table></figure><h3 id="GsonUtil"><a href="#GsonUtil" class="headerlink" title="GsonUtil"></a>GsonUtil</h3><p>吼啦，贴一个自己用的GsonUtil，只写了一个转化list的，因为我只用到了这个，以后用到了再加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.JsonObject;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.reflect.TypeToken;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: UnifiedBgManage</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Gson-处理json字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: WYuyin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-12-13 11:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(GsonUtil.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toJson</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gson.toJson(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toJson</span><span class="params">(Object o , Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gson.toJson(o,type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">toObject</span><span class="params">(String jsonstr , Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(jsonstr,type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 由于比较懒，直接把jsonstr里的值获取出来</span></span><br><span class="line"><span class="comment">     * 例："&#123;\"data\":[],\"desc\":\"1000\",\"pageNum\":1,\"status\":\"success\",\"total\":0&#125;"</span></span><br><span class="line"><span class="comment">     *  -&gt; "[]"</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [jsonstr, title]  title:key 比如"data","status"...</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: java.lang.String </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: WYuyin</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getData</span><span class="params">(String jsonstr , String title)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        JsonObject jsonObject = gson.fromJson(jsonstr,JsonObject.class);</span><br><span class="line">        String resultstr = <span class="string">""</span> + jsonObject.get(title);</span><br><span class="line">        <span class="keyword">return</span> resultstr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 将数组字符串转化为list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [liststr] </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: java.util.List&lt;T&gt; </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: WYuyin</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">toList</span><span class="params">(String liststr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;T&gt; resultlist = gson.fromJson(liststr, <span class="keyword">new</span> TypeToken&lt;List&lt;T&gt;&gt;() &#123;&#125;.getType());</span><br><span class="line">        <span class="keyword">return</span> resultlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##Jackson</p><p>大概一个月前整理了一个Gson的用法，但只会Gson怎么够呢，我得看得懂其他人的代码呀，嘿，事实上现在的我就是这样，不同的人给我他们的代码，让我加东西的时候我总要模仿他们的写法，比如有些人不爱写长注释，有些人用Gson而有些人用Jackson…</p><p>为了把json数据映射到对象上，你需要：有一个包含你需要的属性值的实体类，类的属性名称与json中的key一一对应，若遇到大小写混乱或下划线的用<strong>@JsonProperty(“xxx”)</strong>标在属性上</p><p>接下来，你可以包装一个jackson的工具类，主要用Jackson ObjectMapper对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonJsonUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Jackson ObjectMapper对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">object2String</span><span class="params">(Object object)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectMapper.writeValueAsString(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">string2Object</span><span class="params">(String jsonString, Class&lt;T&gt; classType)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectMapper.readValue(jsonString, classType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">string2List</span><span class="params">(String jsonString, Class&lt;T&gt; valueClassType)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectMapper.readValue(jsonString, objectMapper.getTypeFactory().constructParametricType(ArrayList.class, valueClassType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;json型字符串取值&quot;&gt;&lt;a href=&quot;#json型字符串取值&quot; class=&quot;headerlink&quot; title=&quot;json型字符串取值&quot;&gt;&lt;/a&gt;json型字符串取值&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>工具类HttpClientUtil</title>
    <link href="http://yoursite.com/2018/11/25/%E5%B7%A5%E5%85%B7%E7%B1%BBHttpClientUtil/"/>
    <id>http://yoursite.com/2018/11/25/工具类HttpClientUtil/</id>
    <published>2018-11-25T02:45:47.000Z</published>
    <updated>2019-01-21T11:55:39.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HttpClientUtil"><a href="#HttpClientUtil" class="headerlink" title="HttpClientUtil"></a>HttpClientUtil</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jinbei.common.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.NameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.ClientProtocolException;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity.UrlEncodedFormEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.utils.URIBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message.BasicNameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: UnifiedBgManage</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: HttpClient工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: WYuyin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-11-22 13:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CloseableHttpClient client = HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url, Map&lt;String, String&gt; param,Map&lt;String,String&gt; headers)</span> </span>&#123;</span><br><span class="line">        String resultString = <span class="string">""</span>;</span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URIBuilder uri = <span class="keyword">new</span> URIBuilder(url);</span><br><span class="line">                <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                        uri.addParameter(key, param.get(key));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            HttpGet get = <span class="keyword">new</span> HttpGet(uri.build());</span><br><span class="line">                <span class="keyword">if</span> (headers != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (String key :headers.keySet()) &#123;</span><br><span class="line">                        get.setHeader(key,headers.get(key));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                response = client.execute(get);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>)&#123;</span><br><span class="line">                    resultString = EntityUtils.toString(response.getEntity(), <span class="string">"UTF-8"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (response != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doGet(url,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url, Map&lt;String, String&gt; param)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doGet(url,param,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, Map&lt;String, String&gt; param,Map&lt;String,String&gt; headers)</span></span>&#123;</span><br><span class="line">        String resultString = <span class="string">""</span>;</span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span>)&#123;</span><br><span class="line">                List&lt;NameValuePair&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                    paramList.add(<span class="keyword">new</span> BasicNameValuePair(key, param.get(key)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 模拟表单</span></span><br><span class="line">                UrlEncodedFormEntity entity = <span class="keyword">new</span> UrlEncodedFormEntity(paramList,<span class="string">"utf-8"</span>);</span><br><span class="line">                httpPost.setEntity(entity);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (headers != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (String key :headers.keySet()) &#123;</span><br><span class="line">                    httpPost.setHeader(key,headers.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            resultString = EntityUtils.toString(response.getEntity(),<span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, Map&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doPost(url,param,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doPost(url,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好使用doPost，doGet不太安全</p><h3 id="HttpClient的精简用法"><a href="#HttpClient的精简用法" class="headerlink" title="HttpClient的精简用法"></a>HttpClient的精简用法</h3><p>之前学习了HttpClient的用法，也自己包了一个工具类，前两天看了大佬的代码，</p><p><img src="/2018/11/25/工具类HttpClientUtil/C:/Users\Administrator\AppData\Roaming\Typora\typora-user-images\1546915517113.png" alt="1546915517113"></p><p>我称其为HttpClient的精简用法吧，这省了很多事情，起码自己不用去归纳一套流程了，熟练了也是非常方便的，而且还适应了各种情景：加请求头，参数，编码，timeout时间，真的是非常便捷了，emm 请忽略我截图里面多了一个bodyForm的操作。</p><p>改响应数据编码为utf-8我找了好久，最后就在自动显示的所有方法里看到有个加Charset参数的，开心(<em>^▽^</em>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HttpClientUtil&quot;&gt;&lt;a href=&quot;#HttpClientUtil&quot; class=&quot;headerlink&quot; title=&quot;HttpClientUtil&quot;&gt;&lt;/a&gt;HttpClientUtil&lt;/h2&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>@Transactional</title>
    <link href="http://yoursite.com/2018/11/25/Transactional/"/>
    <id>http://yoursite.com/2018/11/25/Transactional/</id>
    <published>2018-11-25T02:43:24.000Z</published>
    <updated>2019-01-21T09:29:44.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h2><p>标注在方法上可以实现一个事务</p><p>Spring事务管理有编程式和声明式两种，前者通过编码方式，后者基于AOP，代码逻辑不受污染，使用的也较多。声明式事务有两种实现方式，一种是在xml里做相关声明，另一种就是用@Transactional。</p><p>但使用时，若在同一个类中，若其中的方法1调用了方法2，且两者都被标注了@Transactional则只被看成一个事务，方法2不会被Spring的事务拦截器拦截，解决方法可以分两个类写或者用AspectJ取代AOP，但我没有做验证。</p><p>另外该注解可以有属性值</p><p><strong>value/transactionManager</strong></p><p>这两个是一个意思，指定事务的名字</p><p><strong>propagation</strong></p><p>可选的值有：</p><p>Propagation.REQUIRED</p><p>如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。</p><p>Propagation.SUPPORTS</p><p>如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</p><p>Propagation.MANDATORY</p><p>如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</p><p>Propagation.REQUIRES_NEW</p><p>重新创建一个新的事务，如果当前存在事务，暂停当前的事务。</p><p>Propagation.NOT_SUPPORTED</p><p>以非事务的方式运行，如果当前存在事务，暂停当前的事务。</p><p>Propagation.NEVER</p><p>以非事务的方式运行，如果当前存在事务，则抛出异常。</p><p>Propagation.NESTED</p><p>和 Propagation.REQUIRED 效果一样。</p><p><strong>isolation</strong></p><p>事务的隔离级别</p><p>还有一些感觉不太会用到吧不多啰嗦了用到再查</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Transactional&quot;&gt;&lt;a href=&quot;#Transactional&quot; class=&quot;headerlink&quot; title=&quot;@Transactional&quot;&gt;&lt;/a&gt;@Transactional&lt;/h2&gt;&lt;p&gt;标注在方法上可以实现一个事务&lt;/p&gt;
&lt;p&gt;Sp
      
    
    </summary>
    
      <category term="spring boot" scheme="http://yoursite.com/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo入门</title>
    <link href="http://yoursite.com/2018/11/25/Dubbo%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/11/25/Dubbo入门/</id>
    <published>2018-11-25T02:41:53.000Z</published>
    <updated>2019-03-03T02:40:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo是什么"><a href="#Dubbo是什么" class="headerlink" title="Dubbo是什么"></a>Dubbo是什么</h2><p>Dubbo是：</p><ul><li>一款分布式服务框架</li><li>高性能和透明化的RPC远程服务调用方案</li><li>SOA服务治理方案</li></ul><h2 id="Dubbo角色说明"><a href="#Dubbo角色说明" class="headerlink" title="Dubbo角色说明"></a>Dubbo角色说明</h2><p><strong>Provider</strong>: 暴露服务的服务提供方。<br><strong>Consumer</strong>: 调用远程服务的服务消费方。<br><strong>Registry</strong>: 服务注册与发现的注册中心。<br><strong>Monitor</strong>: 统计服务的调用次数和调用时间的监控中心。</p><h2 id="Dubbo注册中心"><a href="#Dubbo注册中心" class="headerlink" title="Dubbo注册中心"></a>Dubbo注册中心</h2><p>你可能兼备服务方与消费方，通过将服务统一管理，来有效的优化对服务发布/使用的流程，<strong>Dubbo提供的注册中心有如下几种类型可供选择</strong>：</p><ul><li>Multicast注册中心</li><li>Zookeeper注册中心</li><li>Redis注册中心</li><li>Simple注册中心</li></ul><h2 id="Dubbo优缺点"><a href="#Dubbo优缺点" class="headerlink" title="Dubbo优缺点"></a>Dubbo优缺点</h2><p>优点：</p><p>1.透明化的远程方法调用 </p><p>​    像调用本地方法一样调用远程方法；只需简单配置，没有任何API侵入。</p><p>2.软负载均衡及容错机制<br>​    可在内网替代nginx lvs等硬件负载均衡器。</p><p>3.服务注册中心自动注册 &amp; 配置管理<br>​    不需要写死服务提供者地址，注册中心基于接口名自动查询提供者ip。<br>​    使用类似zookeeper等分布式协调服务作为服务注册中心，可以将绝大部分项        目配置移入zookeeper集群。</p><p>4.服务接口监控与治理<br>​    Dubbo-admin与Dubbo-monitor提供了完善的服务接口管理与监控功能，针对不同应用的不同接口，可以进行 多版本，多协议，多注册中心管理。</p><p>缺点：</p><p>只支持JAVA语言</p><h2 id="Demo-Zookeeper"><a href="#Demo-Zookeeper" class="headerlink" title="Demo-Zookeeper"></a>Demo-Zookeeper</h2><p><a href="https://blog.csdn.net/hellozpc/article/details/78575773" target="_blank" rel="noopener">https://blog.csdn.net/hellozpc/article/details/78575773</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo是什么&quot;&gt;&lt;a href=&quot;#Dubbo是什么&quot; class=&quot;headerlink&quot; title=&quot;Dubbo是什么&quot;&gt;&lt;/a&gt;Dubbo是什么&lt;/h2&gt;&lt;p&gt;Dubbo是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一款分布式服务框架&lt;/li&gt;
&lt;li&gt;高性能和透明
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>ehcache</title>
    <link href="http://yoursite.com/2018/11/04/ehcache/"/>
    <id>http://yoursite.com/2018/11/04/ehcache/</id>
    <published>2018-11-04T09:09:42.000Z</published>
    <updated>2019-01-21T09:27:09.116Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<a href="https://blog.csdn.net/vbirdbest/article/details/72763048" target="_blank" rel="noopener">https://blog.csdn.net/vbirdbest/article/details/72763048</a></p><h4 id="ehcache与redis比较"><a href="#ehcache与redis比较" class="headerlink" title="ehcache与redis比较"></a>ehcache与redis比较</h4><ul><li>ehcache通常和redis一块使用</li><li>ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。</li><li>redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多， 处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。</li></ul><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>1.pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--EhCache--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.增加配置，可以再resource文件夹下增加</p><p>默认情况下Ehcache会自动加载classpath根目录下名为ehcache.xml文件，也可以将该文件放到其他地方在使用时指定文件的位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"http://ehcache.org/ehcache.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 磁盘缓存位置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir/ehcache"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 默认缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxEntriesLocalDisk</span>=<span class="string">"10000000"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence</span> <span class="attr">strategy</span>=<span class="string">"localTempSwap"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- helloworld缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"HelloWorldCache"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToIdleSeconds</span>=<span class="string">"5"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToLiveSeconds</span>=<span class="string">"5"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以直接写在文件里，Ehcacheconfig.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EhCacheConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ehCacheManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CacheConfiguration cacheConfig = <span class="keyword">new</span> CacheConfiguration();</span><br><span class="line">        cacheConfig.setName(<span class="string">"course"</span>);</span><br><span class="line">        cacheConfig.setMemoryStoreEvictionPolicy(<span class="string">"LRU"</span>);</span><br><span class="line">        cacheConfig.setMaxEntriesLocalHeap(<span class="number">1000</span>);</span><br><span class="line">        cacheConfig.setEternal(<span class="keyword">true</span>);</span><br><span class="line">        net.sf.ehcache.config.Configuration config = <span class="keyword">new</span> net.sf.ehcache.config.Configuration();</span><br><span class="line">        config.addCache(cacheConfig);</span><br><span class="line">        CacheManager cacheManager = CacheManager.newInstance(config);</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.这里对cache做简单的封装：</p><p>先对Cache api做下了解，</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>add(request)</td><td>添加一个请求到缓存</td></tr><tr><td>addAll(List requesets)</td><td>添加一系列请求到缓存</td></tr><tr><td>delete(request,[oprions])</td><td>options可选择如何处理匹配的缓存，有ignoreSearch、ignoreMethod、ignoreVary</td></tr><tr><td>keys(request,[options])</td><td>参数和delete一样，该方法返回一个Promise，即一个Cache键的数组</td></tr><tr><td>match(request,[options])</td><td>request为想要在cache中查找的Promise对象</td></tr><tr><td>matchAll(List requests,[options])</td><td>同上</td></tr><tr><td>put(request,response)</td><td>允许将键值对存到当前缓存</td></tr></tbody></table><hr><p>工具类-EhCacheService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EhCacheService</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建缓存管理器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CacheManager cacheManager = EhCacheConfig.cacheManager();</span><br><span class="line"><span class="comment">//缓存对象</span></span><br><span class="line">    <span class="keyword">private</span> Cache cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EhCacheService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = cacheManager.getCache(<span class="string">"course"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>   获取 ehCache value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCache</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//获取cache中的元素</span></span><br><span class="line">        Element element = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(element == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object object = element.getObjectValue();</span><br><span class="line">        <span class="comment">//转成jsonObject，json-&gt;value,result-&gt;key&amp;value(json)</span></span><br><span class="line">        JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        JSONObject json = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(object != <span class="keyword">null</span>)&#123;</span><br><span class="line">            json = JSONObject.parseObject(object.toString());</span><br><span class="line">            result.put(Contants.TYPE,key);</span><br><span class="line">            result.put(Contants.DATA,json);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>   添加 chCache</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCache</span><span class="params">(String key,String data)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Element element = <span class="keyword">new</span> Element(key,data);</span><br><span class="line">        cache.put(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>   获取cache中所有的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getCacheAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        List&lt;String&gt; keys = cache.getKeys();</span><br><span class="line">        Map&lt;Object, Element&gt; elements = cache.getAll(keys);</span><br><span class="line">        <span class="keyword">for</span> (String key: keys) &#123;</span><br><span class="line">            Element element = elements.get(key);</span><br><span class="line">            JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            <span class="keyword">if</span>(element != <span class="keyword">null</span>)&#123;</span><br><span class="line">                Object object = element.getObjectValue();</span><br><span class="line">                <span class="keyword">if</span>(object != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    JSONObject json = JSONObject.parseObject(object.toString());</span><br><span class="line">                    result.put(Contants.TYPE,key);</span><br><span class="line">                    result.put(Contants.DATA,json);</span><br><span class="line">                    list.add(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>   删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeCache</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>   批量添加缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCacheList</span><span class="params">(List&lt;Element&gt; elements)</span></span>&#123;</span><br><span class="line">        cache.putAll(elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><p>这里拿一个现成的redisConsumer的例子来使用ehcache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * activemq 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(ActiveMqConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EhCacheService ehCacheService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Sub</span></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"$&#123;activemq.topic&#125;"</span> , containerFactory = <span class="string">"topicListenerFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(TextMessage text)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"subscribe : "</span>+ text.getText());</span><br><span class="line">            <span class="keyword">if</span>(text != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//只获取其中的type、data和操作符command</span></span><br><span class="line">                JSONObject json = JSONObject.parseObject(text.getText());</span><br><span class="line">                String key = json.getString(Contants.TYPE);</span><br><span class="line">                String data = json.getString(Contants.DATA);</span><br><span class="line">                String command = json.getString(Contants.COMMAND);</span><br><span class="line">                <span class="keyword">switch</span> (command)&#123;</span><br><span class="line">                    <span class="keyword">case</span> Contants.ADD:</span><br><span class="line">                        <span class="comment">//将消息数据存入ehcache</span></span><br><span class="line">                        ehCacheService.addCache(key,data);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Contants.UPDATE:</span><br><span class="line">                        ehCacheService.addCache(key,data);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Contants.DELETE:</span><br><span class="line">                        ehCacheService.removeCache(key);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        logger.info(<span class="string">"method is not found ..... command:"</span>+command);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"JSM订阅解析异常!  :"</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考链接：&lt;a href=&quot;https://blog.csdn.net/vbirdbest/article/details/72763048&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/vbirdbest/ar
      
    
    </summary>
    
      <category term="缓存" scheme="http://yoursite.com/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="ehcache" scheme="http://yoursite.com/tags/ehcache/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>redis入门与springboot集成</title>
    <link href="http://yoursite.com/2018/11/04/redis%E5%85%A5%E9%97%A8%E4%B8%8Espringboot%E9%9B%86%E6%88%90/"/>
    <id>http://yoursite.com/2018/11/04/redis入门与springboot集成/</id>
    <published>2018-11-04T09:07:58.000Z</published>
    <updated>2019-01-21T09:28:59.012Z</updated>
    
    <content type="html"><![CDATA[<p>安装与客户端的使用：<a href="https://blog.csdn.net/qq_35038153/article/details/79675728" target="_blank" rel="noopener">https://blog.csdn.net/qq_35038153/article/details/79675728</a></p><p>其他参考链接：<a href="https://www.jianshu.com/p/7bf5dc61ca06/" target="_blank" rel="noopener">https://www.jianshu.com/p/7bf5dc61ca06/</a></p><p><a href="https://blog.csdn.net/w501631338/article/details/73555908" target="_blank" rel="noopener">https://blog.csdn.net/w501631338/article/details/73555908</a></p><p>Redis五大类型:字符串（String）、哈希/散列/字典（Hash）、列表（List）、集合（Set）、有序集合（sorted set）</p><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td>String</td><td>可以是字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作；对象和浮点数执行自增(increment)或者自减(decrement)</td></tr><tr><td>List</td><td>一个链表，链表上的每个节点都包含了一个字符串</td><td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或者多个元素；根据值来查找或者移除元素</td></tr><tr><td>Set</td><td>包含字符串的无序收集器(unorderedcollection)，并且被包含的每个字符串都是独一无二的、各不相同</td><td>添加、获取、移除单个元素；检查一个元素是否存在于某个集合中；计算交集、并集、差集；从集合里卖弄随机获取元素</td></tr><tr><td>Hash</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；获取所有键值对</td></tr><tr><td>Zset(有序的Set)</td><td>字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定</td><td>添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素</td></tr></tbody></table><p><strong>其中String和Hash用的较多。</strong><a href="http://www.runoob.com/redis/redis-commands.html" target="_blank" rel="noopener">redis api命令</a></p><p>Spring 封装了<strong>RedisTemplate</strong>来进行对redis的各种操作，支持所有redis原生的api</p><h4 id="redisTemplate"><a href="#redisTemplate" class="headerlink" title="redisTemplate"></a>redisTemplate</h4><p>Controller:@Resource RedisTemplate&lt;String, String&gt; redisTemplate;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue();<span class="comment">//操作字符串</span></span><br><span class="line">redisTemplate.opsForHash();<span class="comment">//操作hash</span></span><br><span class="line">redisTemplate.opsForList();<span class="comment">//操作list</span></span><br><span class="line">redisTemplate.opsForSet();<span class="comment">//操作set</span></span><br><span class="line">redisTemplate.opsForZSet();<span class="comment">//操作有序set</span></span><br><span class="line"><span class="comment">//redisTemplate的超时设置</span></span><br><span class="line">redisTemplate.expire((key,timeout,timeunit)<span class="comment">//timeout:key的生存时间，timeunit：时间单位（小时，分钟，秒…)(TimeUnit.SECONDS)</span></span><br><span class="line">redisTemplate.getExpire(key, [timeunit])<span class="comment">//获得超时时间</span></span><br><span class="line"><span class="comment">//注意：以上设置超时的方法只适用于key对应的值不再更新的问题，set方法会丢失key的生存时间，忽略而变为永久。</span></span><br><span class="line">redisTemplate.delete(key)<span class="comment">//redis的String删除操作</span></span><br><span class="line">redisTemplate.set(key,value,[timeout],[timeunit])<span class="comment">//redis的String添加操作，但不推荐，最好结合opsForValue()对字符串操作</span></span><br></pre></td></tr></table></figure><p><strong>注意：如果使用RedisTemplate需要更改序列化方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RedisSerializer&lt;String&gt; stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        template.setKeySerializer(stringSerializer );</span><br><span class="line">        template.setValueSerializer(stringSerializer );</span><br><span class="line">        template.setHashKeySerializer(stringSerializer );</span><br><span class="line">        template.setHashValueSerializer(stringSerializer );</span><br></pre></td></tr></table></figure><h4 id="StringRedisTemplate（Redis的String数据结构）"><a href="#StringRedisTemplate（Redis的String数据结构）" class="headerlink" title="StringRedisTemplate（Redis的String数据结构）"></a>StringRedisTemplate（Redis的String数据结构）</h4><p>StringRedisTemplate（推荐使用）与RedisTemplate的区别：</p><ul><li><p>StringRedisTemplate继承RedisTemplate</p></li><li><p>两者数据不可通，可以看做两种数据类型</p></li><li><p>SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。</p><p>StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。</p><p>RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</p></li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String:</span><br><span class="line"><span class="number">1</span>.redisTemplate.opsForValue().set(key,value)); </span><br><span class="line"><span class="number">2</span>.redisTemplate.opsForValue().get(key)); </span><br><span class="line"><span class="number">3</span>.redisTemplate.opsForValue().get(key, start, end);</span><br><span class="line"><span class="number">4</span>.redisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line"><span class="number">5</span>.redisTemplate.opsForValue().getBit(key, offset);</span><br><span class="line"><span class="number">6</span>.redisTemplate.opsForValue().multiGet(keys);</span><br><span class="line"><span class="number">7</span>.redisTemplate.opsForValue().setBit(key, offset, value);<span class="comment">//通过ascii码设置String</span></span><br><span class="line"><span class="number">8</span>.redisTemplate.opsForValue().set(K key, V value, <span class="keyword">long</span> timeout, TimeUnit unit);<span class="comment">//详见下</span></span><br><span class="line"><span class="number">9</span>.redisTemplate.opsForValue().setIfAbsent(key, value);<span class="comment">//详见下</span></span><br><span class="line"><span class="number">10</span>.redisTemplate.opsForValue().set(K key, V value, <span class="keyword">long</span> offset);<span class="comment">//详见下</span></span><br><span class="line"><span class="number">11</span>.redisTemplate.opsForValue().size(key));</span><br><span class="line"><span class="number">12</span>.redisTemplate.opsForValue().multiGet(Collection&lt;K&gt; keys);</span><br><span class="line"><span class="number">13</span>.redisTemplate.opsForValue().multiSetIfAbsent(Map&lt;? extends K, ? extends V&gt; m);</span><br><span class="line"><span class="number">14</span>.同<span class="number">8</span></span><br><span class="line"><span class="number">15</span>\<span class="number">16</span>\<span class="number">17</span>\<span class="number">18</span>\<span class="number">19</span>.redisTemplate.opsForValue().increment(K key, <span class="keyword">long</span> delta);或.increment(K key, <span class="keyword">double</span> delta);</span><br><span class="line"><span class="number">20</span>.redisTemplate.opsForValue().append(key, value);<span class="comment">//在key键对应值的右面追加值value</span></span><br><span class="line"><span class="number">21</span>.redisTemplate.opsForValue().getOperations().delete(key);<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><ul><li>8.redisTemplate.opsForValue().set(K key, V value, long timeout, TimeUnit unit);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用：redisTemplate.opsForValue().set(<span class="string">"name"</span>,<span class="string">"tom"</span>,<span class="number">10</span>, TimeUnit.SECONDS); </span><br><span class="line">结果：redisTemplate.opsForValue().get(<span class="string">"name"</span>)<span class="comment">//由于设置的是10秒失效，十秒之内查询有结果，十秒之后返回为null</span></span><br></pre></td></tr></table></figure><ul><li>9.redisTemplate.opsForValue().setIfAbsent(key, value);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用：System.out.println(redisTemplate.opsForValue().setIfAbsent(<span class="string">"multi1"</span>,<span class="string">"multi1"</span>));<span class="comment">//false  multi1之前已经存在</span></span><br><span class="line">       System.out.println(redisTemplate.opsForValue().setIfAbsent(<span class="string">"multi111"</span>,<span class="string">"multi111"</span>));<span class="comment">//true  multi111之前不存在</span></span><br><span class="line">结果：<span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><ul><li><p>10.redisTemplate.opsForValue().set(K key, V value, long offset);</p><p>该方法是用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用：redisTemplate.opsForValue().set(<span class="string">"key"</span>,<span class="string">"hello world"</span>);</span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">"key"</span>,<span class="string">"redis"</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">"********"</span>+redisTemplate.opsForValue().get(<span class="string">"key"</span>));</span><br><span class="line">结果：********hello redis</span><br></pre></td></tr></table></figure><ul><li>6.redisTemplate.opsForValue().multiGet(keys);</li><li>12.redisTemplate.opsForValue().multiGet(Collection<k> keys);</k></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用：Map&lt;String,String&gt; maps = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        maps.put(<span class="string">"multi1"</span>,<span class="string">"multi1"</span>);</span><br><span class="line">        maps.put(<span class="string">"multi2"</span>,<span class="string">"multi2"</span>);</span><br><span class="line">        maps.put(<span class="string">"multi3"</span>,<span class="string">"multi3"</span>);</span><br><span class="line">        redisTemplate.opsForValue().multiSet(maps);</span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        keys.add(<span class="string">"multi1"</span>);</span><br><span class="line">        keys.add(<span class="string">"multi2"</span>);</span><br><span class="line">        keys.add(<span class="string">"multi3"</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().multiGet(keys));</span><br><span class="line">结果：[multi1, multi2, multi3]</span><br></pre></td></tr></table></figure><ul><li><p>redisTemplate.opsForValue().increment(K key, long delta)</p></li><li><p>redisTemplate.opsForValue().increment(K key, double delta)</p><p>原子递增</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().increment(key,<span class="number">1</span>)<span class="comment">//1</span></span><br><span class="line">redisTemplate.opsForValue().increment(key,<span class="number">1.2</span>) <span class="comment">//2.2</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>编号</th><th>命令</th><th>描述说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.yiibai.com/redis/strings_set.html" target="_blank" rel="noopener">SET key value</a></td><td>此命令设置指定键的值。</td></tr><tr><td>2</td><td><a href="http://www.yiibai.com/redis/strings_get.html" target="_blank" rel="noopener">GET key</a></td><td>获取指定键的值。</td></tr><tr><td>3</td><td><a href="http://www.yiibai.com/redis/strings_getrange.html" target="_blank" rel="noopener">GETRANGE key start end</a></td><td>获取存储在键上的字符串的子字符串。</td></tr><tr><td>4</td><td><a href="http://www.yiibai.com/redis/strings_getset.html" target="_blank" rel="noopener">GETSET key value</a></td><td>设置键的字符串值并返回其旧值。</td></tr><tr><td>5</td><td><a href="http://www.yiibai.com/redis/strings_getbit.html" target="_blank" rel="noopener">GETBIT key offset</a></td><td>返回在键处存储的字符串值中偏移处的位值。</td></tr><tr><td>6</td><td><a href="http://www.yiibai.com/redis/strings_mget.html" target="_blank" rel="noopener">MGET key1 [key2..]</a></td><td>获取所有给定键的值</td></tr><tr><td>7</td><td><a href="http://www.yiibai.com/redis/strings_setbit.html" target="_blank" rel="noopener">SETBIT key offset value</a></td><td>存储在键上的字符串值中设置或清除偏移处的位</td></tr><tr><td>8</td><td><a href="http://www.yiibai.com/redis/strings_setex.html" target="_blank" rel="noopener">SETEX key seconds value</a></td><td>使用键和到期时间来设置值</td></tr><tr><td>9</td><td><a href="http://www.yiibai.com/redis/strings_setnx.html" target="_blank" rel="noopener">SETNX key value</a></td><td>设置键的值，仅当键不存在时</td></tr><tr><td>10</td><td><a href="http://www.yiibai.com/redis/strings_setrange.html" target="_blank" rel="noopener">SETRANGE key offset value</a></td><td>在指定偏移处开始的键处覆盖字符串的一部分</td></tr><tr><td>11</td><td><a href="http://www.yiibai.com/redis/strings_strlen.html" target="_blank" rel="noopener">STRLEN key</a></td><td>获取存储在键中的值的长度</td></tr><tr><td>12</td><td><a href="http://www.yiibai.com/redis/strings_mset.html" target="_blank" rel="noopener">MSET key value [key value …]</a></td><td>为多个键分别设置它们的值</td></tr><tr><td>13</td><td><a href="http://www.yiibai.com/redis/strings_msetnx.html" target="_blank" rel="noopener">MSETNX key value [key value …]</a></td><td>为多个键分别设置它们的值，仅当键不存在时</td></tr><tr><td>14</td><td><a href="http://www.yiibai.com/redis/strings_psetex.html" target="_blank" rel="noopener">PSETEX key milliseconds value</a></td><td>设置键的值和到期时间(以毫秒为单位)</td></tr><tr><td>15</td><td><a href="http://www.yiibai.com/redis/strings_incr.html" target="_blank" rel="noopener">INCR key</a></td><td>将键的整数值增加<code>1</code></td></tr><tr><td>16</td><td><a href="http://www.yiibai.com/redis/strings_incrby.html" target="_blank" rel="noopener">INCRBY key increment</a></td><td>将键的整数值按给定的数值增加</td></tr><tr><td>17</td><td><a href="http://www.yiibai.com/redis/strings_incrbyfloat.html" target="_blank" rel="noopener">INCRBYFLOAT key increment</a></td><td>将键的浮点值按给定的数值增加</td></tr><tr><td>18</td><td><a href="http://www.yiibai.com/redis/strings_decr.html" target="_blank" rel="noopener">DECR key</a></td><td>将键的整数值减<code>1</code></td></tr><tr><td>19</td><td><a href="http://www.yiibai.com/redis/strings_decrby.html" target="_blank" rel="noopener">DECRBY key decrement</a></td><td>按给定数值减少键的整数值</td></tr><tr><td>20</td><td><a href="http://www.yiibai.com/redis/strings_append.html" target="_blank" rel="noopener">APPEND key value</a></td><td>将指定值附加到键</td></tr></tbody></table><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Hash:</span><br><span class="line"><span class="number">1</span>.redisTemplate.opsForHash().delete(H key, Object... hashKeys);<span class="comment">//...表示可以传入多个map的key，用，隔开。或用数组传值</span></span><br><span class="line"><span class="number">2</span>.redisTemplate.opsForHash().hasKey(key, hashKey)；</span><br><span class="line"><span class="number">3</span>.redisTemplate.opsForHash().get(key, hashKey)；</span><br><span class="line"><span class="number">4</span>.redisTemplate.opsForHash().entries(key);<span class="comment">//返回map集合</span></span><br><span class="line"><span class="number">5</span>、<span class="number">6</span>.redisTemplate.opsForHash().increment(H key, HK hashKey, <span class="keyword">long</span> delta);<span class="comment">//或increment(H key, HK hashKey, double delta);；</span></span><br><span class="line"><span class="number">7</span>.redisTemplate.opsForHash().keys(key)；<span class="comment">//返回map的key集合Set</span></span><br><span class="line"><span class="number">8</span>.redisTemplate.opsForHash().size(key)；</span><br><span class="line"><span class="number">9</span>.redisTemplate.opsForHash().multiGet(H key, Collection&lt;HK&gt; hashKeys);</span><br><span class="line"><span class="number">10</span>.redisTemplate.opsForHash().putAll(H key, Map&lt;? extends HK, ? extends HV&gt; m)；</span><br><span class="line"><span class="number">11</span>.redisTemplate.opsForHash().put(key, hashKey, value);</span><br><span class="line"><span class="number">12</span>.redisTemplate.opsForHash().putIfAbsent(key, hashKey, value)；</span><br><span class="line"><span class="number">13</span>.redisTemplate.opsForHash().values(key);<span class="comment">//返回map中的value集合List；</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.yiibai.com/redis/hashes_hdel.html" target="_blank" rel="noopener">HDEL key field2 [field2]</a></td><td>删除一个或多个哈希字段。</td></tr><tr><td>2</td><td><a href="http://www.yiibai.com/redis/hashes_hexists.html" target="_blank" rel="noopener">HEXISTS key field</a></td><td>判断是否存在散列字段。</td></tr><tr><td>3</td><td><a href="http://www.yiibai.com/redis/hashes_hget.html" target="_blank" rel="noopener">HGET key field</a></td><td>获取存储在指定键的哈希字段的值。</td></tr><tr><td>4</td><td><a href="http://www.yiibai.com/redis/hashes_hgetall.html" target="_blank" rel="noopener">HGETALL key</a></td><td>获取存储在指定键的哈希中的所有字段和值</td></tr><tr><td>5</td><td><a href="http://www.yiibai.com/redis/hashes_hincrby.html" target="_blank" rel="noopener">HINCRBY key field increment</a></td><td>将哈希字段的整数值按给定数字增加</td></tr><tr><td>6</td><td><a href="http://www.yiibai.com/redis/hashes_hincrbyfloat.html" target="_blank" rel="noopener">HINCRBYFLOAT key field increment</a></td><td>将哈希字段的浮点值按给定数值增加</td></tr><tr><td>7</td><td><a href="http://www.yiibai.com/redis/hashes_hkeys.html" target="_blank" rel="noopener">HKEYS key</a></td><td>获取哈希中的所有字段</td></tr><tr><td>8</td><td><a href="http://www.yiibai.com/redis/hashes_hlen.html" target="_blank" rel="noopener">HLEN key</a></td><td>获取散列中的字段数量</td></tr><tr><td>9</td><td><a href="http://www.yiibai.com/redis/hashes_hmget.html" target="_blank" rel="noopener">HMGET key field1 [field2]</a></td><td>获取所有给定哈希字段的值</td></tr><tr><td>10</td><td><a href="http://www.yiibai.com/redis/hashes_hmset.html" target="_blank" rel="noopener">HMSET key field1 value1 [field2 value2 ]</a></td><td>为多个哈希字段分别设置它们的值</td></tr><tr><td>11</td><td><a href="http://www.yiibai.com/redis/hashes_hset.html" target="_blank" rel="noopener">HSET key field value</a></td><td>设置散列字段的字符串值</td></tr><tr><td>12</td><td><a href="http://www.yiibai.com/redis/hashes_hsetnx.html" target="_blank" rel="noopener">HSETNX key field value</a></td><td>仅当字段不存在时，才设置散列字段的值</td></tr><tr><td>13</td><td><a href="http://www.yiibai.com/redis/hashes_hvals.html" target="_blank" rel="noopener">HVALS key</a></td><td>获取哈希中的所有值</td></tr></tbody></table><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List：</span><br><span class="line"></span><br><span class="line">redisTemplate.opsForList().leftPush(key, value);<span class="comment">//从左向右存压栈</span></span><br><span class="line">redisTemplate.opsForList().leftPop(key);<span class="comment">//从左出栈</span></span><br><span class="line">redisTemplate.opsForList().size(key);<span class="comment">//队/栈长</span></span><br><span class="line">redisTemplate.opsForList().range(key, start, end);<span class="comment">//范围检索,返回List</span></span><br><span class="line">redisTemplate.opsForList().remove(key, i, value);<span class="comment">//移除key中值为value的i个,返回删除的个数；如果没有这个元素则返回0 </span></span><br><span class="line">redisTemplate.opsForList().index(key, index);<span class="comment">//检索</span></span><br><span class="line">redisTemplate.opsForList().set(key, index, value);<span class="comment">//赋值</span></span><br><span class="line">redisTemplate.opsForList().trim(key, start, end);<span class="comment">//裁剪,void,删除除了[start,end]以外的所有元素  </span></span><br><span class="line">redisTemplate.opsForList().rightPopAndLeftPush(String sourceKey, String destinationKey);<span class="comment">//将源key的队列的右边的一个值删除，然后塞入目标key的队列的左边，返回这个值</span></span><br><span class="line">注意:要缓存的对象必须实现Serializable接口,因为 Spring 会将对象先序列化再存入 Redis,否则报异常nested exception is java.lang.IllegalArgumentException: DefaultSerializer <span class="keyword">requires</span> a Serializable……</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.yiibai.com/redis/lists_blpop.html" target="_blank" rel="noopener">BLPOP key1 [key2 ] timeout</a></td><td>删除并获取列表中的第一个元素，或阻塞，直到有一个元素可用</td></tr><tr><td>2</td><td><a href="http://www.yiibai.com/redis/lists_brpop.html" target="_blank" rel="noopener">BRPOP key1 [key2 ] timeout</a></td><td>删除并获取列表中的最后一个元素，或阻塞，直到有一个元素可用</td></tr><tr><td>3</td><td><a href="http://www.yiibai.com/redis/lists_brpoplpush.html" target="_blank" rel="noopener">BRPOPLPUSH source destination timeout</a></td><td>从列表中弹出值，将其推送到另一个列表并返回它; 或阻塞，直到一个可用</td></tr><tr><td>4</td><td><a href="http://www.yiibai.com/redis/lists_lindex.html" target="_blank" rel="noopener">LINDEX key index</a></td><td>通过其索引从列表获取元素</td></tr><tr><td>5</td><td><a href="http://www.yiibai.com/redis/lists_linsert.html" target="_blank" rel="noopener">LINSERT key BEFORE/AFTER pivot value</a></td><td>在列表中的另一个元素之前或之后插入元素</td></tr><tr><td>6</td><td><a href="http://www.yiibai.com/redis/lists_llen.html" target="_blank" rel="noopener">LLEN key</a></td><td>获取列表的长度</td></tr><tr><td>7</td><td><a href="http://www.yiibai.com/redis/lists_lpop.html" target="_blank" rel="noopener">LPOP key</a></td><td>删除并获取列表中的第一个元素</td></tr><tr><td>8</td><td><a href="http://www.yiibai.com/redis/lists_lpush.html" target="_blank" rel="noopener">LPUSH key value1 [value2]</a></td><td>将一个或多个值添加到列表</td></tr><tr><td>9</td><td><a href="http://www.yiibai.com/redis/lists_lpushx.html" target="_blank" rel="noopener">LPUSHX key value</a></td><td>仅当列表存在时，才向列表添加值</td></tr><tr><td>10</td><td><a href="http://www.yiibai.com/redis/lists_lrange.html" target="_blank" rel="noopener">LRANGE key start stop</a></td><td>从列表中获取一系列元素</td></tr><tr><td>11</td><td><a href="http://www.yiibai.com/redis/lists_lrem.html" target="_blank" rel="noopener">LREM key count value</a></td><td>从列表中删除元素</td></tr><tr><td>12</td><td><a href="http://www.yiibai.com/redis/lists_lset.html" target="_blank" rel="noopener">LSET key index value</a></td><td>通过索引在列表中设置元素的值</td></tr><tr><td>13</td><td><a href="http://www.yiibai.com/redis/lists_ltrim.html" target="_blank" rel="noopener">LTRIM key start stop</a></td><td>修剪列表的指定范围</td></tr><tr><td>14</td><td><a href="http://www.yiibai.com/redis/lists_rpop.html" target="_blank" rel="noopener">RPOP key</a></td><td>删除并获取列表中的最后一个元素</td></tr><tr><td>15</td><td><a href="http://www.yiibai.com/redis/lists_rpoplpush.html" target="_blank" rel="noopener">RPOPLPUSH source destination</a></td><td>删除列表中的最后一个元素，将其附加到另一个列表并返回</td></tr><tr><td>16</td><td><a href="http://www.yiibai.com/redis/lists_rpush.html" target="_blank" rel="noopener">RPUSH key value1 [value2]</a></td><td>将一个或多个值附加到列表</td></tr><tr><td>17</td><td><a href="http://www.yiibai.com/redis/lists_rpushx.html" target="_blank" rel="noopener">RPUSHX key value</a></td><td>仅当列表存在时才将值附加到列表</td></tr></tbody></table><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set：</span><br><span class="line">redisTemplate.opsForValue().getAndSet(key, value)</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.yiibai.com/redis/sets_sadd.html" target="_blank" rel="noopener">SADD key member1 [member2]</a></td><td>将一个或多个成员添加到集合</td></tr><tr><td>2</td><td><a href="http://www.yiibai.com/redis/sets_scard.html" target="_blank" rel="noopener">SCARD key</a></td><td>获取集合中的成员数</td></tr><tr><td>3</td><td><a href="http://www.yiibai.com/redis/sets_sdiff.html" target="_blank" rel="noopener">SDIFF key1 [key2]</a></td><td>减去多个集合</td></tr><tr><td>4</td><td><a href="http://www.yiibai.com/redis/sets_sdiffstore.html" target="_blank" rel="noopener">SDIFFSTORE destination key1 [key2]</a></td><td>减去多个集并将结果集存储在键中</td></tr><tr><td>5</td><td><a href="http://www.yiibai.com/redis/sets_sinter.html" target="_blank" rel="noopener">SINTER key1 [key2]</a></td><td>相交多个集合</td></tr><tr><td>6</td><td><a href="http://www.yiibai.com/redis/sets_sinterstore.html" target="_blank" rel="noopener">SINTERSTORE destination key1 [key2]</a></td><td>交叉多个集合并将结果集存储在键中</td></tr><tr><td>7</td><td><a href="http://www.yiibai.com/redis/sets_sismember.html" target="_blank" rel="noopener">SISMEMBER key member</a></td><td>判断确定给定值是否是集合的成员</td></tr><tr><td>8</td><td><a href="http://www.yiibai.com/redis/sets_smove.html" target="_blank" rel="noopener">SMOVE source destination member</a></td><td>将成员从一个集合移动到另一个集合</td></tr><tr><td>9</td><td><a href="http://www.yiibai.com/redis/sets_spop.html" target="_blank" rel="noopener">SPOP key</a></td><td>从集合中删除并返回随机成员</td></tr><tr><td>10</td><td><a href="http://www.yiibai.com/redis/sets_srandmember.html" target="_blank" rel="noopener">SRANDMEMBER key [count]</a></td><td>从集合中获取一个或多个随机成员</td></tr><tr><td>11</td><td><a href="http://www.yiibai.com/redis/sets_srem.html" target="_blank" rel="noopener">SREM key member1 [member2]</a></td><td>从集合中删除一个或多个成员</td></tr><tr><td>12</td><td><a href="http://www.yiibai.com/redis/sets_sunion.html" target="_blank" rel="noopener">SUNION key1 [key2]</a></td><td>添加多个集合</td></tr><tr><td>13</td><td><a href="http://www.yiibai.com/redis/sets_sunionstore.html" target="_blank" rel="noopener">SUNIONSTORE destination key1 [key2]</a></td><td>添加多个集并将结果集存储在键中</td></tr><tr><td>14</td><td><a href="http://www.yiibai.com/redis/sets_sscan.html" target="_blank" rel="noopener">SSCAN key cursor [MATCH pattern] [COUNT count]</a></td><td>递增地迭代集合中的元素</td></tr></tbody></table><h3 id="String…与String-的区别"><a href="#String…与String-的区别" class="headerlink" title="String…与String[]的区别"></a>String…与String[]的区别</h3><p>类型后面三个点(String…)，是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表，其语法就是类型后跟 <strong>…</strong>，表示此处接受的参数为<strong>0到多个</strong>Object类型的对象，或者是一个Object[]。所以如果你有了xxx(String… strs)就不能再有xxx(String[])，三个点的写法包含了第二种。</p><hr><p>2018/12/11更新</p><h2 id="spring-data-redis"><a href="#spring-data-redis" class="headerlink" title="spring-data-redis"></a>spring-data-redis</h2><p>​    上面介绍了StingRedisTemplate的一些基本方法，上周末喜提一个新的项目，(<em>^▽^</em>) 项目比之前的大，功能很多，而且创始者还不爱打注释！这真的让我非常头疼</p><p>​    好了回归主题，我看到代码里有一段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BoundHashOperations&lt;String, Object, Object&gt; <span class="title">hashOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stringRedisTemplate.boundHashOps(<span class="string">"sutSub"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    看到StringRedisTemplate有些熟悉，刚入职的时候学了，是Redis的String数据结构，boundHashOps()没见过啊，这其实是一个RedisTemplate的方法，而StringRedisTemplate继承自它，所以告诉我他与get()的区别？ </p><p>​    好像只是为了简化opsForValue()一步，好吧似乎真的只是这样而已，spring-data-redis提供了对key的“bound”便捷化API，为啥要用bound这个名字呢emmm… 可以通过bound封装指定的key操作redis里的数据，有</p><p>BoundValueOperations<br>BoundSetOperations<br>BoundListOperations<br>BoundSetOperations<br>BoundHashOperations</p><p>注意，这个spring-data-redis和put普通的spring-redis有一小点区别，jar包名字的区别…s一个叫spring-boot-data-redis，一个叫spring-boot-start-redis，都是基于Jedis的，所以其实没区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装与客户端的使用：&lt;a href=&quot;https://blog.csdn.net/qq_35038153/article/details/79675728&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_35
      
    
    </summary>
    
      <category term="Nosql" scheme="http://yoursite.com/categories/Nosql/"/>
    
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ</title>
    <link href="http://yoursite.com/2018/11/04/ActiveMQ/"/>
    <id>http://yoursite.com/2018/11/04/ActiveMQ/</id>
    <published>2018-11-04T08:54:04.000Z</published>
    <updated>2019-01-21T09:26:33.653Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>休息了大概一个礼拜，到一个新的单位重新开始，大佬列了很多新人技术清单，其中有很多只是听说过但没有学习和接触过，得赶紧学习啦，^-^</p><p>另外最近使用的是来自大傻逼推荐的一个md编辑器Typora，非常好看还带大纲，比markdownPad好用很多</p></blockquote><p>Activemq学习来源：<a href="https://www.cnblogs.com/cyfonly/p/6380860.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyfonly/p/6380860.html</a></p><p><a href="https://www.cnblogs.com/jaycekon/p/6225058.html" target="_blank" rel="noopener">https://www.cnblogs.com/jaycekon/p/6225058.html</a></p><p><a href="https://blog.csdn.net/Ouyzc/article/details/79643387" target="_blank" rel="noopener">https://blog.csdn.net/Ouyzc/article/details/79643387</a></p><p>首先了解我初步要学到的内容，理解JMS规范-理解点对点，发布订阅模式，理解生产者与消费者</p><p>ok，我的环境是win，没有在虚拟机里装，但一般用在Linux的好像比较多，来看看activemq是个什么东西吧：它是一个面向<strong>消息中间件</strong>（MOM Message-oriented middleware）【MOM 的总体思想是它作为消息发送器和消息接收器之间的消息中介,这种中介提供了一个全新水平的松耦合。】</p><p>JMS(Java Message Service)java消息服务</p><p>activemq就是JMS的一种体现，再了解消息的传递方式-<strong>包括点对点P2P和发布/订阅两种</strong>，nice 这似乎是我需要get的第一个知识点。</p><h4 id="P2P与Pub-Sub"><a href="#P2P与Pub-Sub" class="headerlink" title="P2P与Pub/Sub"></a>P2P与Pub/Sub</h4><p><strong>P2P</strong> （点对点）消息域使用 queue 作为 目标，消息可以被<strong>同步或异步</strong>的发送和接收，每个消息只会给一个 Consumer 传送一次。</p><p>Consumer 可以使用 MessageConsumer.receive() 同步地接收消息，也可以通过使用MessageConsumer.setMessageListener() 注册一个 MessageListener 实现异步接收。</p><p>多个 Consumer 可以注册到同一个 queue 上，但一个消息只能被一个 Consumer 所接收，然后由该 Consumer 来确认消息。并且在这种情况下，Provider 对所有注册的 Consumer 以<strong>轮询的方式</strong>发送消息。</p><p><strong>Pub/Sub</strong>（发布/订阅，Publish/Subscribe）消息域使用 topic 作为 Destination，发布者向 topic 发送消息，订阅者注册接收来自 topic 的消息。发送到 topic 的任何消息都将自动传递给所有订阅者。接收方式（同步和异步）与 P2P 域相同。<br>除非显式指定，否则 topic 不会为订阅者保留消息。当然，这可以通过持久化（Durable）订阅来实现消息的保存。这种情况下，当订阅者与 Provider 断开时，Provider 会为它存储消息。当持久化订阅者重新连接时，将会受到所有的断连期间未消费的消息。</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><ul><li>获取连接工厂</li><li>使用连接工厂创建连接</li><li>启动连接</li><li>从连接创建会话</li><li>获取 Destination</li><li>创建 Producer，或<ul><li>创建 Producer</li><li>创建 message</li></ul></li><li>创建 Consumer，或发送或接收message发送或接收 message<ul><li>创建 Consumer</li><li>注册消息监听器（可选）</li></ul></li><li>发送或接收 message</li><li>关闭资源（connection, session, producer, consumer 等)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--ActiveMQ所需要的jar包 --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 添加ActiveMQ的pool包 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-pool<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第一种P2P模式：</strong></p><p>①消息生产者给消息中间件（队列）发送消息</p><p>②消息消费者接收消息中间件（队列）的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//activamq默认用户名 密码和地址，获取连接的三个必要参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BORKEN_URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Atomic原子类型，保证该int一时间只被单线程操作</span></span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//获取连接工厂</span></span><br><span class="line">    ConnectionFactory connectionFactory;</span><br><span class="line">    <span class="comment">//创建连接对象</span></span><br><span class="line">    Connection connection;</span><br><span class="line">    <span class="comment">//事务管理</span></span><br><span class="line">    Session session;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;MessageProducer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;MessageProducer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(USERNAME,PASSWORD,BORKEN_URL);</span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            connection.start();</span><br><span class="line">            session = connection.createSession(<span class="keyword">true</span>,Session.SESSION_TRANSACTED);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String disname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取消息队列</span></span><br><span class="line">            Queue queue =  session.createQueue(disname);</span><br><span class="line">            MessageProducer messageProducer = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (threadLocal.get() !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//若不为空则从线程中获取，若为空则用session创建</span></span><br><span class="line">                messageProducer = threadLocal.get();</span><br><span class="line">                <span class="comment">//消息过期设置</span></span><br><span class="line">                <span class="comment">//messageProducer.setTimeToLive(1000);</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                messageProducer = session.createProducer(queue);</span><br><span class="line">                threadLocal.set(messageProducer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始创建消息</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">int</span> num = count.getAndIncrement();</span><br><span class="line">                TextMessage textMessage = session.createTextMessage(Thread.currentThread().getName()+<span class="string">"我正在生产消息,num"</span>+num);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"我正在生产消息,num"</span>+num);</span><br><span class="line">                <span class="comment">//发送消息</span></span><br><span class="line">                messageProducer.send(textMessage);</span><br><span class="line">                <span class="comment">//提交事务</span></span><br><span class="line">                session.commit();</span><br><span class="line">                <span class="keyword">if</span> (num&gt;<span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"消息发送结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: activemq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试Activemq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: WYuyin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-11-01 15:45</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMq</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Producter producter = <span class="keyword">new</span> Producter();</span><br><span class="line">        producter.init();</span><br><span class="line">        TestMq testMq = <span class="keyword">new</span> TestMq();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Thread 1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        <span class="comment">//Thread 2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        <span class="comment">//Thread 3</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        <span class="comment">//Thread 4</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        <span class="comment">//Thread 5</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductorMq</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Producter producter;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProductorMq</span><span class="params">(Producter producter)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.producter = producter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    producter.sendMessage(<span class="string">"Jaycekon-MQ"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: activemq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: WYuyin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-11-01 16:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Comsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BORKEN_URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line">    <span class="comment">//获取连接工厂</span></span><br><span class="line">    ConnectionFactory connectionFactory;</span><br><span class="line">    <span class="comment">//创建连接对象</span></span><br><span class="line">    Connection connection;</span><br><span class="line">    <span class="comment">//事务管理</span></span><br><span class="line">    Session session;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;MessageConsumer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;MessageConsumer&gt;();</span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(USERNAME,PASSWORD,BORKEN_URL);</span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            connection.start();</span><br><span class="line">            session = connection.createSession(<span class="keyword">true</span>,Session.SESSION_TRANSACTED);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">getMessage</span><span class="params">(String disname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Queue queue = session.createQueue(disname);</span><br><span class="line">            MessageConsumer consumer = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(threadLocal.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                consumer = threadLocal.get();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                consumer = session.createConsumer(queue);</span><br><span class="line">                threadLocal.set(consumer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">                TextMessage msg = (TextMessage) consumer.receive();</span><br><span class="line">                <span class="keyword">if</span>(msg!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    msg.acknowledge();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">": Consumer:我是消费者，我正在消费Msg"</span>+msg.getText()+<span class="string">"---&gt;"</span>+count.getAndIncrement());</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: activemq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试Mq消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: WYuyin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-11-01 16:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCustomer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Comsumer comsumer = <span class="keyword">new</span> Comsumer();</span><br><span class="line">        comsumer.init();</span><br><span class="line">        TestCustomer testCustomer = <span class="keyword">new</span> TestCustomer();</span><br><span class="line">        <span class="keyword">new</span> Thread(testCustomer.new ConsumerMq(comsumer)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testCustomer.new ConsumerMq(comsumer)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testCustomer.new ConsumerMq(comsumer)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testCustomer.new ConsumerMq(comsumer)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerMq</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Comsumer comsumer;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerMq</span><span class="params">(Comsumer comsumer)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.comsumer = comsumer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    comsumer.getMessage(<span class="string">"Jaycekon-MQ"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种Pub/Sub模式</strong></p><p>①消息生产者（发布者）给消息中间件发送话题（topic）</p><p>②消息消费者（订阅者）接收消息中间件的发送话题</p><p>消息生产者（发布者）代码与第一种P2P模式的消息生产者代码几乎一样，只是在创建生产者时，创建的是话题并不是队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取session注意参数值mytopic是一个服务器的topic，须在在ActiveMq的console配置  </span></span><br><span class="line">topic = session.createTopic(<span class="string">"mytopic"</span>);  </span><br><span class="line"><span class="comment">// 得到消息生成者【发送者】  </span></span><br><span class="line">producer = session.createProducer(topic);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">TextMessage message = session.createTextMessage(<span class="string">"我给你发话题"</span>);  </span><br><span class="line">System.out.println(<span class="string">"Sender发送消息："</span> + <span class="string">"topic:"</span> + i);  </span><br><span class="line">producer.send(message);</span><br></pre></td></tr></table></figure><p>订阅者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">session = connection.createSession(Boolean.FALSE,Session.AUTO_ACKNOWLEDGE);  </span><br><span class="line"><span class="comment">// 获取session注意参数值mytopic是一个服务器的topic，须在在ActiveMq的console配置  </span></span><br><span class="line">destination = session.createTopic(<span class="string">"mytopic"</span>);  </span><br><span class="line">consumer = session.createConsumer(destination);</span><br></pre></td></tr></table></figure><h4 id="什么情况下使用ActiveMQ"><a href="#什么情况下使用ActiveMQ" class="headerlink" title="什么情况下使用ActiveMQ?"></a>什么情况下使用ActiveMQ?</h4><ol><li>多个项目之间集成<br>(1) 跨平台<br>(2) 多语言<br>(3) 多项目</li><li>降低系统间模块的耦合度，解耦<br>(1) 软件扩展性</li><li>系统前后端隔离<br>(1) 前后端隔离，屏蔽高安全区</li></ol><h3 id="SpringBoot集成Activemq"><a href="#SpringBoot集成Activemq" class="headerlink" title="SpringBoot集成Activemq"></a>SpringBoot集成Activemq</h3><p>即JMS在Springboot中的应用</p><p>[<a href="https://blog.csdn.net/Ouyzc/article/details/79756574" target="_blank" rel="noopener">https://blog.csdn.net/Ouyzc/article/details/79756574</a></p><p>下面按照上面这个链接中的代码进行分析：</p><p><strong>生产者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1生产者发送消息(发送信息到队列)P2P</span></span><br><span class="line"><span class="comment"> * 根据实例化Destination目的地参数的类型的对象决定是点对点队列的形式，还是广播的形式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">5000</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个目的地（队列类型）</span></span><br><span class="line">Destination queue = <span class="keyword">new</span> ActiveMQQueue(<span class="string">"mytest.queue"</span>);  </span><br><span class="line">jmsTemplate.convertAndSend(queue, <span class="string">"myname is Oyzc"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2生产者发送消息(发送信息到话题)Pub</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">5000</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个目的地（队列类型）</span></span><br><span class="line">Destination topic = <span class="keyword">new</span> ActiveMQTopic(<span class="string">"mytest.topic"</span>); </span><br><span class="line">jmsTemplate.convertAndSend(topic, <span class="string">"myname is Oyzc"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3生产者发送出去消息之后，可以马上监听指定消费者的反馈信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@JmsListener</span>(destination=<span class="string">"out.queue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerMessage</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"从out.queue队列收到的回复报文为:"</span>+text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者生产说明：</p><p>//P2P创建队列，参数为队列名</p><p>Destination queue = new ==ActiveMQQueue==(“mytest.queue”);</p><p>//Pub定义topic，参数为topic名称</p><p>Destination topic = new ==ActiveMQTopic==(“mytest.topic”); </p><p>//jms发送队列/话题信息，第一个参数为队列/topic，第二个参数为发送的内容，可以是字符串或实体或json</p><p>==jmsTemplate.convertAndSend(topic, “myname is Oyzc”);==</p><p><strong>消费者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用JmsListener配置消费者监听的队列，其中text是接收到的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者接收信息1(接收队列为mytest.queue的信息，并马上回复信息到out.queue队列中)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 使用JmsListener配置消费者监听的队列，其中text是接收到的消息  </span></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"mytest.queue"</span>) </span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"out.queue"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">receiveQueue1</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"消费者1收到目的地为mytest.queue发来的信息"</span>+text);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"mytest.queue接收到你的信息了"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者说明：</p><p>//@JmsListener开启监听，接受名为”mytest.queue”的队列/话题信息</p><p>@JmsListener(destination = “mytest.queue”) </p><p>//返回给生产者的队列</p><p>@SendTo(“out.queue”)  </p><p>在队列和话题同时存在的情况下，Jms默认支持队列，解决方式：</p><p>在配置文件中添加 <strong>spring.jms.pub-sub-domain=true</strong>，使得队列和话题同时发送成功，但消费者只接受topic。</p><p>正确解决方式：</p><p>① Jms配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJms</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsFactoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;activemq.ClientId&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String ClientId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JmsListenerContainerFactory&lt;?&gt; topicListenerFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        <span class="comment">//订阅发布</span></span><br><span class="line">        factory.setPubSubDomain(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//消息持久化</span></span><br><span class="line">        factory.setSubscriptionDurable(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//链接超时</span></span><br><span class="line">        factory.setReceiveTimeout(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">//接收者id</span></span><br><span class="line">        factory.setClientId(ClientId);</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JmsListenerContainerFactory&lt;?&gt; queueListenerFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        <span class="comment">//队列</span></span><br><span class="line">        factory.setPubSubDomain(<span class="keyword">false</span>);</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改消费者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JmsListener</span>(destination = <span class="string">"$&#123;activemq.topic&#125;"</span> , containerFactory = <span class="string">"topicListenerFactory"</span>)</span><br></pre></td></tr></table></figure><p>//使监听器处理话题/队列信息</p><p>containerFactory = “topicListenerFactory/queueListenerFactory”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;休息了大概一个礼拜，到一个新的单位重新开始，大佬列了很多新人技术清单，其中有很多只是听说过但没有学习和接触过，得赶紧学习啦，^-^&lt;/p&gt;
&lt;p&gt;另外最近使用的是来自大傻逼推荐的一个md编辑器Typora，非常好看还带大纲，比markdownPad
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="activemq" scheme="http://yoursite.com/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot(一)</title>
    <link href="http://yoursite.com/2018/10/22/Spring-Boot-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/10/22/Spring-Boot-一/</id>
    <published>2018-10-22T01:54:18.000Z</published>
    <updated>2018-11-04T09:41:03.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>上一节写HelloWorldDemo时主程序类被修饰了一个<strong>@SpringBootApplication</strong>，【顾名思义-SpringBoot应用注解】标注在某各类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用，是一个组合注解。</p><p>这个组合注解中包含Spring里的<strong>@Configuration</strong>、<strong>@Import、@EnableAutoConfiguration、@ComponentScan</strong>等底层注解，之前也说SpringBoot有自动配置的优点，那么只要你在主程序配置了<strong>@SpringBootApplication</strong>，其所在包及其中子包里所有的组件都扫描到Spring容器，这是其中的<strong>@AutoConfigurationPackage</strong>【自动配置包】的作用</p><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p><strong>@RestController</strong>标注在Controller类上，也是一个组合注解，主要包含<strong>@Controller</strong>和<strong>@ResponseBody</strong></p><p>@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中,页面不会发生跳转。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>新建Spring Initializer项目时会生成一个application.properties，除了这个properties文件还支持yml格式的配置文件，两者的书写格式有所不同，yml更加的清爽适合用来作为配置文件。</p><p>在建博客的时候遇到的配置文件都是yml类型，所以已经有些熟悉。</p><h3 id="值的格式"><a href="#值的格式" class="headerlink" title="值的格式"></a>值的格式</h3><p>k: v    //k和v之间一定要有空格</p><p><strong>普通的值：数字，字符串，布尔</strong><br>字符串不用加引号，但如果字符串中含有空格或特殊字符，要用单引号括起来，否则会被转义。<br>布尔类型：用on、1、true来表示true，off、0、false来表示false</p><p><strong>对象、Map、数组</strong><br>对象的值就在下一行写对象的属性值，注意缩进。</p><pre><code>friends:     lastName: zhangsan    age: 20</code></pre><p>行内写法：【也是Map的写法】</p><pre><code>frends: {lastName: zhangsan,age: 20}</code></pre><p>数组：用”- “隔开</p><pre><code>pets: - cat - dog</code></pre><p>数组的行内写法：<br>​<br>    pets: [dog,cat]</p><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>在配置文件中写好值后，如何获取参数？</p><h3 id="ConfigurationProperties-1"><a href="#ConfigurationProperties-1" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>最常见的方法有将对象以映射的方式，将配置信息封装成一个类，创建一个class，在类上修饰：<strong>@Component</strong> 和 <strong>@ConfigurationProperties(prefix=”xxx”)</strong>,前者是将类变成一个JavaBean，后者表示前缀为xxx的配置信息被绑定</p><p>我们可以导入<strong>配置文件处理器</strong>，写配置文件时会有相应包下bean的自动提示：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>JavaBean：</p><pre><code>@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person {    private String name;    private Integer age;    private List&lt;Object&gt; list;</code></pre><p>yml配置文件：</p><pre><code>person:  age: 20  name: Zhangsan  list:     - miao    - wang</code></pre><p>如果是properties文件要将文件编码改为ASCII码，否则会出现乱码，设置步骤为：Settings-File Encodings-√Transparent native-to-ascii conversion</p><h2 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h2><p>同Spring一样@Value(“${xxx}”)</p><p>其中引号中可以用EL表达式表示#{xxx}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringBootApplication&quot;&gt;&lt;a href=&quot;#SpringBootApplication&quot; class=&quot;headerlink&quot; title=&quot;@SpringBootApplication&quot;&gt;&lt;/a&gt;@SpringBootApplication
      
    
    </summary>
    
      <category term="spring boot" scheme="http://yoursite.com/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
      <category term="java ee" scheme="http://yoursite.com/tags/java-ee/"/>
    
  </entry>
  
  <entry>
    <title>被IE支配的恐惧</title>
    <link href="http://yoursite.com/2018/10/18/%E8%A2%ABIE%E6%94%AF%E9%85%8D%E7%9A%84%E6%81%90%E6%83%A7/"/>
    <id>http://yoursite.com/2018/10/18/被IE支配的恐惧/</id>
    <published>2018-10-18T02:44:02.000Z</published>
    <updated>2019-01-21T09:26:02.389Z</updated>
    
    <content type="html"><![CDATA[<p> 这两天改前端，平时习惯拿谷歌和opera调试，今天突然想到有个表格的宽没定好，有点丑，就打开几个浏览器一同看效果，然后就被IE整崩溃了，总是出现 属性“xxx”的值为 null、未定义或不是 Function 对象这个错，简单的一个onclick=”xxx()”都没有效果。</p><p>首先，我的js代码绝对没问题，因为其他浏览器正常都没问题，而且就算清除方法内容单单写一个alert也还是报一样的错。后来我改了方法名，重新刷新，刷新一下之后短暂地不报错并且成功走了我的js代码，但一切换或刷新又报错，一开始我以为是ie8的问题，切换调试工具为ie11发现的确ie11不报错，但也没有走我的方法，只是它没找到方法直接跳转到下一页面并且没有告诉你它没找到，真的是太草率了一点吧这个IE？？？</p><p>花了半天时间解决了这个问题，总结归纳如下几步：</p><p>1)确保js代码无误，方法名没有写错，或是方法里有什么语法错误。</p><p>2)判断问题是出在IE8兼容上还是IE的通病，通过F12右上角一个下拉选项可以切换调试版本，默认是8，这也是最蛋疼的一点。<br><img src="/2018/10/18/被IE支配的恐惧/20180831_1.png"></p><p>3)若是ie8独有的问题，那么就自行百度如何处理吧，如果是所有版本都存在的问题，或是像我一样时灵时不灵的情况，这是浏览器缓存导致的，js代码修改过但是浏览器只加载最初的js，这个靠刷新是没有效果的，</p><p><strong>清缓存步骤</strong>：设置-Internet选项-常规-删除，就会跳出删除浏览历史记录的窗口，把下载历史记录、表单数据都勾上，确认删除，等待几秒后就会弹出“Internet Explorer已完成删除所选的浏览历史记录”，这时再刷新就一切恢复正常了。</p><blockquote><p>后续：经过反复清缓存又重跑代码，最终觉得还是有代码本身的问题，页面上的表单用s标签提交，而我却欲用ajax，并把事件触发在submit上，感觉可能是冲突了，【我不信！那为啥什么也不写只有一句alert还是会报错@-@，还是要靠清缓存】，总之这个问题第二天在我放弃了ajax提交之后就悄悄地解决了，也没有发生昨天的情况，程序员的谎言：“我真的没有改代码！”orz</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 这两天改前端，平时习惯拿谷歌和opera调试，今天突然想到有个表格的宽没定好，有点丑，就打开几个浏览器一同看效果，然后就被IE整崩溃了，总是出现 属性“xxx”的值为 null、未定义或不是 Function 对象这个错，简单的一个onclick=”xxx()”都没有效果
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>spring boot入门</title>
    <link href="http://yoursite.com/2018/10/12/spring-boot%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/10/12/spring-boot入门/</id>
    <published>2018-10-12T02:22:06.000Z</published>
    <updated>2018-10-22T05:56:16.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>虽然工作用不到springboot，甚至没有用到spring，但这也就是为什么我有了强烈的危机感，现在许多地方应该会用到吧，或许标题应该是从零开始学springboot。跟着尚硅谷的springboot视频学习，如有侵权请留言或发<a href="9005837@qq.com">邮箱</a>告诉我</p></blockquote><p>spring boot是用于简化spring开发的框架，是基于spring再封装的一个框架<br>优点：</p><ul><li>快速创建独立运行的Spring项目以及与主流框架集成</li><li>使用嵌入式的Servlet容器，应用无需打成WAR包</li><li>starters自动依赖与版本控制</li><li>大量的自动配置，简化开发，也可修改默认值</li><li>无需配置XML，无代码生成，开箱即用</li><li>准生产环境的运行时应用监控</li><li>与云计算的天然集成<br>这里的无需配置配置文件，和starters自动依赖真的是很吸引人，想想用spring的时候从各种配置开始学真的有些繁琐。</li></ul><h2 id="环境约束"><a href="#环境约束" class="headerlink" title="环境约束"></a>环境约束</h2><ul><li>jdk1.8</li><li>maven3.x</li><li>IDEA2018</li><li>SpringBoot1.5.9</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.在apache-maven-3.3.9\conf\settings.xml中检查：</p><pre><code>&lt;profiles&gt;  &lt;profile&gt;            &lt;id&gt;jdk18&lt;/id&gt;            &lt;activation&gt;                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;                &lt;jdk&gt;1.8&lt;/jdk&gt;            &lt;/activation&gt;            &lt;properties&gt;                &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;                &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;                &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;            &lt;/properties&gt;         &lt;/profile&gt;  </code></pre><p>2.将IDEA的Maven环境修改为当前1.8版本，IDEA自带Maven<br><img src="/2018/10/12/spring-boot入门/20181012145508.png"></p><h2 id="HelloWorldDemo"><a href="#HelloWorldDemo" class="headerlink" title="HelloWorldDemo"></a>HelloWorldDemo</h2><p>流程：浏览器发送请求，服务器接收后处理并响应HelloWorld</p><ol><li><p>创建一个Maven工程<br>(也可以创建一个SpringInitializr工程，下面会讲到)<br><img src="/2018/10/12/spring-boot入门/20181012150010.png"><br>右下角会出现一个AutoImport<br><img src="/2018/10/12/spring-boot入门/20181012151419.png"><br>如果你和我一样很不幸的点了×但是又不想重来一遍,那么就在settings中设置Maven-importing<br><img src="/2018/10/12/spring-boot入门/20181012151700.png"><br>这个设置呢就意味着IDEA会自动帮我们导入依赖</p></li><li><p>导入依赖，在pom.xml中加入：</p><pre><code>   &lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></li></ol><p>就可以看到右下角在自动下载jar包</p><ol start="3"><li><p>写HelloWorld，在main里新建一个HelloWorld的class</p><pre><code>import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/*@SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorld {public static void main(String[] args){SpringApplication.run(HelloWorld.class,args);}}</code></pre></li><li><p>编写相关的Controller</p><pre><code>@Controllerpublic class HelloWorldController {@ResponseBody@RequestMapping(&quot;/hello&quot;)public String hello(){return &quot;Hello World&quot;;}}</code></pre></li></ol><blockquote><p>补习：@ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。<a href="https://www.cnblogs.com/daimajun/p/7152970.html" target="_blank" rel="noopener">来源</a></p></blockquote><ol start="5"><li>运行main方法<br><img src="/2018/10/12/spring-boot入门/20181012160811.png"></li></ol><blockquote><p>可以看到整个过程是非常简单的，也就只有注入依赖、写主程序和控制器就没了，回顾一下springMVC应用的流程，配置bean 创建Ioc容器 在程序中获取bean实例 还有SpringMVC的ModelAndView，（虽然我SpringMVC只是学了个大概，没有实践过），SpringBoot的出现一定是为了我这样的懒人减少配置的步骤才出现的吧</p></blockquote><ol start="6"><li><p>打包，加一个插件就可以做到</p> <!-- 这个插件可以将应用打包成一个可执行的jar包 --><pre><code>&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre></li></ol><p>无需再目标服务器安装tomcat环境,接着在右侧看到Maven Projects点开，点package让他装<br><img src="/2018/10/12/spring-boot入门/20181012162729.png"><br>打包好的jar包存在于target文件夹下<br><img src="/2018/10/12/spring-boot入门/20181012163051.png"><br>用cmd执行<code>java -jar jar包名称</code>就可以一样把应用跑起来，这就是SpringBoot对部署带来的便捷</p><h2 id="quickDemo"><a href="#quickDemo" class="headerlink" title="quickDemo"></a>quickDemo</h2><p>可使用Spring Initializer快速创建SpringBoot项目</p><p>IDE都支持使用Spring快速创建向导来开启一个SpringBoot项目</p><p>步骤：<strong>New- Project- Spring Initializer</strong><br>在Dependencies下选择你要的依赖，然后向导会自动联网帮你配好这些依赖<img src="/2018/10/12/spring-boot入门/20181022111750.png">把不要的东西去掉。</p><p>新建完成后会发现主程序已经帮你创好了，接下来只要写逻辑就可以了。</p><p>Controller中的一个注解<strong>@RestController</strong>包含@Controller和@ResponseBody，ResponseBody在上面已经回顾过。标注在Controller上代表这是一个Controller类。</p><pre><code>@RestControllerpublic class HelloController {@RequestMapping(&quot;/hello2&quot;)public String hello(){return &quot;quick hello&quot;;}}</code></pre><p>这下一个quickDemo就完成了，不仅比原先少写主配置文件和依赖，自动生成的目录结构也将静态资源和配置文件生成好了</p><pre><code>-main---java------com.quickdemo.demo---------DemoApplication---resources------static    这个放静态资源------templates    这个保存所有的模态页面------application.properties    配置文件</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;虽然工作用不到springboot，甚至没有用到spring，但这也就是为什么我有了强烈的危机感，现在许多地方应该会用到吧，或许标题应该是从零开始学springboot。跟着尚硅谷的springboot视频学习，如有侵权请留言或发&lt;a href=&quot;
      
    
    </summary>
    
      <category term="spring boot" scheme="http://yoursite.com/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
      <category term="java ee" scheme="http://yoursite.com/tags/java-ee/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题汇总</title>
    <link href="http://yoursite.com/2018/10/11/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/10/11/Java面试题汇总/</id>
    <published>2018-10-11T03:23:53.000Z</published>
    <updated>2019-01-21T09:27:41.493Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有可能不全是Java的知识，只是时间一长感觉这些知识会忘了，就把我遇到的和我了解的先列列看吧。其中会出现许多来自百度、知乎、CSDN等处的内容，就不一一列出来了。</p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="private、protected、public、default的区别"><a href="#private、protected、public、default的区别" class="headerlink" title="private、protected、public、default的区别"></a>private、protected、public、default的区别</h4><p><img src="https://images2015.cnblogs.com/blog/690292/201609/690292-20160923095944481-1758567758.png"></p><p>private 的访问权限仅限于类的内部，是一种封装的体现，大多数成员变量都是private的，使它不能被任何外部的类访问。</p><p>不写时默认为default，即同一包内、类内。</p><h4 id="封装、继承、多态、抽象"><a href="#封装、继承、多态、抽象" class="headerlink" title="封装、继承、多态、抽象"></a>封装、继承、多态、抽象</h4><p>众所周知的面向对象的特征。</p><p>封装：把对象的属性、方法结合成一个独立的整体，这也就是模块化的思想</p><p>继承：一个类可以继承(extends) 父类，就变成了他的子类，继承了父类所有的非私有的方法与属性，哪些内容会被继承见上面的图，继承的方法一般可以重写，继承与重载的权限如下图所示</p><p><img src="https://pic1.zhimg.com/80/v2-a836e010f9e147509844b79529f5a176_hd.jpg"></p><p>多态：不同的对象对同一消息做出不一样的响应，采取不同的方法。最直观的例子就是一个实体类可以有多个构造方法。</p><p>抽象：有相同特性的类抽象出共同的部分，用abstract修饰，抽象类的意义可以用三句话来概括：1.为其它子类提供一个公共的类型 2.封装子类中重复定义的内容 3.定义统一抽象方法，</p><p>抽象方法没有方法体。</p><h4 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h4><p>抽象和接口通常被放在一起比较</p><p><strong>实现方式</strong>：抽象类用extends继承，接口用implements，需要提供接口中所有声明的实现。</p><p><strong>是否可以被实例化</strong>：抽象类不可以，接口则是完全不同的类型，接口不是类，更不能被实例化</p><p><strong>构造器：</strong>抽象类中可以有构造器，接口不能</p><p><strong>修饰符：</strong>抽象方法可以有public、protected、default修饰，接口默认为public，不能被其他修饰符修饰</p><p><strong>是否可以多继承</strong>：抽象类有传递性质，但只能继承一个父类，却可以同时实现多个接口</p><p><strong>构造方法</strong>：接口没有构造方法</p><p>接口的意义在于规范，扩展，回调</p><h4 id="Overload和Override的区别"><a href="#Overload和Override的区别" class="headerlink" title="Overload和Override的区别"></a>Overload和Override的区别</h4><p>重写Override，子类覆盖父类的方法，将子类传与父类的引用调用的还是子类的方法。<br>重载Overloading，一个类多个方法，名称相同，参数个数类型不同，返回值的类型也可不同。<br>两者都是Java多态性的不同表现。</p><h4 id="Final有什么作用"><a href="#Final有什么作用" class="headerlink" title="Final有什么作用"></a>Final有什么作用</h4><p>修饰的属性为常量<br>修饰的方法不可以重写<br>修饰的类不可以继承</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>this()和super()的意义</p><p>什么是不可变对象</p><p>Object有哪些公共方法？（equals(),clone(),getClass(),notify(),notifyAll(),wait(),toString()）</p><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h4><p>ArrayList:线程不安全，速度快<br>Vector:线程安全，速度慢(synchoronized)<br>两者都实现了List接口，都是有序的集合，允许重复和null</p><p>LikedList: 以单链表的方式存储，增、删快，查、改慢</p><h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h4><p>HashMap与Hashtable都实现的Map接口,HashTable线程安全，HashMap线程不安全。</p><h4 id="Collection-和-Collections的区别"><a href="#Collection-和-Collections的区别" class="headerlink" title="Collection 和 Collections的区别"></a>Collection 和 Collections的区别</h4><p>Collection是集合的根接口，其下有set（无序）及list（有序）<br>Collections是集合的算法。</p><p>Map不继承于Collection，是无序的键值对的集合，不允许重复</p><h4 id="Enumeration和Iterator接口的区别"><a href="#Enumeration和Iterator接口的区别" class="headerlink" title="Enumeration和Iterator接口的区别"></a>Enumeration和Iterator接口的区别</h4><p>Enumeration比Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。</p><p>Iterator能够删除元素，Enumeration不能。</p><h4 id="ArrayList集合加入1万条数据，应该怎么提高效率"><a href="#ArrayList集合加入1万条数据，应该怎么提高效率" class="headerlink" title="ArrayList集合加入1万条数据，应该怎么提高效率"></a>ArrayList集合加入1万条数据，应该怎么提高效率</h4><p>ArrayList的默认初始容量为10，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了10万条数据了，我们可以直接在初始化的时候就设置ArrayList的容量！</p><h4 id="HashMap的key值要是为类对象则该类需要满足什么条件？"><a href="#HashMap的key值要是为类对象则该类需要满足什么条件？" class="headerlink" title="HashMap的key值要是为类对象则该类需要满足什么条件？"></a>HashMap的key值要是为类对象则该类需要满足什么条件？</h4><p>转载自<a href="https://segmentfault.com/a/1190000014403696#articleHeader11" target="_blank" rel="noopener">这里</a></p><p>需同时重写该类的hashCode()方法和它的equals()方法。</p><p>一般来说，我们会认为：只要两个对象的成员变量的值是相等的，那么我们就认为这两个对象是相等的！因为，Object底层比较的是两个对象的地址，而对我们开发来说这样的意义并不大~这也就为什么我们要重写equals()方法</p><p>重写了equals()方法，就要重写hashCode()的方法。因为equals()认定了这两个对象相同，而同一个对象调用hashCode()方法时，是应该返回相同的值的</p><h4 id="与equals"><a href="#与equals" class="headerlink" title="== 与equals"></a>== 与equals</h4><p>==：主要用于基本数据类型（byte、int、char、long、float、double、boolean和short）及引用<br>equals()：用于对象及引用，（String一般用equals）</p><h2 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h4><p>事务是是并发控制单位，要么全部做要么劝都不做。如果你自己不去控制事务，数据库默认一条sql语句就处在自己单独的事务当中。以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。</p><h4 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h4><p>（呃啊这需要理解到位，第一次面试遇到过的题目）<br><strong>原子性、一致性、隔离性、持久性</strong><br>链接：<a href="https://blog.csdn.net/leprovision/article/details/81021675" target="_blank" rel="noopener">什么是事务,事务的四个特性是什么</a><br>⑴ 原子性（Atomicity）<br>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p>⑵ 一致性（Consistency）<br>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><p>⑶ 隔离性（Isolation）</p><p>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><p>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p><p>⑷ 持久性（Durability）</p><p>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><p>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p><p>　　以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p><p>1，脏读</p><p>　　脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p><p>　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下</p><p>update account set money=money+100 where name=’B’; (此时A通知B) update account set money=money - 100 where name=’A’;</p><p>　　当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p><p>2，不可重复读</p><p>　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p><p>　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p><p>　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p><p>　　在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</p><p>3，虚读(幻读)</p><p>　　幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p><p>　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有可能不全是Java的知识，只是时间一长感觉这些知识会忘了，就把我遇到的和我了解的先列列看吧。其中会出现许多来自百度、知乎、CSDN等处的内容，就不一一列出来了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Java&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>获取指定行所在的列</title>
    <link href="http://yoursite.com/2018/10/10/%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%89%80%E5%9C%A8%E7%9A%84%E5%88%97/"/>
    <id>http://yoursite.com/2018/10/10/获取指定行所在的列/</id>
    <published>2018-10-10T07:27:02.000Z</published>
    <updated>2019-01-21T09:31:39.588Z</updated>
    
    <content type="html"><![CDATA[<p>每次前端的问题都能把我整好久，看来当时网页这门课没学好，今天遇到的问题是不知道如何获取table下某一列的所有数值，校验后并对它所在的行的其他兄弟节点进行操作。</p><p>html：</p><pre><code>&lt;table class=&quot;datatbl&quot;&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;td&gt;xxx&lt;/td&gt;            &lt;td&gt;xxx&lt;/td&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;        &lt;s:iterator value=&quot;list&quot;&gt;            &lt;td class=&quot;a&quot;&gt;&lt;s:property value=&quot;a&quot;/&gt;&lt;/td&gt;            &lt;td class=&quot;compareFlag&quot;&gt;&lt;s:property value=&quot;b&quot;/&gt;&lt;/td&gt;        &lt;/s:iterator&gt;    &lt;/tbody&gt;&lt;/table&gt;</code></pre><p>思路：为了操作步骤方便，我直接将要获取的那一列加上class，本来想从table一步步往下找，但是不知道怎么.childern不太会用，索性直接根据class找所有的元素。<br>​<br>    $(“.compareFkStatus”).each(function(){<br>        console.log($(this).html());<br>    });</p><p>然后获取此td所在的tr，也就是其父节点</p><pre><code>$(&quot;.compareFkStatus&quot;).each(function(){    console.log($(this).html());    var parent = $(this).parent();    var a = parent.find(&quot;[class=&apos;a&apos;]&quot;).html();    console.log(&quot;a:&quot;+a);});</code></pre><p>这里parent就是所在列，a就是所在列。</p><p>总结一下，也就是子元素与父元素的获取<br>​<br>    $(子元素).parent() #获取父元素<br>    $(父元素).children(selector) #获取子元素<br>    $(xxx).find(“[class=’a’]”)    #与上面相似，此处的意思为xxx下的class为a的元素</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每次前端的问题都能把我整好久，看来当时网页这门课没学好，今天遇到的问题是不知道如何获取table下某一列的所有数值，校验后并对它所在的行的其他兄弟节点进行操作。&lt;/p&gt;
&lt;p&gt;html：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table class=&amp;quot;datatb
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>搭建博客步骤</title>
    <link href="http://yoursite.com/2018/10/10/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%AD%A5%E9%AA%A4/"/>
    <id>http://yoursite.com/2018/10/10/搭建博客步骤/</id>
    <published>2018-10-10T01:42:31.000Z</published>
    <updated>2019-01-21T09:31:23.314Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面，这其实不是我第一次搭博客，之前尝试过一次但是兴致冲冲地找了很多教程做到后来发现hexo装的就有些问题，并不是网上的教程不详细，但是东看西看容易出错，这里重头再来一遍，把之前的坑都补上</p></blockquote><h3 id="安装Nexo"><a href="#安装Nexo" class="headerlink" title="安装Nexo"></a>安装Nexo</h3><p>前提：安装好了node.js和git</p><p>1)新建一个空的文件夹，用于存放你的项目，在其中打开Git Bash</p><p>2)依次执行以下命令：<br>​<br>​    npm install hexo-cli -g<br>​    hexo init blog<br>​    cd blog<br>​    npm install<br>​    hexo server</p><p>其中第一步可能会等的久一点，耐心等待。</p><p>3)浏览器打开4000端口，可以在本地看到原始的hexo博客，ctrl+c关闭，每次想预览可以再输入 <code>hexo server (hexo s)</code></p><p>如果4000端口占用，可用<code>hexo server -p 其他端口号</code>，也可以找方法把4000端口的服务关掉</p><p>这一步有问题一定要解决，hexo运行正常才是搭一个githubio的前提</p><h3 id="部署到GitHub-Pages"><a href="#部署到GitHub-Pages" class="headerlink" title="部署到GitHub Pages"></a>部署到GitHub Pages</h3><p>1) 在GitHub新建一个仓库，Repository name必须得是 <strong>账户名.github.io</strong> </p><p>这时你已经可以访问 <a href="https://xxx.github.io/了" target="_blank" rel="noopener">https://xxx.github.io/了</a></p><p>2) 回到你的blog文件夹下，执行：<br>​<br>​    $ git config –global user.name “yourname”<br>​    $ git config –global user.name “<a href="mailto:youremail@xx.com" target="_blank" rel="noopener">youremail@xx.com</a>“</p><p>3) 找到_config.yml，在最后找到下面的内容并修改：<br>​<br>​    deploy:<br>​    type: git<br>​    repository: <a href="https://github.com/WYuyin/WYuyin.github.io.git" target="_blank" rel="noopener">https://github.com/WYuyin/WYuyin.github.io.git</a><br>​    branch: master</p><p>4) 执行命令 <code>hexo d -g</code> 就可完成部署</p><p>等待一会会让你输入GitHub用户名和密码，再访问<a href="http://xxx.github.io就可以看到你的主页" target="_blank" rel="noopener">http://xxx.github.io就可以看到你的主页</a></p><blockquote><p>这里 搭建和部署是两个命令，第一次部署需要用hexo g，安装完插件后每次要提交只需hexo d即可，如果出错可以hexo clean + hexo d -g</p></blockquote><h3 id="使用NexT"><a href="#使用NexT" class="headerlink" title="使用NexT"></a>使用NexT</h3><p>1) 安装</p><pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>2) 启用，修改_config.yml:<br>​<br>​    theme: next</p><p>3) 开启服务后再访问你的主页就可以看到NexT了</p><pre><code>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d -g$ hexo g &amp;&amp; hexo s   #如需本地预览，执行这一条</code></pre><p>提交了后并不是立马刷新的，稍微等十几秒钟才能更新</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>这里根据个人喜好装饰博客，我之前其实已经做完了这些工作，一些配置就直接复制的之前的配置文件，这里区分两个配置文件，一个是安装hexo时生成的，还有一个是next主题中的，位置blog\themes\next_config.yml，修改样式主要在这两个中，另外如果想修改NexT的css样式，直接添加进\blog\themes\next\source\css_custom\custom.styl<br>​<br>样式的修改参考了<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">大佬的博客</a></p><p>下面就一些我遇到的坑记录解决方法</p><h4 id="字数与阅读时长"><a href="#字数与阅读时长" class="headerlink" title="字数与阅读时长"></a>字数与阅读时长</h4><p>链接：<a href="https://www.jianshu.com/p/baea8c95e39b" target="_blank" rel="noopener">Hexo添加字数统计、阅读时长</a></p><h4 id="代码块高亮颜色"><a href="#代码块高亮颜色" class="headerlink" title="代码块高亮颜色"></a>代码块高亮颜色</h4><p>在配置文件中找到：</p><p>highlight_theme: normal，注释显示有五种显示主题可用，分别是：</p><ul><li>normal</li><li>night</li><li>night eighties</li><li>night blue</li><li>night bright</li></ul><h4 id="创建分类与标签"><a href="#创建分类与标签" class="headerlink" title="创建分类与标签"></a>创建分类与标签</h4><p>链接：<a href="https://blog.csdn.net/ganzhilin520/article/details/79047249" target="_blank" rel="noopener">hexo设置 关于 标签 分类 归档</a></p><h4 id="博客icon更替"><a href="#博客icon更替" class="headerlink" title="博客icon更替"></a>博客icon更替</h4><p>1) 找一个尽量长宽比相等的小图标，什么图片格式都可以</p><p>2) 百度，在线将你的图片转成ico格式</p><p>3) 将图标放在 blog\themes\next\source\images 文件夹下</p><p><img src="/2018/10/10/搭建博客步骤/20181010112351.png"></p><p>4) 修改 blog\themes\next_config.yml</p><p><img src="/2018/10/10/搭建博客步骤/20181010112817.png"></p><h4 id="在博客中添加图片"><a href="#在博客中添加图片" class="headerlink" title="在博客中添加图片"></a>在博客中添加图片</h4><p>链接：<a href="https://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="noopener">hexo生成博文插入图片</a></p><p>之前我用的是一种比较笨的方法，每次上传到github然后再添加打开，但是github加载的速度大家也知道，相当的慢，经常出不来，于是找到了这个hexo的插件：<code>npm install hexo-asset-image --save</code></p><p>当生成一个新的博客时会多出一个同名的文件夹，将图片放进去然后用<code>&lt;img src=&quot;xxxx/图片名.png&quot;&gt;</code>就可以实现了，当然，如果你想贴的是网上现成的图，直接写网址就ok</p><h4 id="首页不显示全文"><a href="#首页不显示全文" class="headerlink" title="首页不显示全文"></a>首页不显示全文</h4><p>在配置文件中找到 auto_excerpt ，并修改：</p><pre><code>auto_excerpt:  enable: true    #这里修改为true  length: 150</code></pre><h4 id="评论与其他"><a href="#评论与其他" class="headerlink" title="评论与其他"></a>评论与其他</h4><p>上面收集的是一些我开博客遇到的问题，另外有一些样式上的问题比较简单。评论我用了<a href="https://livere.com/introduce" target="_blank" rel="noopener">来必力</a>，网上有很多其他的第三方评论平台都已经停了，所以只能暂时用这个，还算方便快捷。</p><p>这里就告一段落啦，如果有问题欢迎留言讨论，不过我也还是一个小菜鸡呀</p><hr><p>10.18日更新</p><h4 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h4><pre><code>$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save</code></pre><p>然后在文章顶部+<code>top: true</code>就可以啦。另外还找到一个方法是改js，设置top的优先级，还未试过，这边给出<a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="noopener">链接</a></p><h4 id="菜单点击出现的小图案"><a href="#菜单点击出现的小图案" class="headerlink" title="菜单点击出现的小图案"></a>菜单点击出现的小图案</h4><p>总的来说看上去还是一个标标准准的Next风格，其实想变得与众不同一些我在一些小细节上还是做了很多改动的！比如这个点击菜单出现的喵喵图案，改起来其实并不难。<br>第一步，找一个背景透明，缩小看也不失真的图片，我是用ps调整的图片大小，【用画图工具的话好像会留白】，调整大小为30px*30px<br>第二步，将图片放在blog\themes\next\source\images目录下，和改icon的目录一致<br>第三步，修改\blog\themes\next\source\css_custom\custom.styl文件，添加：</p><pre><code>//菜单.menu-item-active a:after {    width: 30px;    height: 30px;    background: url(&quot;../images/miao2.png&quot;);    margin-top: -12px;//调整好位置}</code></pre><p>第四步，预览并调试图片的位置，上面的margintop是我调整后觉得合适的边距，主题不一样可能位置有偏差，用浏览器的开发者工具调整到一个最佳的角度就ok，效果：<img src="/2018/10/10/搭建博客步骤/20181018145958.png"></p><h4 id="加速博客浏览速度"><a href="#加速博客浏览速度" class="headerlink" title="加速博客浏览速度"></a>加速博客浏览速度</h4><p>找到一个好的博客真的是很难得，<a href="https://blog.csdn.net/linshuhe1/article/details/71170499" target="_blank" rel="noopener">河乐不为的CSDN</a>，<strong>重点！重点</strong>这里的操作完全和文中的一样，且没有遇到坑，惊喜</p><ul><li>注册Coding.net账号：<br>打开<a href="https://coding.net/" target="_blank" rel="noopener">Coding.net官网</a>，注册一个个人账号</li><li>新建项目<br>注意项目名与注册用的账户名一致，这里我用的是WYuyin：</li><li>添加公钥<br>上面设置完毕之后点击创建项目，然后点击设置-&gt;部署公钥-&gt;新建部署公钥，之前部署到Github上的时候，本地目录 C\User(中文为用户)(电脑用户名).ssh 目录下会有 github.rsa.pub 公钥文件，打开然后复制里面的内容，直接贴在这里的公钥框中：<br><img src="/2018/10/10/搭建博客步骤/20181018151019.png"><br><img src="/2018/10/10/搭建博客步骤/20181018151145.png"><blockquote><p>记得要勾选 授予推送权限 ，否则在后面运行hexo d时会提示错误：<br>  Coding.net Tips : [Deploy key is not allowed to push!]<br>  fatal: Could not read from remote repository.<br>原因就是没有推送权限。</p></blockquote></li></ul><p>打开Git命令窗口，输入以下指令：</p><pre><code>ssh -T git@git.coding.NET</code></pre><p>假如出现以下输出结果，表示公钥绑定成功：</p><pre><code>The authenticity of host &apos;git.coding.net (118.25.166.124)&apos; can&apos;t be established.RSA key fingerprint is SHA256:jok3FH7q5LJ6qvE7iPNehBgXRw51ErE77S0Dn+Vg/Ik.Are you sure you want to continue connecting (yes/no)? yPlease type &apos;yes&apos; or &apos;no&apos;: yesWarning: Permanently added &apos;git.coding.net,118.25.166.124&apos; (RSA) to the list of known hosts.Coding 提示: Hello WYuyin, You&apos;ve connected to Coding.net via SSH. This is a deploy key.WYuyin，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个部署公钥</code></pre><ul><li><p>修改hexo配置<br>打开hexo本地的配置文件 _config.yml，修改 deploy 的配置内容，这里设置了运行hexo d之后部署的目的地址，原本只有Github地址，现在添加多Coding.net的地址，其中WYuyin是注册该平台的 用户名：</p><pre><code>deploy:  type: git  repository: github: https://github.com/WYuyin/WYuyin.github.io.gitcoding: git@git.coding.net:WYuyin/WYuyin.git,master  branch: master</code></pre></li><li><p>正式部署到Coding.net：<br>打开命令行窗口，定位到当前hexo项目的根目录下，运行以下指令将本地博客部署到Github和Coding.net上：</p><pre><code>hexo g  hexo d</code></pre></li><li><p>设置Coding Page：<br><img src="/2018/10/10/搭建博客步骤/20181018152156.png"><br>设置成功后是这个样子<br><img src="/2018/10/10/搭建博客步骤/20181018152406.png"></p></li></ul><p>然后访问<a href="http://wyuyin.coding.me/" target="_blank" rel="noopener">http://wyuyin.coding.me/</a>就可以啦，无需等待立马就可以见到效果,访问的速度比之前快了一倍，另外我也对next的js做了一些调整，这里参考<a href="https://blog.csdn.net/Domino_b/article/details/81704118" target="_blank" rel="noopener">Soul_wwb的CSDN</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;写在前面，这其实不是我第一次搭博客，之前尝试过一次但是兴致冲冲地找了很多教程做到后来发现hexo装的就有些问题，并不是网上的教程不详细，但是东看西看容易出错，这里重头再来一遍，把之前的坑都补上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安
      
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
