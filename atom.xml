<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只小喵喵的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-20T06:51:20.710Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库索引[下]</title>
    <link href="http://yoursite.com/2019/09/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95-%E4%B8%8B/"/>
    <id>http://yoursite.com/2019/09/19/数据库索引-下/</id>
    <published>2019-09-19T02:05:17.000Z</published>
    <updated>2019-09-20T06:51:20.710Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="http://cmsblogs.com/?p=5469" target="_blank" rel="noopener">http://cmsblogs.com/?p=5469</a></p><p><a href="https://blog.csdn.net/mrzhouxiaofei/article/details/79940958" target="_blank" rel="noopener">https://blog.csdn.net/mrzhouxiaofei/article/details/79940958</a></p><p>上一篇主要介绍了自增约束、聚簇索引也就是主索引、以及索引的物理结构，一开始说索引分类的时候有提到<strong>全文索引</strong>和<strong>组合索引</strong></p><p>全文索引</p><p>通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。</p><p>你可能会说，用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。</p><p>你可能没有注意过全文索引，不过至少应该对一种全文索引技术比较熟悉：各种的搜索引擎。虽然搜索引擎的索引对象是超大量的数据，并且通常其背后都不是关系型数据库，不过全文索引的基本原理是一样的。</p><h2 id="版本支持"><a href="#版本支持" class="headerlink" title="版本支持"></a>版本支持</h2><p>开始之前，先说一下全文索引的版本、存储引擎、数据类型的支持情况</p><p>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；<br>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;<br>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。<br>测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。</p><h2 id="创建删除全文索引"><a href="#创建删除全文索引" class="headerlink" title="创建删除全文索引"></a>创建删除全文索引</h2><p>全文索引的关键字为fulltext</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建表时创建全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> article ( </span><br><span class="line">                  <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>, </span><br><span class="line">                  title <span class="built_in">VARCHAR</span>(<span class="number">200</span>), </span><br><span class="line">                  <span class="keyword">body</span> <span class="built_in">TEXT</span>, </span><br><span class="line">                  FULLTEXT(title, <span class="keyword">body</span>) </span><br><span class="line">              ) <span class="keyword">TYPE</span>=MYISAM;</span><br></pre></td></tr></table></figure><p>在已存在的表上创建全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT <span class="keyword">INDEX</span> ft_email_name <span class="keyword">ON</span> <span class="string">`student`</span> (<span class="string">`name`</span>)</span><br><span class="line">#也可以在创建索引的时候指定索引的长度：</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT <span class="keyword">INDEX</span> ft_email_name <span class="keyword">ON</span> <span class="string">`student`</span> (<span class="string">`name`</span>(<span class="number">20</span>))</span><br></pre></td></tr></table></figure><p>通过 SQL 语句 ALTER TABLE 创建全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">ADD</span> FULLTEXT <span class="keyword">INDEX</span> ft_stu_name  (<span class="string">`name`</span>) </span><br><span class="line">#ft_stu_name是索引名，可以随便起</span><br><span class="line"></span><br><span class="line">#或者：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">ADD</span> FULLTEXT ft_stu_name  (<span class="string">`name`</span>)</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改个 O，直接删掉重建。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>直接使用 DROP INDEX 删除全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> content_tag_fulltext</span><br><span class="line">    <span class="keyword">on</span> fulltext_test;</span><br></pre></td></tr></table></figure><p>通过 SQL 语句 ALTER TABLE 删除全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> fulltext_test</span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">index</span> content_tag_fulltext;</span><br></pre></td></tr></table></figure><h2 id="使用全文索引"><a href="#使用全文索引" class="headerlink" title="使用全文索引"></a>使用全文索引</h2><p>如何创建比较简单，这里就不说了，来看一下怎么使用</p><p>全文索引的使用方式一般为使用 <code>MATCH()... AGAINST</code></p><p>使用的时候感觉索引名根本没什么用，因为语法是这样的：</p><p><code>select * from tb_name where match(col_name)against(&#39;a&#39;)</code></p><p>另外插一句，使用全文索引时，测试表里至少要有 4 条以上的记录，否则，会出现意想不到的结果。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ul><li><p>MySql自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。如果需要对包含中文在内的文本数据进行全文检索，我们需要采用Sphinx（斯芬克斯）/Coreseek技术来处理中文。</p></li><li><p>数据表越大，全文索引效果好，比较小的数据表会返回一些难以理解的结果。</p></li><li>只有由字母，数字，单引号，下划线构成的字符串被认为是单词，带注音符号的字母仍是字母，像C++不再认为是单词，且不区分大小写</li><li>全文索引创建速度慢，而且对有全文索引的各种数据修改操作也慢</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;a href=&quot;http://cmsblogs.com/?p=5469&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cmsblogs.com/?p=5469&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引[上]</title>
    <link href="http://yoursite.com/2019/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%5B%E4%B8%8A%5D/"/>
    <id>http://yoursite.com/2019/09/18/数据库索引[上]/</id>
    <published>2019-09-18T02:34:53.000Z</published>
    <updated>2019-09-19T02:10:02.466Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="http://cmsblogs.com/?p=5477" target="_blank" rel="noopener">http://cmsblogs.com/?p=5477</a></p><p><a href="https://blog.csdn.net/tongdanping/article/details/79878302" target="_blank" rel="noopener">https://blog.csdn.net/tongdanping/article/details/79878302</a></p><p><a href="https://www.cnblogs.com/JiangLe/p/6362770.html" target="_blank" rel="noopener">https://www.cnblogs.com/JiangLe/p/6362770.html</a></p><p><a href="https://blog.csdn.net/du5006150054/article/details/82379210" target="_blank" rel="noopener">https://blog.csdn.net/du5006150054/article/details/82379210</a></p><p>记得大二刚开始学数据库的时候，学的Oracle，书本和考试的重点就是一些增删改查、视图存储过程，索引只是一带而过，也不知道这东西究竟是什么原理，有什么效果，（也许老师讲过我忘了），总之当时并不觉得时什么很重要的内容，但现在却常常提起。</p><p>有时开会的时候大佬们讨论要不要建索引 怎么建，还有看到许多面试题会扯到，索引的机制、策略等</p><p>索引，可以看作一个特定的结构，以某种方式指向数据，这样就不用检索全表，而采取先检索索引的达到快速查找的目的。在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，而在MySQL中使用的是Innodb引擎。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p><strong>常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引</strong></p><p>1、主键索引：即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值；</p><p><code>ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;)；</code><br>2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值</p><p><code>ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)；</code><br>3、普通索引：用表中的普通列构建的索引，没有任何限制</p><p><code>ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)；</code><br>4、全文索引：用大文本对象的列构建的索引（下一部分会讲解）</p><p><code>ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;)；</code><br>5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值</p><p><code>ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)；</code></p><ul><li><p>遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。</p></li><li><p>在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引</p></li></ul><p><code>ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(col1(4),col2（3))；</code></p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>有非空、自增、唯一、主键约束，当然还有外键，只不过外键我一般不用</p><p>想必你已经很熟悉 MySQL Innodb 中的 AUTO_INCREMENT，如果某个字段添加了这个约束条件，插入数据的时候，如果没有给该字段指定一个值，那么它就会自动插入一个自增长的值。</p><h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h3><p>AUTO_INCREMENT 是 Innodb 提供的一种可配置的锁定机制，如果某个表的某一列具有 AUTO_INCREMENT 约束，那么向该表添加数据的时候可以很明显的提高 SQL 语句的性能和可伸缩性。</p><p>指定了AUTO_INCREMENT的列必须要建索引，不然会报错。这个索引不一定就是主键，甚至可以不是唯一索引。</p><p>通常情况下，为了最大化性能，添加了 AUTO_INCREMENT 约束的列要么独自成一个索引 ( 主索引 )，那么是组合索引中的第一列</p><h3 id="AUTO-INCREMENT锁的模式"><a href="#AUTO-INCREMENT锁的模式" class="headerlink" title="AUTO_INCREMENT锁的模式"></a>AUTO_INCREMENT锁的模式</h3><p>使用了 AUTO_INCREMENT 那么多次，我们已经知道它的主要作用就是产生一个不重复的 「 自增值 」。</p><p>我们知道，插入多条数据有两种插入方法，一种是一条一条的执行 INSERT INTO，另一种是 INSERT INTO VALUES(…),(…) 多条一起插入</p><p>这两种插入方法都能正确的自增 AUTO_INCREMENT 列，它们是如何做的呢 ？</p><p>这就仰赖了 <strong>AUTO_INCREMENT 锁</strong>，为了适应这两种插入方法，它同时也具有多种模式。</p><p>「 AUTO_INCREMENT 锁」模式的配置变量为 <code>innodb_autoinc_lock_mode</code> ，我们可以通过下面的语句查看当前的模式是什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;innodb_autoinc_lock_mode&apos;;</span><br></pre></td></tr></table></figure><p>在我的 <code>5.7.22</code> 的版本的 MySQL 中，输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> mysql&gt; show variables like &apos;innodb_autoinc_lock_mode&apos;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_autoinc_lock_mode | 1     |</span><br><span class="line">+--------------------------+-------+</span><br></pre></td></tr></table></figure><p>配置参数 <code>innodb_autoinc_lock_mode</code> 有三个可选的值，分别是 <code>0</code>、<code>1</code> 和 <code>2</code> ，分别代表着 「 传统 」，「 连续 」 或 「 交错 」 三种锁模式</p><p>在不同的版本下，<code>innodb_autoinc_lock_mode</code> 的默认值是不一样的，在 <code>mysql &gt;= 8.0.3</code> 版本中是 <code>2</code>，也就是 「 交错 」 模式，而 <code>mysql &lt;= 8.0.2</code> 版本中是 <code>1</code>，也就是 「 连续 」 模式</p><p>对于 <code>8.0.3</code> 版本中的这种变更，也反应了 Innodb 的默认 「 复制模式 」 已经从基于 <strong>SQL 语句</strong> 变更为基于 <strong>行</strong> ( row )</p><p>基于 SQL 语句的复制需要 「 连续 」 模式的 「 AUTO_INCREMENT 锁」，以确保为给定的 SQL 语句序列以可预测和可重复的顺序分配自动增量值，而基于行的复制对 SQL 语句的执行顺序不敏感</p><p><strong>术语</strong><br>在我们继续讲解之前，为了方便大家理解一些术语或概念，我们先罗列在此</p><p>「 insert like 」 语句</p><p>所有可以在表中添加新行的语句，我们称之为 「 insert like 」 语句，例如</p><p>INSERT, INSERT … SELECT<br>REPLACE<br>REPLACE … SELECT<br>LOAD DATA<br>其它的还有 「 simple-inserts 」、「 bulk-inserts 」和 「 mixed-mode 」 三种插入语句<br>「 simple-inserts 」 语句</p><p>「 simple-inserts 」 是可以预先确定要插入的行数的语句 ( 最初处理语句时 )。包括不带子查询的 单行 和 多行 INSERT 和REPLACE 语句，但不包括 INSERT … ON DUPLICATE KEY UPDATE 语句</p><p>「 Bulk inserts 」 批量插入</p><p>「 Bulk inserts 」是预先不知道要插入的行数（以及所需的自动增量值的数量）的语句。</p><p>包括 INSERT … SELECT，REPLACE … SELECT 和 LOAD DATA 语句，但不包括普通的 INSERT</p><p>在处理每一行时，InnoDB 都会重新为 AUTO_INCREMENT 列分配一个新值</p><p>「 Mixed-mode inserts 」 混合模式插入</p><p>「 Mixed-mode inserts 」 是指「 simple-inserts 」 语句中，有些指定了 AUTO_INCREMENT 列的值，而另一些则没有。</p><p>例如下面的 SQL 语句，其中 c1 是表 t1 的 AUTO_INCREMENT 列</p><p>INSERT INTO t1 (c1,c2) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’);</p><p>另一种类型的 「 Mixed-mode inserts 」 是 INSERT … ON DUPLICATE KEY UPDATE ，这种语句最坏的情况下实际上是 INSERT 后跟 UPDATE，其中在更新阶段，可能会也可能不会为 AUTO_INCREMENT 列的分配值</p><h4 id="innodb-autoinc-lock-mode-0-传统锁模式"><a href="#innodb-autoinc-lock-mode-0-传统锁模式" class="headerlink" title="innodb_autoinc_lock_mode = 0 传统锁模式"></a>innodb_autoinc_lock_mode = 0 传统锁模式</h4><p>传统锁模式是在 <code>MySQL 5.1</code> 中引入 <code>innodb_autoinc_lock_mode</code> 配置参数之前的默认模式。现在，传统锁模式存在的意义，仅仅是用于向后兼容，性能测试以及解决 「 混合模式插入 」 问题，因为语义方面可能存在差异。</p><p>在这种锁模式下，为了向具有 <code>AUTO_INCREMENT</code> 列的表中插入数据，所有的 「 insert like 」 语句都会获得一个特殊的 <strong>表级 AUTO-INC</strong> 锁，这种锁会自动添加到 SQL 语句的末尾 ( 不是事务的末尾 )，以确保以可预测且可重复的顺序为给定的 INSERT 语句序列分配自增值，并确保为任何给定语句分配的自增值都是连续的。</p><p>在基于 SQL 语句的 ( 主从 ) 复制环境中，在从服务器上运行复制 SQL 语句时，自增量列的值和主服务器的值相同，这样执行多个 INSERT 语句的结果是确定性的，并且从服务器的数据和主服务器的数据一摸一样。</p><p>如果多个 INSERT 语句生成的自增值是交错的，那么两个并发 INSERT 语句的结果将是不确定的，这样就无法使用基于 SQL 语句的复制模式将数据可靠地复制到从服务器</p><p>凸(艹皿艹 ) 啃不动了，有点干，换个看看</p><p>1、它提供了一个向后兼容的能力<br>2、在这一模式下，所有的insert语句(“insert like”) 都要在语句开始的时候得到一个表级的auto_inc锁，在语句结束的时候才释放这把锁，注意呀，这里说的是语句级而不是事务级的，一个事务可能包涵有一个或多个语句。<br>3、它能保证值分配的可预见性，与连续性，可重复性，这个也就保证了insert语句在复制到slave的时候还能生成和master那边一样的值(它保证了基于语句复制的安全)。<br>4、由于在这种模式下auto_inc锁一直要保持到语句的结束，所以这个就影响到了并发的插入。</p><h4 id="innodb-autoinc-lock-mode-1-连续锁模式"><a href="#innodb-autoinc-lock-mode-1-连续锁模式" class="headerlink" title="innodb_autoinc_lock_mode = 1 连续锁模式"></a>innodb_autoinc_lock_mode = 1 连续锁模式</h4><p>1、这一模式下去simple insert 做了优化，由于simple insert一次性插入值的个数可以立马得到确定，所以mysql可以一次生成几个连续的值，用于这个insert语句；总的来说这个对复制也是安全的<br>          (它保证了基于语句复制的安全)<br>2、这一模式也是mysql的默认模式，这个模式的好处是auto_inc锁不要一直保持到语句的结束，只要语句得到了相应的值后就可以提前释放锁</p><h4 id="innodb-autoinc-lock-mode-2-交错锁模式"><a href="#innodb-autoinc-lock-mode-2-交错锁模式" class="headerlink" title="innodb_autoinc_lock_mode = 2 交错锁模式"></a>innodb_autoinc_lock_mode = 2 交错锁模式</h4><p>由于这个模式下已经没有了auto_inc锁，且多个语句可以同时执行，所以这个模式下的性能是最好的；但是它也有一个问题，就是对于同一个语句来说它所得到的auto_incremant值可能不是连续的。</p><hr><p>简单总结这三种锁模式</p><p>传统锁模式 – 不管三七二十一，先用表级的 AUTO-INC 锁，直到语句插入完成，然后释放锁<br>连续锁模式 – 不管三七二十一，先用互斥锁，然后生成所有插入行需要的自增值，然后释放互斥锁，最后使用这些自增值来插入数据。对于行数未知的，那就只能使用 「 传统锁 」 模式了，先锁起来，执行完毕了再释放，因为人家不知道要生成多少自增值啊<br>交错模式 – 管它刮风下雨，需要的时候再生成，也管它连续与否，用了就是了…</p><p>交错模式在日常的 <code>SELECT</code> 语句中是不会出啥问题的，因为会按照自增值排序，出问题就处恢复数据或主从过程中的二进制日志回放，可能导致从库或者恢复的数据的自增值和源数据不一致。</p><h3 id="丢失自增值和序列间隙"><a href="#丢失自增值和序列间隙" class="headerlink" title="丢失自增值和序列间隙"></a>丢失自增值和序列间隙</h3><p>无论你使用的是哪种锁模式 ( 0 , 1 或 2 )，如果生成自增值的事务回滚，则这些自增量值将 「 丢失 」。</p><p>一旦为 <code>AUTO_INCREMENT</code> 列生成一个自增值后，无论 「 INSERT-like 」 语句是否完成，以及包含事务是否回滚，都无法回滚该自增值。</p><p>这些丢失的自增值不会被重复使用。因此，表的 <code>AUTO_INCREMENT</code> 列中的值可能存在间隙</p><p>这一点我遇到过，如果删除表中自增主键最大的一行信息，再添加新的一条数据时生成的主键是跳过被删除的主键的，<strong>丢失的自增值不会被重复使用</strong></p><h3 id="「-批量插入-」-中的自增值的间隙"><a href="#「-批量插入-」-中的自增值的间隙" class="headerlink" title="「 批量插入 」 中的自增值的间隙"></a>「 批量插入 」 中的自增值的间隙</h3><p>对于锁模式 1 和 2 ，连续的语句间也可能出现间隙，因为批量插入，可能并不知道每个语句所需的确切数量的自增值，可能会存在高估，如果一旦高估了，那么高估的自增值将会被抛弃且永远也不会使用到。</p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p>从数据存储方式上索引可以分为聚簇索引（又叫主索引）和非聚簇索引（又叫二级索引、辅助索引）两种</p><p>聚簇索引就是 「 主键 」( primary key ) ，Innodb 使用它存储表中每一行的数据。</p><p>如果想要从 <a href="https://www.twle.cn/l/yufei/mysql/mysql-basic-select-query.html" target="_blank" rel="noopener">查询</a>，<a href="https://www.twle.cn/l/yufei/mysql/mysql-basic-insert-query.html" target="_blank" rel="noopener">插入</a> 和其它数据库操作中获得最佳性能，那么我们就必须了解 InnoDB 如何使用 <strong>聚簇索引</strong> 来优化每个表的最常见检索和 DML 操作方式</p><ul><li><p>当我们在一个 Innodb 表上定义了一个主键，InnoDB 会默认的使用它作为聚簇索引。</p><p>使用 InnoDB 存储引擎时，建议为每个表都添加一个主键。如果该表没有一个逻辑唯一且非空列或列集合，那么可以添加一个带有 AUTO_INCREMENT 约束的自增列作为主键，InnoDB 会自动填充该列。</p></li><li><p>如果某个 InnoDB 表并没有定义主键。那么 InnoDB 会查找第一个 「 唯一索引 」( UNIQUE Index ) ，因为唯一索引的所有键 ( key ) 都是 <code>NOT</code> ，因此可以用来作为聚簇索引</p></li><li><p>如果某个 InnoDB 表既没有定义主键，也没有一个合适的唯一索引。InnoDB 会在内部生成一个名为 <code>GEN_CLUST_INDEX</code> 的隐式的聚簇索引</p><p>该聚簇索引的键 ( key ) 会包含一个自动为行生成的 ID 值 ( 行号 ) 。</p><p>该表中的所有行会按 InnoDB 分配给此类表中的行的 ID 排序。</p><p>行 ID 是一个 <strong>6</strong> 字节的字段，在插入新行时会单调自增。</p><p>因此，可以认为物理上的行保存顺序就是该行 ID 排序的排序顺序</p></li></ul><p>另外，MyISAM存储引擎采用的是非聚簇索引，Innodb采取的是聚簇索引</p><h3 id="聚簇索引如何加快查询速度"><a href="#聚簇索引如何加快查询速度" class="headerlink" title="聚簇索引如何加快查询速度"></a>聚簇索引如何加快查询速度</h3><p>通过聚簇索引访问行很快，因为索引搜索直接指向包含所有行数据页 ( data page )。</p><p>如果表很大，与那种索引页与数据页分离的 MyISAM 存储引擎相比， 聚簇索引体系结构通常可以节省磁盘 I/O 操作。</p><h3 id="非聚簇索引和聚簇索引的关系"><a href="#非聚簇索引和聚簇索引的关系" class="headerlink" title="非聚簇索引和聚簇索引的关系"></a>非聚簇索引和聚簇索引的关系</h3><p>非聚簇索引，通常也称之为 「 二级索引 」 ( Secondary Indexes ) 或 「 辅助索引 」 ，一般是指聚簇索引之外的所有其它的索引。</p><p>在 InnoDB 中，每个辅助索引中的每条记录都会包含该行的主键列 ( 也就是聚簇索引的键 ) ，以及为辅助索引指定的列。InnoDB 使用此主键值来搜索聚簇索引中的行</p><h3 id="聚簇索引和非聚簇索引的区别"><a href="#聚簇索引和非聚簇索引的区别" class="headerlink" title="聚簇索引和非聚簇索引的区别"></a>聚簇索引和非聚簇索引的区别</h3><p>如果主键很长，那么辅助索引就会占用更多空间，因此使用短主键是有利的，也是我们所推荐的</p><ol><li><p>首先，我们要认识到聚簇索引和非聚簇索引的划分依据是什么 ？</p><p>答案就是 InnoDB 会使用聚簇索索引来保存数据，而非聚簇索引的目的仅仅是加快查询速度</p></li><li><p>在第一点认知基础上，我们就可以知道</p><ul><li>聚簇索引是唯一的，一个 InnoDB 表只有一个聚簇索引，而且一定会有一个聚簇索引，如果不存在，Innodb 存储引擎会自动添加一个</li><li>非聚簇所以可以有多个，而且只能由用户自己添加，InnoDB 默认并不会创建任何非聚簇索引。</li></ul></li><li><p>非聚簇索引中一定包含了聚簇索引的列值，但反过来却不存在。</p><p>因此，使用非聚簇索引查询数据一定会用到聚簇索引，但反过来却不存在。</p><blockquote><p>题外话 我总是把聚簇看成聚众索引 啊天呐！这是什么毛病</p></blockquote></li></ol><h2 id="索引的物理结构"><a href="#索引的物理结构" class="headerlink" title="索引的物理结构"></a>索引的物理结构</h2><p>几乎所有的 Innodb 的索引都使用 <code>B 树</code> 数据结构，除了空间索引 ( spatial indexes ) 是个例外（空间索引使用的是 <code>R 树</code>）。</p><p>不管使用的是任何索引结构，索引记录只存储在 B 树 或 R树 数据结构的叶子节点中。索引页的默认大小为 <code>16KB</code></p><p>B+树是Innodb中使用的数据结构，B+树中的B代表平衡（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。在这之前得先看看B树和B+树都有哪些区别</p><p><strong>恶龙咆哮：B树就是B-树就是平衡二叉树！</strong></p><h3 id="B-树-平衡二叉树"><a href="#B-树-平衡二叉树" class="headerlink" title="B-树(平衡二叉树)"></a>B-树(平衡二叉树)</h3><p>一棵m阶的B-Tree有如下特性：<br>\1. 每个节点最多有m个孩子。<br>\2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。<br>\3. 若根节点不是叶子节点，则至少有2个孩子<br>\4. 所有叶子节点都在同一层，且不包含其它关键字信息<br>\5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）<br>\6. 关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1<br>\7. ki(i=1,…n)为关键字，且关键字升序排序。<br>\8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</p><p>B-Tree的结构如下：</p><p><img src="https://img-blog.csdn.net/20160202204827368" alt="https://img-blog.csdn.net/20160202204827368"></p><p>在B-Tree的结构下，就可以使用二分查找的查找方式，查找复杂度为h*log(n)，一般来说树的高度是很小的，一般为3左右，因此BTree是一个非常高效的查找结构。</p><p>这边不详细讲树和树的插入删除了，之前看的一个大牛的博客里有详细地讲红黑树时有这些内容，感兴趣可以关注田小波的博客-&gt;<a href="http://www.tianxiaobo.com/2018/01/11/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://www.tianxiaobo.com/2018/01/11/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</a></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+Tree是BTree的一个优化。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在<strong>同一层</strong>的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度</p><p>结构如下：</p><p><img src="https://img-blog.csdn.net/20160202205105560" alt="https://img-blog.csdn.net/20160202205105560"></p><p>B+Tree相对于B-Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息。</li><li>所有叶子节点之间都有一个链指针。</li><li>数据记录都存放在叶子节点中。</li></ol><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 <em> 10^3 </em> 10^3 = 10亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><ol><li>InnoDB 表使用什么数据结构，它们的数据都保存在哪里</li></ol><p>使用的是 <code>B 树</code> 数据结构，它们的索引数据都保存在叶子节点中。</p><ol start="2"><li>InnoDB 的页大小一般是多少，把页大小提高为什么能提高 MySQL 的性能。</li></ol><p>页大小决定了每次 IO 操作读取的数据大小，设置的越高当然每次读取的数据就越多，可以较少 IO 操作</p><p>最后 再次感谢我参考的这些文章！</p><p><a href="http://cmsblogs.com/?p=5477" target="_blank" rel="noopener">http://cmsblogs.com/?p=5477</a></p><p><a href="https://blog.csdn.net/tongdanping/article/details/79878302" target="_blank" rel="noopener">https://blog.csdn.net/tongdanping/article/details/79878302</a></p><p><a href="https://www.cnblogs.com/JiangLe/p/6362770.html" target="_blank" rel="noopener">https://www.cnblogs.com/JiangLe/p/6362770.html</a></p><p><a href="https://blog.csdn.net/du5006150054/article/details/82379210" target="_blank" rel="noopener">https://blog.csdn.net/du5006150054/article/details/82379210</a></p><p>学饿了，也快下班了，今天暂时就到这里啦</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;a href=&quot;http://cmsblogs.com/?p=5477&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cmsblogs.com/?p=5477&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>聊聊线程</title>
    <link href="http://yoursite.com/2019/09/16/%E8%81%8A%E8%81%8A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/16/聊聊线程/</id>
    <published>2019-09-16T02:40:52.000Z</published>
    <updated>2019-09-23T02:29:58.610Z</updated>
    
    <content type="html"><![CDATA[<p>翻翻旧笔记整理一下线程相关知识</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>从操作系统的角度，可以认为<strong>线程</strong>是系统调度的最小单元，而<strong>进程</strong>是程序，一个进程可以包含多个线程，是任务的真正运作者，有自己的<strong>栈（Stack）、寄存器（Register）、本地存储（Thread local）</strong>等，会与进程内其他线程共享文件描述符、虚拟地址空间等。<br>多个线程共用进程的<strong>堆</strong>和<strong>方法区</strong></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>有新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead）五种状态<br><img src="/2019/09/16/聊聊线程/1111.png"><br>① 创建线程后，线程进入New状态，和普通对象一样，Java虚拟机会为其分配内存</p><p>② 调用start() 方法后，线程处于Runnable状态，可运行的，Java虚拟机会为其创建方法调用栈和程序计数器</p><p>③ 处于Runnable状态的线程获得CPU之后，开始执行方法体，处于Running运行状态</p><p>如果发生如下情况，线程会进入<strong>阻塞</strong>状态：</p><p>线程调用sleep方法主动放弃所占用的处理器资源。<br>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。<br>线程试图获得一个同步监视器，但该同步监视器正被其他线程锁持有。关于同步监视器的知识将在后面有更深入的介绍。<br>线程在等待某个通知(notify)。<br>程序调用了线程的suspend方法将该线程挂起。不过这个方法容易导致死锁，所以程序应该尽量避免使用该方法。<br>当前线程被阻塞后，其他线程就可获得执行的机会，被阻塞线程会在合适的时候进入就绪状态，等待重新调度，解除阻塞的情况有：</p><p>调用sleep方法的线程经过了指定时间。<br>线程调用的阻塞式IO方法已经返回。<br>线程成功地获得了试图取得同步监视器。<br>线程正在等待某个通知时，其他线程发出了一个通知。<br>处于挂起状态的线程被调用了resume恢复方法。<br>④ 线程死亡 run()方法执行完成，线程正常结束，或抛出未捕获的Exception或Error</p><p>Java5之后，线程的状态在java.lang.Thread.State中的枚举中，我用的是8，看到有NEW、RUNNABLE、BLOCKED、WAITING、TIME_WAITING计时等待、TEAMINATED终止六种。</p><p>可以看到区分了等待状态，Waiting表示等待其他线程的操作，常用于生产者消费者模式，通常，消费者进入等待wait模式，等待生产者发出notify等操作告诉消费者可以继续工作。计时等待Time_Waiting与Waiting类似，但调用的时候存在超时条件。</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程(Daemon Thread)，Java中线程分两种守护线程和用户线程</p><p>有时候需要一个长期驻留的服务程序，但是不希望其影响应用，当Java虚拟机发现只有守护线程存在时，将结束进程。百度百科上的守护进程（or线程）有详细的定义，一般的网络服务都是以守护进程的方式运行</p><p>任何线程都可以设置为守护线程,可通过setDaemon()中的参数为true来设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread daemonThread = <span class="keyword">new</span> Thread();</span><br><span class="line">daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure><p>垃圾回收线程是一个守护线程,如果只剩了守护线程,虚拟机会自动离开</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>Java提供了三种创建线程的方法：</p><ul><li><strong>实现Runnable接口</strong></li><li>继承Thread类本身</li><li>通过Callable和Future创建线程</li></ul><p>其中最简单的方法就是继承Runnable，复写run()方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;    <span class="comment">// 实现Runnable接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;    <span class="comment">// 覆写run()方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//currentThread()可以获取当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">"运行，i = "</span> + i) ;    <span class="comment">// 取得当前线程的名字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你也可以在类中实例化一个线程对象，常用的构造方法带的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable threadOb,String threadName);</span><br><span class="line"><span class="comment">//threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。</span></span><br></pre></td></tr></table></figure><p>比如这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> Mythread();</span><br><span class="line"><span class="keyword">new</span> Thread(thread,<span class="string">"线程A"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread,<span class="string">"线程B"</span>).start();</span><br></pre></td></tr></table></figure><p>出现频率也很高的<code>join()</code>方法不得不说，他可以使得一个线程强行运行，期间其他线程无法运行。</p><p>休眠，<code>sleep()</code>方法必须要有InterruptedException异常处理，入参时间的单位为毫秒</p><p><code>yield()</code>方法让线程放弃执行,将CPU的控制权让出</p><blockquote><p>Runnable 和 Callable 有什么不同？</p><p>Runnable 和 Callable 都代表那些要在不同的线程中执行的任务。Runnable 从 JDK1.0 开始就有了，Callable 是在 JDK1.5 增加的。它们的主要区别是 Callable 的 call() 方法可以返回值和抛出异常，而 Runnable 的 run() 方法没有这些功能。Callable 可以返回装载有计算结果的 Future 对象。</p><p>但是,单独使用 Callable，无法在新线程中(new Thread(Runnable r))使用，Thread 类只支持 Runnable。不过 Callable 可以使用 ExecutorService 。</p></blockquote><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h2><ul><li>newCachedThreadPool 创建一个可缓存的线程池，用来处理大量短时间任务的线程池；如果线程闲置的时间超过60秒，则被终止并移除缓存；长时间闲置时这种线程池不会消耗什么资源，在使用缓存型池时，先查看池中有没有以前创建的线程，如果有，就复用.如果没有，就新建新的线程加入池中</li><li>newFixedThreadPool 创建一个定长线程池</li><li>newScheduledThreadPool 创建一个定长线程池 定期和周期性的执行任务的线程池</li><li>newSingleThreadExecutor 与newScheduledThreadPool的区别在于创建一个单线程化的线程池</li><li>Java8之后加入了newWorkStealingPool(int parallelism) 线程池，其内部构建ForkJoinPool，利用Work-Stealing算法，并行的处理任务<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2>线程池管理者,ExecutorService接口继承了Executor接口.定义了一些生命周期的方法.我们能把Runnable,Callable提交到池中让其调度.</li></ul><p>先说使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如创建一个定长线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>看一下它的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;<span class="comment">//顺次地关闭ExecutorService,停止接收新的任务，等待所有已经提交的任务执行完毕之后，关闭ExecutorService</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;<span class="comment">//阻止等待任务启动并试图停止当前正在执行的任务，停止接收新的任务，返回处于等待的任务列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;<span class="comment">//判断线程池是否已经关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;<span class="comment">//如果关闭后所有任务都已完成，则返回 true。注意，除非首先调用 shutdown 或 shutdownNow，否则 isTerminated 永不为 true。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span><span class="comment">//等待（阻塞）直到关闭或最长等待时间或发生中断,timeout - 最长等待时间 ,unit - timeout 参数的时间单位  如果此执行程序终止，则返回 true；如果终止前超时期满，则返回 false </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    &lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;<span class="comment">//提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;<span class="comment">//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);<span class="comment">//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功 完成时将会返回 null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)<span class="comment">//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)<span class="comment">//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><span class="comment">//执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span><span class="comment">//执行给定的任务，返回已成功完成的任务结果（期间没抛异常），如果在超时时间内有任何异常，在返回时，未完成的任务将被取消，如果在执行此操作时修改了给定的集合，则此方法的结果是未定义的</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是!阿里巴巴开发规约中有一条说:</p><p>【强制】线程池不允许使用 Executors 去创建，而是通过 <strong>ThreadPoolExecutor</strong> 的方式，这样<br>的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说明：Executors 返回的线程池对象的弊端如下：<br>1）FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。<br>2）CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p><p><strong>重点:推荐使用ThreadPoolExecutor </strong></p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>自定义线程池，参考<a href="https://www.jianshu.com/p/f030aa5d7a28下面讲解参数较全的一个构造方法" target="_blank" rel="noopener">https://www.jianshu.com/p/f030aa5d7a28下面讲解参数较全的一个构造方法</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // <span class="number">1</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,  // <span class="number">2</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,  // <span class="number">3</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,  // <span class="number">4</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue, // <span class="number">5</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,  // <span class="number">6</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler )</span> </span>&#123; <span class="comment">//7</span></span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>名称</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>corePoolSize</td><td>int</td><td>核心线程池大小</td></tr><tr><td>2</td><td>maximumPoolSize</td><td>int</td><td>最大线程池大小</td></tr><tr><td>3</td><td>keepAliveTime</td><td>long</td><td>线程最大空闲时间</td></tr><tr><td>4</td><td>unit</td><td>TimeUnit</td><td>时间单位</td></tr><tr><td>5</td><td>workQueue</td><td>BlockingQueue<runnable></runnable></td><td>线程等待队列（阻塞队列）</td></tr><tr><td>6</td><td>threadFactory</td><td>ThreadFactory</td><td>线程创建工厂</td></tr><tr><td>7</td><td>handler</td><td>RejectedExecutionHandler</td><td>拒绝策略</td></tr></tbody></table><p><img src="/2019/09/16/聊聊线程/2222.png"></p><p>结合这张线程池处理流程图能更好的理解这些入参，keepAliveTime是超出核心线程池给予的时间，unit是keepAliveTime的单位，workQueue 阻塞队列，存放来不及处理的线程，有ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue，PriorityBlockingQueue几种，handler，拒绝/饱和策略，有AborPolicy直接抛弃，CallerRunsPolicy用调用这线程执行，DiscardOldestPolicy抛弃队列中最久的任务，DiscardPolicy抛弃当前任务四种</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p><strong>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p><p>以上参考:<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions.md</a></p><p>比如</p><blockquote><p>但是,又要说但是了,看到阿里规约中</p><p>【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static<br>修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享<br>此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只<br>要是这个线程内定义的)都可以操控这个变量。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。</p><p>通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。</p><p>请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h2><p>多线程会共同使用一组计算机上的 CPU ，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU 。</p><p>不同的线程切换使用 CPU 发生的切换数据等，就是上下文切换。<br>在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。</p><h2 id="如何结束线程"><a href="#如何结束线程" class="headerlink" title="如何结束线程"></a>如何结束线程</h2><p>可以使用interrupt()来中断一个正在执行的线程,它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。</p><h2 id="如何使用-wait-notify-实现通知机制？"><a href="#如何使用-wait-notify-实现通知机制？" class="headerlink" title="如何使用 wait + notify 实现通知机制？"></a>如何使用 wait + notify 实现通知机制？</h2><p>我们知道，java的wait/notify的通知机制可以用来实现线程间通信。wait表示线程的等待，调用该方法会导致线程阻塞，直至另一线程调用notify或notifyAll方法才可另其继续执行。经典的生产者、消费者模式即是使用wait/notify机制得以完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();  <span class="comment">//对象锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread consume = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consume(), <span class="string">"Consume"</span>);</span><br><span class="line">        Thread produce = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Produce(), <span class="string">"Produce"</span>);</span><br><span class="line">        consume.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        produce.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            produce.join();</span><br><span class="line">            consume.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Produce</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">"进入生产者线程"</span>);</span><br><span class="line">                System.out.println(<span class="string">"生产"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);  <span class="comment">//模拟生产过程</span></span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    obj.notifyAll();  <span class="comment">//通知消费者 </span></span><br><span class="line">                    <span class="comment">//notifyAll():唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态</span></span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);  <span class="comment">//模拟其他耗时操作</span></span><br><span class="line">                    System.out.println(<span class="string">"退出生产者线程"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consume</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">"进入消费者线程"</span>);</span><br><span class="line">                System.out.println(<span class="string">"wait flag 1:"</span> + flag);</span><br><span class="line">                <span class="keyword">while</span> (!flag) &#123;  <span class="comment">//判断条件是否满足，若不满足则等待</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"还没生产，进入等待"</span>);</span><br><span class="line">                        obj.wait();</span><br><span class="line">                        System.out.println(<span class="string">"结束等待"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"wait flag 2:"</span> + flag);</span><br><span class="line">                System.out.println(<span class="string">"消费"</span>);</span><br><span class="line">                System.out.println(<span class="string">"退出消费者线程"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个注意点:</p><p>1)wait、notify 方法是针对对象的</p><p>2)wait、notify 方法必须在 <code>synchronized</code> 块或方法中被调用</p><h2 id="SpringBoot中的自定义线程池"><a href="#SpringBoot中的自定义线程池" class="headerlink" title="SpringBoot中的自定义线程池"></a>SpringBoot中的自定义线程池</h2><p>ThreadPoolTaskExecutor是spring core包中的，而ThreadPoolExecutor是JDK中的JUC。ThreadPoolTaskExecutor是对ThreadPoolExecutor进行了封装处理。</p><p>ThreadPoolTaskExecutor,创建线程池:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line">   <span class="meta">@Configuration</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">TaskPoolConfig</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">           executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">           executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">           executor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line">           executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">           executor.setThreadNamePrefix(<span class="string">"taskExecutor-"</span>);</span><br><span class="line">           executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">           executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">           executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">           <span class="keyword">return</span> executor;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在需要的地方用<code>@Async</code>注解使用即可</p><ul><li>无返回值的任务使用execute(Runnable)</li><li>有返回值的任务使用submit(Runnable)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;翻翻旧笔记整理一下线程相关知识&lt;/p&gt;
&lt;h1 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【详】socketIO与webSocket</title>
    <link href="http://yoursite.com/2019/09/09/socketIO%E4%B8%8EwebSocket/"/>
    <id>http://yoursite.com/2019/09/09/socketIO与webSocket/</id>
    <published>2019-09-09T06:56:21.000Z</published>
    <updated>2019-09-17T09:48:12.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补习"><a href="#补习" class="headerlink" title="补习"></a>补习</h1><p>先来补习几个月的前某天整理的一些TCP方面的知识</p><h2 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h2><p>TCP协议中有长连接和短连接之分。</p><p>众所周知，在网络通信中客户端与服务端建立TCP连接有三次握手和四次挥手，每个连接的建立都是需要资源消耗和时间消耗的</p><p>短连接是指通信双方一有数据交互，就建立一个TCP连接，数据发送完后，就断开此TCP连接；</p><p>长连接是指一次TCP连接后可以连续发送多个数据包，TCP保持期间，如果没有数据包发送，需要双方检测包以维持此链接：</p><p><strong>连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）</strong></p><hr><p>短连接环境下，数据交互完毕后，主动释放连接；</p><p>长连接的环境下，进行一次数据交互后，很长一段时间内无数据交互时，客户端可能意外断电、死机、崩溃、重启，还是中间路由网络无故断开，这些TCP连接并未来得及正常释放，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，且有可能导致在一个无效的数据链路层面发送业务数据，结果就是发送失败。所以服务器端要做到快速感知失败，减少无效链接操作，这就有了TCP的<strong>Keepalive</strong>（保活探测）机制。</p><h2 id="保活机制原理"><a href="#保活机制原理" class="headerlink" title="保活机制原理"></a>保活机制原理</h2><p>一端会启动一个计时器，当计时器到达0之后（达到tcp_keepalive_time），一个TCP探测包会被发出，这个探测包是一个纯ACK包（不应该包含任何数据），其seq号与上一个包是重复的</p><p>如果一个给定的连接在（默认）两个小时内没有任何动作，则服务器就发送一个探测报文段，检测客户主机的状态，有以下四种：</p><ol><li><p>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</p></li><li><p>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</p></li><li><p>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</p></li><li><p>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探测的响应。</p></li></ol><p>利用保活机制，当意外发生时，可以释放半打开的TCP连接</p><h2 id="保活机制可能导致的问题"><a href="#保活机制可能导致的问题" class="headerlink" title="保活机制可能导致的问题"></a>保活机制可能导致的问题</h2><p>Keepalive 技术只是 TCP 技术中的一个可选项。因为不当的配置可能会引起一些问题，所以默认是关闭的。</p><p>可能导致下列问题：</p><ol><li><p>在短暂的故障期间，Keepalive设置不合理时可能会因为短暂的网络波动而断开健康的TCP连接</p></li><li><p>需要消耗额外的宽带和流量</p></li><li><p>在以流量计费的互联网环境中增加了费用开销</p></li></ol><hr><p>参考：<a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">https://blog.csdn.net/skiof007/article/details/52873421</a></p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p><strong>1、WebSocket是什么？</strong></p><p>WebScoket是一种让客户端和服务器之间能进行<strong>双向</strong>实时通信的技术。它是HTML最新标准HTML5的一个协议规范，本质上是个基于TCP的协议，它通过HTTP/HTTPS协议发送一条特殊的请求进行握手后创建了一个TCP连接，此后浏览器/客户端和服务器之间便可以通过此连接来进行双向实时通信。</p><p><strong>2、为什么要用WebSocket？</strong></p><p>1）一直以来，HTTP协议是无状态、单向通信的，即客户端请求一次，服务器回复一次。如果想让服务器消息及时下发到客户端，需要采用类似于轮询的机制，即客户端定时频繁的向服务器发出请求，这样效率很低，而且HTTP数据包头本身的字节量较大，浪费了大量带宽和服务器资源；</p><p>2）为提高效率，出现了AJAX/Comet技术，它实现了双向通信且节省了一定带宽，但仍然需要发出请求，本质上仍然是轮询；</p><p>3）新一代HTML标准HTML5推出了WebSocket技术，它使客户端和服务器之间能通过HTTP协议建立TCP连接，之后便可以随时随地进行双向通信，且交换的数据包头信息量很小；</p><p><strong>3、如何使用WebSocket？</strong></p><p>在支持WebSocket的浏览器中，创建Socket之后，通过onopen、onmessage、onclose、onerror四个事件的实现来处理Socket的响应；</p><p><strong>4、WebSocket与HTTP、TCP的关系</strong></p><p>WebSocket和HTTP都属于应用层协议，且都是基于TCP的，它们的send函数最终也是通过TCP系统接口来做数据传输。那么WebSocket和HTTP的关系呢？WebSocket在建立握手连接时，数据是通过HTTP协议传输的，但是在连接建立后，真正的数据传输阶段则不需要HTTP协议的参与。它们之间的关系如下图：</p><p><img src="https://images2017.cnblogs.com/blog/1247371/201711/1247371-20171120120707258-353166864.gif" alt="img"></p><p><strong>5、什么情况下使用WebSocket？</strong></p><p>如果需要同时支持手机端、Web端，那毫无疑问应该使用WebSocket，现在各个平台都提供了相应的WebSocket实现。如果游戏不需要支持Web端，且对实时性要求比较高，那么使用TCP/UDP结合的原生Socket会比较好。</p><p><strong>6、SocketIO</strong></p><p>WebSocket是HTML5最新提出的规范，虽然主流浏览器都已经支持，但仍然可能有不兼容的情况，为了兼容所有浏览器，给程序员提供一致的编程体验，SocketIO将WebSocket、AJAX和其它的通信方式全部封装成了统一的通信接口，也就是说，我们在使用SocketIO时，不用担心兼容问题，底层会自动选用最佳的通信方式。因此说，WebSocket是SocketIO的一个子集。</p><p>参考：<a href="https://www.cnblogs.com/foupwang/p/7865694.html" target="_blank" rel="noopener">https://www.cnblogs.com/foupwang/p/7865694.html</a></p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><h2 id="WebSocket-1"><a href="#WebSocket-1" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebSocketServer:</p><p>因为WebSocket是类似客户端服务端的形式(采用ws协议)，那么这里的WebSocketServer其实就相当于一个ws协议的Controller<br>直接@ServerEndpoint(“/websocket”)@Component启用即可，然后在里面实现@OnOpen,@onClose,@onMessage等方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnClose;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnError;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnMessage;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnOpen;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.log.Log;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.log.LogFactory;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/websocket/&#123;sid&#125;"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Log log=LogFactory.get(WebSocketServer.class);</span><br><span class="line">    <span class="comment">//静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> onlineCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;WebSocketServer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收sid</span></span><br><span class="line">    <span class="keyword">private</span> String sid=<span class="string">""</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法*/</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session,@PathParam(<span class="string">"sid"</span>)</span> String sid) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        webSocketSet.add(<span class="keyword">this</span>);     <span class="comment">//加入set中</span></span><br><span class="line">        addOnlineCount();           <span class="comment">//在线数加1</span></span><br><span class="line">        log.info(<span class="string">"有新窗口开始监听:"</span>+sid+<span class="string">",当前在线人数为"</span> + getOnlineCount());</span><br><span class="line">        <span class="keyword">this</span>.sid=sid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">         sendMessage(<span class="string">"连接成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"websocket IO异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        webSocketSet.remove(<span class="keyword">this</span>);  <span class="comment">//从set中删除</span></span><br><span class="line">        subOnlineCount();           <span class="comment">//在线数减1</span></span><br><span class="line">        log.info(<span class="string">"有一连接关闭！当前在线人数为"</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息*/</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"收到来自窗口"</span>+sid+<span class="string">"的信息:"</span>+message);</span><br><span class="line">        <span class="comment">//群发消息</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketServer item : webSocketSet) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                item.sendMessage(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"发生错误"</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现服务器主动推送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 群发自定义消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String message,@PathParam(<span class="string">"sid"</span>)</span> String sid) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    log.info(<span class="string">"推送消息到窗口"</span>+sid+<span class="string">"，推送内容:"</span>+message);</span><br><span class="line">        <span class="keyword">for</span> (WebSocketServer item : webSocketSet) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里可以设定只推送给这个sid的，为null则全部推送</span></span><br><span class="line">            <span class="keyword">if</span>(sid==<span class="keyword">null</span>) &#123;</span><br><span class="line">            item.sendMessage(message);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.sid.equals(sid))&#123;</span><br><span class="line">            item.sendMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServer.onlineCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServer.onlineCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/moshowgame/article/details/80275084" target="_blank" rel="noopener">https://blog.csdn.net/moshowgame/article/details/80275084</a></p><h2 id="SocketIO"><a href="#SocketIO" class="headerlink" title="SocketIO"></a>SocketIO</h2><p>准确的说是netty-socketio，socketIO的java版，我会着重来讲一下它，先撸代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.corundumstudio.socketio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-socketio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.socket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>socket.io-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miao.socketio.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.corundumstudio.socketio.*;</span><br><span class="line"><span class="keyword">import</span> com.corundumstudio.socketio.listener.ConnectListener;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/9/10 15:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIOConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(SocketIOConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SocketIOServer <span class="title">initSocketIO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意是com.corundumstudio.socketio.Configuration</span></span><br><span class="line">        Configuration config = getConfiguration();</span><br><span class="line">        SocketIOServer server = <span class="keyword">new</span> SocketIOServer(config);</span><br><span class="line">        server.addConnectListener(client -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != client) &#123;</span><br><span class="line">                logger.info(<span class="string">"连接成功"</span>);</span><br><span class="line">                <span class="comment">// 可给客户端发送事件，参数为事件名及内容</span></span><br><span class="line">                client.sendEvent(<span class="string">"testEvent"</span>, JSONObject.toJSON(<span class="string">"balabala..."</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"没有连接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Configuration <span class="title">getConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可不填，默认是0.0.0.0</span></span><br><span class="line">        configuration.setHostname(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">// 端口号</span></span><br><span class="line">        configuration.setPort(<span class="number">8099</span>);</span><br><span class="line">        <span class="comment">// Ping消息超时时间（毫秒），默认60秒，这个时间间隔内没有接收到心跳消息就会发送超时事件</span></span><br><span class="line">        configuration.setPingTimeout(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// Ping消息间隔（毫秒），默认25秒。客户端向服务器发送一条心跳消息间隔</span></span><br><span class="line">        configuration.setPingInterval(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        configuration.setMaxFramePayloadLength(<span class="number">1024</span> *<span class="number">1024</span>);</span><br><span class="line">        configuration.setMaxHttpContentLength(<span class="number">1024</span> *<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一次握手时的监听器</span></span><br><span class="line"><span class="comment">//        configuration.setAuthorizationListener(data -&gt; true);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> configuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendEvent是我从前人老代码里看到的最多的一个用法，业务场景是从Netty长链里拿到的实时信息（不知道这样描述是否妥当，Netty之后要好好在学习学习），用发送事件的方式传给前端。</p><p>他SocketIOServer这的操作我认为有一些繁琐，他的做法是首先让客户端主动订阅事件，服务端用事件监听器取到client，并把SocketIOClient直接存在内存中的Set集合里，当有从另一个长链拿到消息时又给到每一个SocketIOClient去发event。之所以说这样繁琐是socketIO是一个<strong>天然的“聊天室”</strong>，当我拿到消息后我可以直接发送给某个房间内所有的client，主要讲怎么使用吧：</p><p>先要了解两个概念：</p><p><strong>Namespace</strong></p><p>套接字，客户端默认连接的namespace为<code>/</code>，服务端也默认监听<code>/</code>，但如果指定了namespace，则默认下发给/的信息就收不到了</p><p><strong>Rooms</strong></p><p>每个Namespace下都可以定义房间来供客户端加入与离开，如果没有指定会有一个默认的room，上面的例子里应该就是给默认的room里所有的client都发事件，一个client可以连不同的room，类似于一个账号能进很多个群。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以获取Namespace下所有的客户端</span></span><br><span class="line">server.getNamespace(<span class="string">"/"</span>).getAllClients();</span><br><span class="line"><span class="comment">// 可以给指定room里的客户端发事件</span></span><br><span class="line">server.getRoomOperations(<span class="string">"testRoom"</span>).sendEvent(<span class="string">"testRoomOne"</span>,</span><br><span class="line">                JSONObject.toJSON(<span class="string">"RoomOne...RoomOne...RoomOne..."</span>));</span><br><span class="line"><span class="comment">// 客户端加入指定的房间</span></span><br><span class="line">client.joinRoom(<span class="string">"testRoom"</span>);</span><br><span class="line"><span class="comment">// 离开</span></span><br><span class="line">client.leaveRoom(<span class="string">"testRoom"</span>);</span><br></pre></td></tr></table></figure><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>写到最后忘记总结这俩的区别了，基于谷歌和百度的小码农找了一个精炼又赞的答案：</p><p>websocket是一种长连接协议，用nodejs实现了这个ws协议的库也叫websocket，github搜索一下就有。socket.io也是实现了ws协议的库，不过它支持的更多，不仅实现了ws协议，也支持长轮询等方式，兼容flash，IE6等不支持ws协议的浏览器。</p><p>——v站  <strong>halfblood</strong>的回答 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补习&quot;&gt;&lt;a href=&quot;#补习&quot; class=&quot;headerlink&quot; title=&quot;补习&quot;&gt;&lt;/a&gt;补习&lt;/h1&gt;&lt;p&gt;先来补习几个月的前某天整理的一些TCP方面的知识&lt;/p&gt;
&lt;h2 id=&quot;长连接与短连接&quot;&gt;&lt;a href=&quot;#长连接与短连接&quot; class
      
    
    </summary>
    
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题详解</title>
    <link href="http://yoursite.com/2019/09/01/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/01/跨域问题详解/</id>
    <published>2019-09-01T03:14:56.000Z</published>
    <updated>2019-09-18T02:39:18.724Z</updated>
    
    <content type="html"><![CDATA[<p>一直都没有时间捣鼓博客，发现自己的描述和总结的习惯都没有了，换新电脑有三个月了，觉得这段时间过得很快，事实上我不更博客都不止三个月了，换电脑是一个原因，其他理由就是毕业季，转正，同事的离职，两个版本的老项目快速迭代，的的确确没有太多时间给自己总结，说白了就是没有时间摸鱼了，晚上有时还要加班，周末都用来睡觉和打游戏虚度，老电脑也不在身边，总之感觉自己过得浑浑噩噩，一边补洞一边自己写出新的烂代码来。对了，另一个不更的原因是CTO成天坐旁边，不明白为啥他总不爱坐自己的办公室😥（好在在写这篇文章的时候他已经换了一个位置坐）</p><p>接下来会列一些这么长时间里遇到的比较经典的问题，由于上班节奏变快了，有些忘了记录下来，但之后的日子我还是会继续恢复以前的习惯，常总结，今天梳理一下工作中遇到n次的跨域问题！</p><p>第一次遇到跨域还是在去年冬天刚实习的时候，前端大佬说他那调我的http接口报403，捣鼓半天问了组里的大哥找到项目里有应对跨域问题的拦截器，最后问题原因出在前端大佬把访问的路径写岔了，跨域问题也就不了了之。</p><h1 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h1><blockquote><p> 在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于JavaScript代码能够访问的页面内容做了很重要的限制，即JavaScript只能访问与包含它的文档在同一域下的内容。</p><p>JavaScript这个安全策略在进行多iframe或多窗口编程、以及Ajax编程时显得尤为重要。根据这个策略，在baidu.com下的页面中包含的JavaScript代码，不能访问在google.com域名下的页面内容；甚至不同的子域名之间的页面也不能通过JavaScript代码互相访问。对于Ajax的影响在于，通过XMLHttpRequest实现的Ajax请求，不能向不同的域提交请求，例如，在abc.example.com下的页面，不能向def.example.com提交Ajax请求，等等。</p></blockquote><p>以上来自<a href="https://www.cnblogs.com/smiler/p/5829621.html" target="_blank" rel="noopener">https://www.cnblogs.com/smiler/p/5829621.html</a></p><p>所谓同源是指，域名，协议，端口相同。当页面在执行一个脚本时会检查访问的资源是否同源，如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。</p><p>这个问题表现上来说与后端并没有什么关系，浏览器并不能在同一个js请求不同域名的接口，否则就会跨域，所以大多数接口需要后端转发，变成同一个域名和端口才能给前端请求，但有的时候明明是同一个项目甚至同一个Controller下的接口也会出现跨域问题，这就不知道前端大佬们到底是如何请求的了，可能是都写在了一块吧。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>最常用的解决方法是CORS，者是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing)，定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，但比起简单地允许所有这些的要求来说更加安全。</p><p>目前我了解到的有两种实现方法，一是加处理响应头的过滤器或拦截器，二是SpringMVC的一个注解@CrossOrigin，第二种方法比较偷懒，我们先来介绍这种偷懒的方法。</p><h2 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h2><p>在Controller中的方法上添加一个@CrossOrigin注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line">   <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> JSONObject <span class="title">abababa</span><span class="params">(@RequestParam String id)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>有2个参数：</p><p><strong>origins</strong>  ： 允许可访问的域列表</p><p><strong>maxAge</strong>：准备响应前的缓存持续的最大时间（以秒为单位）。</p><p>还可以加上CORS的设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span>(allowCredentials = <span class="string">"true"</span>, allowedHeaders = <span class="string">"*"</span>)</span><br></pre></td></tr></table></figure><p>这虽然是一个非常简单的处理方法，但有的时候加了还是没有用，看网上有许多分析问题原因究竟出在哪里的帖子，有时要加上CORS配置才生效，有时要制定@RequestMapping是POST还是GET，有时加了这些都没用，把注解搬到类上也没用，感觉有的时候不应该一概而论的解决，要看浏览器究竟报了什么错，根据错误来判断究竟要加什么头或条件，我比较喜欢用土方法，写个过滤器，</p><h2 id="Filter-CORS"><a href="#Filter-CORS" class="headerlink" title="Filter + CORS"></a>Filter + CORS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CROSFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"GET,POST,OPTIONS,HEAD"</span>);</span><br><span class="line"><span class="comment">//        response.setHeader("Access-Control-Allow-Headers", "epid,version,web_platform");</span></span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, request.getHeader(<span class="string">"Access-Control-Request-Headers"</span>));</span><br><span class="line"></span><br><span class="line">        chain.doFilter(req, res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是由于出现了Access-Control-Allow-Headers缺省导致的错误，所以一开始我加了浏览器报错上提示的请求头，”epid,version,web_platform”是某个项目里需要的请求头，缺省就报405，与前端大佬沟通后发现他们请求的时候头就会带这些东西，于是后来遇到类似情况，要改Access-Control-Allow-Headers，我都会优先从请求头里取。</p><p>这里再解释一下其他几个CORS相关的参数：</p><p><strong>（1）Access-Control-Allow-Origin</strong></p><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p><p>这个参数的缺省带来的报错非常常见，通常写成*就行，但也遇到写了也没用的情况，那么要具体问题具体分析，看到底缺了什么</p><p><strong>（2）Access-Control-Allow-Credentials</strong></p><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p><strong>（3）Access-Control-Expose-Headers</strong></p><p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p><p><strong>（4）Access-Control-Allow-Methods</strong></p><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p><p>前端大佬表示他们在请求时通常都会预检，发一个OPTIONS请求，所以在上面的例子中我也加了这个</p><p><strong>（5）Access-Control-Allow-Headers</strong></p><p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p><p><strong>（6）Access-Control-Allow-Credentials</strong></p><p>该字段与简单请求时的含义相同。</p><p><strong>（7）Access-Control-Max-Age</strong></p><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p><p>总之，要与前端大佬沟通好是缺省什么，哪个参数报的错，一般他们请求过来什么，我们给他们加什么就行，切忌所有请求一概而论的胡乱加*，当然也许@CrossOrigin也可以达到一样的效果，只是由于我比较笨拙喜欢复杂的写法</p><h2 id="WebMvcConfigurer-SpringBoot"><a href="#WebMvcConfigurer-SpringBoot" class="headerlink" title="WebMvcConfigurer(SpringBoot)"></a>WebMvcConfigurer(SpringBoot)</h2><p>另外，如果你用的是一个SpringBoot项目，不妨试试<strong>WebMvcConfigurer</strong>，（SpringBoot2.x版本为<strong>WebMvcConfigurerAdapter</strong> ）</p><p>建一个Configuration实现WebMvcConfigurer ，老的WebMvcConfigurerAdapter有解决跨域的方法，十分强大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 解决跨域问题 **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>;</span><br><span class="line"><span class="comment">/** 添加拦截器 **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 这里配置视图解析器 **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 配置内容裁决的一些选项 **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span></span>;</span><br><span class="line"><span class="comment">/** 视图跳转控制器 **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 静态资源处理 **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 默认静态资源处理器 **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span></span>;</span><br></pre></td></tr></table></figure><p>例如你可以这样解决跨域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"POST"</span>, <span class="string">"GET"</span>, <span class="string">"PUT"</span>, <span class="string">"OPTIONS"</span>, <span class="string">"DELETE"</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">"Content-Type"</span>, <span class="string">"X-Requested-With"</span>, <span class="string">"accept"</span>, <span class="string">"Origin"</span>, <span class="string">"Access-Control-Request-Method"</span>,</span><br><span class="line">                        <span class="string">"Access-Control-Request-Headers"</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高版本的SpringBoot可以这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfigure</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直都没有时间捣鼓博客，发现自己的描述和总结的习惯都没有了，换新电脑有三个月了，觉得这段时间过得很快，事实上我不更博客都不止三个月了，换电脑是一个原因，其他理由就是毕业季，转正，同事的离职，两个版本的老项目快速迭代，的的确确没有太多时间给自己总结，说白了就是没有时间摸鱼了，
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>深入了解ConcurrentHashMap</title>
    <link href="http://yoursite.com/2019/03/31/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3ConcurrentHashMap/"/>
    <id>http://yoursite.com/2019/03/31/深入了解ConcurrentHashMap/</id>
    <published>2019-03-31T09:59:08.000Z</published>
    <updated>2019-03-31T10:04:21.907Z</updated>
    
    <content type="html"><![CDATA[<p>转眼三月了 又到了樱花飘落的季节？昨天高中舍友翻出了当年小纸条拍给我看 没想到我还有那样疯狂杀马特的年纪啊</p><p>很多东西都变了 不变的是我的文笔和字还是这么烂 很多事都是第一次接触 给人一种很不真实的感觉 不再有人告诉你该怎么做 该好好学数学 学英语 做题 锻炼 吃有营养的食物… 连现在坐在这做对着电脑码bug 都给人一种很不可思议的感觉</p><p>这些都是一些废话 随口一说 今天有时间划水 想把上个礼拜看到的一个东东摸清楚——ConcurrentHashMap 说来惭愧 我之前似乎从来没见过这个类 第一眼看到百度了一下有了个大概的概念是用于并发的HashMap 天呐<strong>并发</strong>这块我真的是一点都不懂 持续利用搜索引擎打开新篇章(σﾟ∀ﾟ)σ…不 这回get了一个新技能 Ctrl Shift Alt + U 查看包 这图画的也太清晰了 可以说是相当方便了</p><p>Java提供了并发包java.util.concurrent 在用ConcurrentHashMap时可以看到引入的时候是<figure class="highlight plain"><figcaption><span>java.util.concurrent.ConcurrentHashMap; ```首先回顾一下它的祖辈 集合 顺便系统的复习一下吧</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;img src=&quot;深入了解ConcurrentHashMap/1.png&quot;&gt;</span><br><span class="line"></span><br><span class="line">util.Collection的三个直系子接口：Set，List，Queue</span><br><span class="line">Set为数字意义上的集合 没有重复项  List则为允许重复项的有序集合 Queue 接触的不多 队列 先进先出 主要是它的一个数据结构 这些直系子接口下能与支持并发挂上钩的 只有Vector（Vetor是个同步容器类）</span><br><span class="line"></span><br><span class="line">&gt; 题外话：为什么Vector我们总是不用呢？明明他是安全的 而且读取得也很快</span><br><span class="line">&gt; 是的 他安全，所以效率低 类似于StringBuffer 她和ArrayList是亲姐妹 但修改操作的效率却远低于ArrayList</span><br><span class="line">&gt; 另外分配内存时需要连续的存储空间 </span><br><span class="line">&gt; ArrayList的增长量默认0.5倍 而Vector是一倍</span><br><span class="line">&gt; 总得来说是个比较死板的List 也难怪大家都不爱用她了</span><br><span class="line"></span><br><span class="line">在这之前的推荐的线程安全的实现方式有Collections.synchronizedMap 和HashTable （但HashTable效率也比较低）今天的主角所在的concurrent包说来应该是个混血 虽然祖辈和集合有点联系 但它的结构来自于HashMap 父亲ConcurrentMap是从JDK5开始增加的线程安全的Map接口 </span><br><span class="line"></span><br><span class="line">**1.8之前**</span><br><span class="line"></span><br><span class="line">## 结构</span><br><span class="line"></span><br><span class="line">一个ConcurrentHashMap由一个个Segment组成 可以理解为一个Segment数组 Segment通过继承ReentrantLock 来实现加锁 每次锁住的是一个segment</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 2249069246763182397L;</span><br><span class="line">        final float loadFactor;</span><br><span class="line">        Segment(float lf) &#123; this.loadFactor = lf; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>concurrencyLevel</strong> 并发数目 即Segment个数 默认为16个 一旦初始化不能扩容 在一个三入参的构造方法里可以初始化这个值  注意，Java 需要它是 2 的幂次方，如果输入是类似 15则会自动调整到临近的2的幂次方 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>initialCapacity</strong> 初始容量 会平均分给每个Segment</p><p><strong>loadFactor</strong> 负载系数 这个我们稍后详细看看是什么来的</p><p>从他的结构就可以看出与HashTable相比 做并发操作时有了更多选择 因为HashTable只是竞争同一把锁 而ConcurrentHashMap默认会有十六个选择 这就是分离锁的作用 当一个线程访问其中一段数据的时候 其他段的数据也能被其他线程访问</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>这要首先讲讲HashMap的机制</p><p><img src="https://static001.geekbang.org/resource/image/1f/56/1f72306a9d8719c66790b56ef7977c56.png"></p><p>一个HashMap可以看做是key-value数组 但数组内部的形式上是链表组合的结构 通过计算哈希值决定了寻址 当得到一个地址并进入插入时 若发现这块存储地址已经被其他元素占用 就会找一块未被占用的存储地址 用链表的方式跟在后面</p><blockquote><p>在这解释为什么刚才说ConcurrentHashMap的concurrencyLevel会是2的幂次方 这和HashMap的数组初始化长度如出一辙  因为这样可以更好地减少key之间的碰撞  key经过计算之后获取的哈希值在寻址之前要与数组长度2^n-1做与运算（比如16长度则与1110做与运算） 若不满2^n位则有较大几率产生相同结果 比如哈希值为8（1000）和9（1001）与1110与运算结果相同 这就产生了碰撞 这会导致哈希值为9的这块地址无法存放元素 产生了浪费 也减慢了查询的效率</p></blockquote><p>初始的数组（也叫作桶bucket）+ 链表 组成了HashMap</p><p>当一个HashMap中元素越来越多，碰撞的几率也越来越高，就要对初始数组进行扩容 也就是resize操作 初始容量<strong>initialCapacity</strong>与负载因子<strong>loadFactor</strong>决定了它何时扩容 </p><p>初始时 initialCapacity = 0 当要塞元素时 执行resize 初始容量设置为 threshold 16</p><p>继续塞 当元素数量超过 initialCapacity <em> loadFactory = 16 </em> 0.75 = 12 时 执行resize 容量 -&gt; threshold = 2*16 = 32</p><p>当容量算出来之后会初始化一个新的长度的桶数组 将键值对重新映射到新的桶数组中</p><p>以上就是作为一个普通的HashMap所遇到的扩容问题 <strong>那么ConcurrentHashMap是如何操作扩容的呢？</strong> 不是整体扩容 而是对每个segment扩容 为了支持多线程 ConcurrentHashMap有个 <strong>sizeCtl</strong> 字段会在未初始化、初始化中和扩容中用不同的数字表示状态</p><p><strong>1.8之后</strong></p><p>JDK8后的ConcurrentHashMap可以说是脱胎换骨 但在了解变化之前要先来看看HashMap在1.8之后做了什么</p><p>HashMap 从原先的 <strong>数组 + 链表</strong> 变为 <strong>数组 + 链表 + 红黑树</strong> 当链表根的长度超过8时会转化为树  (๑Ő௰Ő๑)真是做梦都没想到我还能看到红黑树这么深奥的东东了？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若添加元素为8时会转化为树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若添加元素小于6时会从树转化为链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000012926727?w=1598&h=752"></p><p>参考原文：<a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/" target="_blank" rel="noopener">http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/</a></p><p>真是庆幸自己能看到这篇文章 大神讲解的十分详细 连图都是这么优美 相比我自己写的实在是太垃圾了 (((;꒪ꈊ꒪;)))另外关于红黑树大神也有一篇博客 真的强推！ 今天把这个放一下等周末有大把时间再来琢磨</p><p>回到主题ConcurrentHashMap在JDK1.8之后也沿袭了HashMap的结构 抛弃了Segment（但如今还是能在源码中看到Segment是为了保证序列化时的兼容 实际上已没有用处）初始化简化为懒加载 使用CAS</p><blockquote><p>说到懒加载 上一篇博客讲的单例就是非懒加载</p><p>懒加载：对象使用的时候才去创建。节省资源,但是不利于提前发现错误<br>非懒加载：容器启动时立马创建。消耗资源,有利于提前发现错误</p><p>错误非常关键，所以一般来说都用非懒加载的方式</p></blockquote><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>参考原文：<a href="https://blog.csdn.net/weixin_42636552/article/details/82383272" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42636552/article/details/82383272</a></p><p>CAS:Compare and Swap 意为比价交换 java.util.concurrent包中接住CAS实现了区别于synchronouse的一种乐观锁</p><p><strong>无锁的概念</strong></p><p>在谈论无锁概念时，总会关联起乐观派与悲观派，对于乐观派而言，他们认为事情总会往好的方向发展，总是认为坏的情况发生的概率特别小，可以无所顾忌地做事，但对于悲观派而已，他们总会认为发展事态如果不及时控制，以后就无法挽回了，即使无法挽回的局面几乎不可能发生。<br>这两种派系映射到并发编程中就如同加锁与无锁的策略，即加锁是一种悲观策略，无锁是一种乐观策略，因为对于加锁的并发程序来说，它们总是认为每次访问共享资源时总会发生冲突，因此必须对每一次数据操作实施加锁策略。<br>而无锁则总是假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，无锁策略则采用一种称为CAS的技术来保证线程执行的安全性，这项CAS技术就是无锁策略实现的关键，下面我们进一步了解CAS技术的奇妙之处。</p><p>CAS有三个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * V 需要更新的变量</span></span><br><span class="line"><span class="comment"> * E 预期值</span></span><br><span class="line"><span class="comment"> * N 新值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CAS(V, E, N)</span><br></pre></td></tr></table></figure><p>如果V == E，则将V设置为N。若V != E 这说明已经有其他线程做了更新，则当前线程什么都不做</p><p>由于CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作，这点从图中也可以看出来。基于这样的原理，CAS操作即使没有锁，同样知道其他线程对共享资源操作影响，并执行相应的处理措施。<strong>同时从这点也可以看出，由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说无锁操作天生免疫死锁。</strong></p><p>另外会不会发生这边写着V那边读的情况呢？是有可能的 但因为CAS是原语 （这一点将Compare and Swap放到有道词典里一搜就能知道）故不会产生不一致的问题</p><p>在没有锁的机制下，需要借助volatile原语来保证线程间的数据是可见 共享的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">//利用volatile为val和next设置同步锁 导致只有在获取变量的时候才能直接读取</span></span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 初始化tab也是一个cas操作</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 利用CAS 进行无锁线程操作 判断bin是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//对Node加悲观锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                <span class="comment">//链表操作</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            <span class="comment">//如果是树要采取红黑树的方法安排数据</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        <span class="comment">// 数目超过阈值 进行树化</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 还记得这个sizeCtl吗？ 小于0表示已经扩容 大于0表示还没扩容</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 这个翻译说是进入自旋状态 自旋锁 36讲有章节讲 之后再开一话</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//若CAS返回true 则做下面的操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用了前后三天时间写了这个博客 感觉越深入越感觉自己不会的有很多 在这之前我可能连HashMap的结构都不清楚 现在还遗留了很多未打开的话题 比如volatile 自旋锁与偏向锁 红黑树等等 开这篇博客的原因是从公司大哥代码里看到的 是从zookeeper中拿的数据放在了ConcurrentHashMap中 一边这边刷新数据赋值的同时当前系统可能有并发的读取 所以用了高效的ConcurrentHashMap </p><p>但要真的理解和掌握肯定不是这么粗粗地看一眼就学会的 手边有Java并发编程和Java36讲 在36讲刚出来的时候订阅却看不懂什么 现在居然也可以跟着慢慢磨懂了 还是挺开心的 另外我的写作水平有待加强 废话有点多 不够清晰 不加标点符号成了习惯看上去也有点费劲 我会慢慢改正的！有什么意见和建议欢迎留言呀！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转眼三月了 又到了樱花飘落的季节？昨天高中舍友翻出了当年小纸条拍给我看 没想到我还有那样疯狂杀马特的年纪啊&lt;/p&gt;
&lt;p&gt;很多东西都变了 不变的是我的文笔和字还是这么烂 很多事都是第一次接触 给人一种很不真实的感觉 不再有人告诉你该怎么做 该好好学数学 学英语 做题 锻炼 
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>记bug簿（长期更新）</title>
    <link href="http://yoursite.com/2019/03/03/%E8%AE%B0bug%E7%B0%BF%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/03/记bug簿（长期更新）/</id>
    <published>2019-03-03T02:30:57.000Z</published>
    <updated>2019-09-18T09:21:13.017Z</updated>
    
    <content type="html"><![CDATA[<p>开这篇的起因是因为工作中真的遇到了很多大大小小的问题，平时有空我都会记录下来，但由于又不是很重要或者很难的东西，（一切都源于我菜才会有这些问题），不想为这些分别立一篇，但还是有记录的价值的！（记录了自己成长哈哈哈）</p><p>我会按照内容来做标题，也会按照时间倒序，这篇的开始为19/2/13，所以一些小问题以后就不会立一篇博客了，只有当我觉得很重要的东西才会不放在这里面。</p><p>当然，每一个bug解决不可能完全不依赖谷歌百度，我会记录原文地址。</p><h2 id="部署jar包"><a href="#部署jar包" class="headerlink" title="部署jar包"></a>部署jar包</h2><p>nohup java -jar XXX.jar</p><h2 id="启动疯狂报Error-creating-bean"><a href="#启动疯狂报Error-creating-bean" class="headerlink" title="启动疯狂报Error creating bean"></a>启动疯狂报Error creating bean</h2><p>前一段时间拿到前人的代码之后,有个特别坑的地方就是在服务器上跑起来的时候出现疯狂报错,排查了很久最后还是其他大佬帮忙照出了问题,先放个当时的报错:</p><p>循环报许多类的error creating bean ,而真正的问题出在<code>java.util.ConcurrentModificationException</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">2019-07-01 11:19:27,870 [nioEventLoopGroup-5-1] WARN  [io.netty.channel.AbstractChannelHandlerContext] - An exception &apos;java.util.ConcurrentModificationException&apos; [enable DEBUG level for full stacktrace] was thrown by a user handler&apos;s exceptionCaught() method while handling the following exception:</span><br><span class="line">org.springframework.beans.factory.BeanCreationNotAllowedException: Error creating bean with name &apos;tcpClientHandler&apos;: Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)</span><br><span class="line">   at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:208)</span><br><span class="line">   at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318)</span><br><span class="line">   at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)</span><br><span class="line">   at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:273)</span><br><span class="line">   at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1239)</span><br><span class="line">   at org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver$1.getTarget(ContextAnnotationAutowireCandidateResolver.java:90)</span><br><span class="line">   at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:672)</span><br><span class="line">   at com.gkoudai.officialnetwork.netty.TcpClientHandler$$EnhancerBySpringCGLIB$$76b97b7b.channelRead(&lt;generated&gt;)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)</span><br><span class="line">   at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)</span><br><span class="line">   at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:310)</span><br><span class="line">   at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:297)</span><br><span class="line">   at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:413)</span><br><span class="line">   at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)</span><br><span class="line">   at io.netty.handler.timeout.IdleStateHandler.channelRead(IdleStateHandler.java:286)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)</span><br><span class="line">   at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)</span><br><span class="line">   at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)</span><br><span class="line">   at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)</span><br><span class="line">   at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)</span><br><span class="line">   at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:628)</span><br><span class="line">   at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:563)</span><br><span class="line">   at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:480)</span><br><span class="line">   at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:442)</span><br><span class="line">   at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)</span><br><span class="line">   at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">   at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>问题出在多线程中对同一个list用了迭代器并进行了修改长度的操作，要合理使用线程池以及对集合的使用</p><h2 id="Mybatis如何设置联合主键（多主键）"><a href="#Mybatis如何设置联合主键（多主键）" class="headerlink" title="Mybatis如何设置联合主键（多主键）"></a>Mybatis如何设置联合主键（多主键）</h2><p>由于Mybatis查询会根据结果集中的id进行unique过滤，而id又只能设置一个，会导致多主键情况下sql结果与真实的Mybatis结果不符，在Mybatis中多主键就把它当作没主键就行</p><h2 id="Mysql-error-code-1366"><a href="#Mysql-error-code-1366" class="headerlink" title="Mysql error code 1366"></a>Mysql error code 1366</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### Error updating database.  Cause: java.sql.SQLException: Incorrect string value: &apos;\xE6\x9D\xA5\xE8\x87\xAA...&apos; for column &apos;content&apos; at row 1</span><br><span class="line">### The error may involve com.gkoudai.futureManage.Mapper.RedMsgMapper.insertSelective-Inline</span><br><span class="line">### The error occurred while setting parameters</span><br><span class="line">### SQL: insert into tb_exchange_notice      ( id,                       title,                       content,                       sort,                                     url,                                                   icon,                              old_id,                       exchange_name,                       is_show )       values ( ?,                       ?,                       ?,                       ?,                                     ?,                                                   ?,                              ?,                       ?,                       ? )</span><br><span class="line">### Cause: java.sql.SQLException: Incorrect string value: &apos;\xE6\x9D\xA5\xE8\x87\xAA...&apos; for column &apos;content&apos; at row 1</span><br><span class="line">; uncategorized SQLException; SQL state [HY000]; error code [1366]; Incorrect string value: &apos;\xE6\x9D\xA5\xE8\x87\xAA...&apos; for column &apos;content&apos; at row 1</span><br></pre></td></tr></table></figure><p>这里content设为text格式，字符编码应为utf-8，默认是latin不支持中文，会报1366错</p><h2 id="Mybatis-OrderBy问题"><a href="#Mybatis-OrderBy问题" class="headerlink" title="Mybatis OrderBy问题"></a>Mybatis OrderBy问题</h2><p>多条件排序</p><p>example.setOrderByClauser(“timestamp DESC, name ASC”);</p><h2 id="如何将一个bean的属性赋给另一个bean"><a href="#如何将一个bean的属性赋给另一个bean" class="headerlink" title="如何将一个bean的属性赋给另一个bean"></a>如何将一个bean的属性赋给另一个bean</h2><p>两个类的属性不一定全部相同，但希望相同的属性中能映射过去。</p><p>Spring的BeanUtils.copyProperties()方法</p><h2 id="如何判断一个元素在数组中"><a href="#如何判断一个元素在数组中" class="headerlink" title="如何判断一个元素在数组中"></a>如何判断一个元素在数组中</h2><p>indexOf()若大于零则存在</p><h2 id="IDEA中WebApplication-Exploded与Archive区别"><a href="#IDEA中WebApplication-Exploded与Archive区别" class="headerlink" title="IDEA中WebApplication:Exploded与Archive区别"></a>IDEA中WebApplication:Exploded与Archive区别</h2><p>原文：<a href="https://blog.csdn.net/ydk888888/article/details/77247725" target="_blank" rel="noopener">https://blog.csdn.net/ydk888888/article/details/77247725 </a></p><p>对这个问题的疑惑是当时有个同事交接给我项目时，用IDEA跑普通maven项目起不来，于是以为是artifacts配置的问题，设置的地方在IDEA右上角有个蓝色俄罗斯方块的文件夹-Project Settings-Artifacts，就产生了疑惑，WebApplication:Exploded和WebApplication:Archive有啥区别？</p><p><img src="/2019/03/03/记bug簿（长期更新）/111.png"></p><p>直接引用原博客的话：</p><p>选项中有web application exploded，这个是以文件夹形式（War Exploded）发布项目，选择这个，发布项目时就会自动生成文件夹在指定的output directory,</p><p>如果选web application archive，就是war包形式，每次都会重新打包全部的,将项目打成一个war包在指定位置；</p><h2 id="git-Warning-detached-HEAD"><a href="#git-Warning-detached-HEAD" class="headerlink" title="git Warning detached HEAD"></a>git Warning detached HEAD</h2><p>原文：<a href="https://www.jianshu.com/p/ae4857d2f868" target="_blank" rel="noopener">https://www.jianshu.com/p/ae4857d2f868</a></p><p>提交代码的时候遇到了Warning，没有贴原句，就拿这个原文中的复制过来，是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Warning: you are leaving 1 commit behind, not connected to</span><br><span class="line">any of your branches:</span><br><span class="line"></span><br><span class="line">  fef4501 interrationRecord page completed</span><br><span class="line"></span><br><span class="line">If you want to keep them by creating a new branch, this may be a good time</span><br><span class="line">to do so with:</span><br><span class="line"></span><br><span class="line"> git branch &lt;new-branch-name&gt; fef4501</span><br></pre></td></tr></table></figure><p>原本应该上传到master分支，但commit时出现了这个Warning导致没有成功，当时也没来得及看这段话，只看到git提交记录中自己的那个分支上右侧tag显示了一个黄色的感叹号，且无法push，当时急忙着checkout了版本库里的master分支看发现果然没有自己commit的那条，返回本地分支回去发现自己辛辛苦苦写了两天的代码就没了，突然愣住，找了其他大佬说应该是找不回来了，于是回去翻看到这个warning，找到这篇简书。</p><p>按照步骤第一步输入,xxxx就是这个Warning里的版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git branch temp xxxx</span><br></pre></td></tr></table></figure><p>第二步切换工作分支并合并代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge temp</span><br></pre></td></tr></table></figure><p>最后删除temp分支</p><p>但是！我发现自己创的temp分支根本和这篇里的不一样，我只是创了一个temp 但并没有我原来的那个代码，以为这个方法也凉凉，但还是坚信代码能找回来！毕竟commit过，怎么会丢呢？</p><p>首先我们分析一下这个Warning，git把我们新的提交已经创好了一个版本号，但是实际上这个版本没有完全成功因为他说没有提交到任一分支，（奇怪我坚信自己肯定是选了，和平时操作一样），但这个编号为xxxx的commit实际上是肯定存在某个地方的，git也建议我们使用temp分支来解决这个问题，所以解决思路应该没问题</p><p>最后意识到自己在遇到这个Warning后又自己checkout了master分支又切回来多次，所以当下的git状态可能没有之前我commit的这条xxxx，所以创建temp分支会有语法错误，于是git log找到当时我提交的那个head 版本号，再reset回去，保险起见我在IDEA里右击-git-reset里退回（防止我自己敲错）然后再按照上面的步骤重新合并，成功！</p><p>花了差不多半个小时挽回了自己两天的代码…</p><h2 id="sublist"><a href="#sublist" class="headerlink" title="sublist()"></a>sublist()</h2><p>List中有个sublist方法的小标为左闭右开</p><h2 id="git-无法重输密码的问题"><a href="#git-无法重输密码的问题" class="headerlink" title="git 无法重输密码的问题"></a>git 无法重输密码的问题</h2><p>公司内网gitlab代码down不下来，因为一段时间没用gitlab，可能第一次输密码的时候错了，导致怎么都拉不下来代码，想重新输入又没有跳出来弹框，在外面用命令直接输出现Authentication failed。于是按照<a href="https://blog.csdn.net/qq_40028324/article/details/80883010" target="_blank" rel="noopener">https://blog.csdn.net/qq_40028324/article/details/80883010</a>将密码清空之后再输一次就成功了。</p><h2 id="log占位符"><a href="#log占位符" class="headerlink" title="log占位符"></a>log占位符</h2><p>研究大佬们代码发现他们log放参数的方法没有见过，是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&quot;xxxxxx:&#123;&#125;&quot;,obj.getXXX());</span><br></pre></td></tr></table></figure><p>这种大括号的占位符方式是log特有的，非常方便，多参数还可以加上序号区分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.log(Level.INFO,&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;&quot;,new Object[]&#123;&quot;刘利新&quot;,System.getProperty(&quot;line.separator&quot;),&quot;西安&quot;&#125;);</span><br></pre></td></tr></table></figure><p>来自<a href="https://blog.csdn.net/weiyanghuadi/article/details/9271447" target="_blank" rel="noopener">https://blog.csdn.net/weiyanghuadi/article/details/9271447</a></p><h2 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h2><p>Ctrl+Shift+Backspace，跳转到上次编辑的地方</p><p>F2 或 Shift+F2，高亮错误或警告快速定位</p><p>Alt+Shift+Up/Down，上/下移一行</p><h2 id="String-Date和Timestamp转化"><a href="#String-Date和Timestamp转化" class="headerlink" title="String Date和Timestamp转化"></a>String Date和Timestamp转化</h2><p>因为原文真的太详细了，实在不忍心复制黏贴下来，请查阅原文：<a href="https://www.cnblogs.com/qima/p/3652566.html" target="_blank" rel="noopener">https://www.cnblogs.com/qima/p/3652566.html</a></p><p>另外timestamp的单位为秒或毫秒</p><h2 id="数据库datetime类型的set方法"><a href="#数据库datetime类型的set方法" class="headerlink" title="数据库datetime类型的set方法"></a>数据库datetime类型的set方法</h2><p>datetime类型在java中导入用setTimestamp()方法</p><h2 id="util-Date与sql-Date转化"><a href="#util-Date与sql-Date转化" class="headerlink" title="util.Date与sql.Date转化"></a>util.Date与sql.Date转化</h2><p>数据库中拿到的Date是sql包的，赋给util.Date时会报错,转换方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlDate = new Timestamp(utilDate.getTime());</span><br><span class="line">utilDate = new Date(sqlDate.getTime());</span><br></pre></td></tr></table></figure><p>同时，两者均可被SimpleDateFormat格式化</p><h2 id="设置Date时间"><a href="#设置Date时间" class="headerlink" title="设置Date时间"></a>设置Date时间</h2><p>这边是设置Date时分秒为0的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date tradeDay = candleStick.getTradeDay();</span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.setTime(tradeDay);</span><br><span class="line">calendar.set(Calendar.HOUR,0);</span><br><span class="line">calendar.set(Calendar.MINUTE,0);</span><br><span class="line">calendar.set(Calendar.SECOND,0);</span><br></pre></td></tr></table></figure><h2 id="List与ArrayList的区别"><a href="#List与ArrayList的区别" class="headerlink" title="List与ArrayList的区别"></a>List与ArrayList的区别</h2><p><a href="https://www.cnblogs.com/zcscnn/p/7743507.html" target="_blank" rel="noopener">https://www.cnblogs.com/zcscnn/p/7743507.html</a></p><p>这些基础知识有些忘了，今天看代码时突然不明白为什么通常使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList()</span><br></pre></td></tr></table></figure><p>找到这篇博客复习了集合，ArrayList是List的实现类，而作为接口List的扩展性是很好的</p><h2 id="java8中stream，filter遍历代替for"><a href="#java8中stream，filter遍历代替for" class="headerlink" title="java8中stream，filter遍历代替for"></a>java8中stream，filter遍历代替for</h2><p>今天看代码又发现一处没见过的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;QuotesConfigTimeSubsection&gt; subsectionList = tradeTime.stream()</span><br><span class="line">        .filter(info -&gt; info.getStartMonth() &lt;= month &amp;&amp; info.getEndMonth() &gt;= month)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>了解了这种新特性的写法，看上去的确比for来的清爽的多</p><p>stream().filter可过滤一个满足某条件的集合并赋值，</p><p>stream().map可直接遍历一整个集合并赋值</p><p>另外还有filtermap还没用过</p><p>#######################分割线########################</p><p>今天来操练一下流式写法👨‍💻</p><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; expression;</span><br></pre></td></tr></table></figure><p>左侧为参数，如果不需要参数也可以为空，右侧是lambda代码块；如果只有一个返回时不需要特别声明，但若有条件分支的情况下需要视情况return；后面是表达式，或者一个代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(params) -&gt; expression</span><br><span class="line">(params) -&gt; statement</span><br><span class="line">(params) -&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><p>如果对参数不需要进行修改的话就是简单的匿名内部类，比如监听事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 8之前：</span></span><br><span class="line">JButton show =  <span class="keyword">new</span> JButton(<span class="string">"Show"</span>);</span><br><span class="line">show.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Event handling without lambda expression is boring"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8方式：</span></span><br><span class="line">show.addActionListener((e) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Light, Camera, Action !! Lambda expressions Rocks"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.forEach()</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ChannelStudentInfo info : infos) &#123;</span><br><span class="line">            map.put(info.getStuUid() + <span class="string">"_"</span> + info.getChannelId(), info);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 改造后</span></span><br><span class="line">map.forEach((id, info) -&gt; map.put(info.getStuUid() + <span class="string">"_"</span> + info.getChannelId(), info));</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title="::"></a>::</h4><p>对象::实例方法<br>类::静态方法<br>类::实例方法</p><p>将方法名和对象分割开来</p><p>System.out::println</p><h3 id="流式"><a href="#流式" class="headerlink" title="流式"></a>流式</h3><p>前面大致了解了一点基本的lambda表达式的语法，主要还是来掌握java8的流式处理：</p><p><img src="https://static.oschina.net/uploads/img/201610/06140456_uXbM.png"></p><h4 id="stream"><a href="#stream" class="headerlink" title="stream()"></a>stream()</h4><p>一个流式处理的操作首先是要调用<strong>stream()</strong>函数将集合（或数组，文件等）转化为流</p><p>然后再调用相应的<strong>中间操作</strong>达到我们需要对集合进行的操作</p><h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p>也就是条件筛选，java8提供的筛选操作包括：filter、distinct、limit、skip，筛选的条件都用lamda表达式写</p><ul><li>filter()</li></ul><p>相当于if()</p><ul><li>disctinct()</li></ul><p>相当于sql的distinct，去重</p><ul><li>limit()</li></ul><p>limit(n)：返回包含前n个元素的流</p><ul><li>skip()</li></ul><p>与limit相反，跳过前n个元素</p><ul><li>sorted()</li></ul><p>排序，例如想对流内数据进行年龄从小到大操作：<code>.sorted((s1, s2) -&gt; s1.getAge() - s2.getAge())</code></p><h4 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h4><p>用到频率最高的是collect()，可以这样使用：<code>collect(Collectors.toList())</code>or <code>collect(Collectors.toSet())</code>or<code>collect(Collectors.toMap())</code></p><p>通俗易懂，就不解释了</p><h3 id="流式处理的好处"><a href="#流式处理的好处" class="headerlink" title="流式处理的好处"></a>流式处理的好处</h3><p>（1）代码的<strong>可读性</strong>变高了，虽然也看到不少对于纯流式写法的吐槽，对于刚接触的人比如现在的我而言，把三四行并一行可读性的确提升了，但把十多行并一块就让人觉得有些吃力，debug的时候也会麻烦一些。</p><p>（2）流式处理的意义绝不可能是单单为了好看这么简单，其真正的特点是一个环节处理完的内容可以立马交给下一个环节处理，而不用等所有数据都处理完再进入下一个流程，应该是<strong>加快了运行速度</strong></p><blockquote><p>传统的for循环遍历，不仅需要等全部for循环完成后才能处理下一步，而且在for循环遍历时，只能使用一个核，通过将集合转化成流（通过实际观察，集合转成流本质上是new一个新对象的所需的时间耗时极少），转成流后，就可以充分利用流式处理的特点，显著的提高程序的响应速度，特别对于大数据业务耗时久的集合操作可以提高十倍甚至百倍的响应速度。<br>————————————————<br>版权声明：本文为CSDN博主「timchen525」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/timchen525/article/details/75041328" target="_blank" rel="noopener">https://blog.csdn.net/timchen525/article/details/75041328</a></p></blockquote><p>#######################分割线########################</p><h2 id="sql中-Limit1的作用"><a href="#sql中-Limit1的作用" class="headerlink" title="sql中 Limit1的作用"></a>sql中 Limit1的作用</h2><p>在某些情况下,如果明知道查询结果只有一个,SQL语句中使用LIMIT 1会提高查询效率。 只要找到了对应的一条记录,就不会继续向下扫描了,效率会大大提高。</p><p>如果email是索引的话,就不需要加上LIMIT 1,如果是根据主键查询一条记录也不需要LIMIT 1,主键也是索引</p><p>当然，还有最简单的应用是只找出一个</p><h2 id="SpringBoot接收Date型入参和出参"><a href="#SpringBoot接收Date型入参和出参" class="headerlink" title="SpringBoot接收Date型入参和出参"></a>SpringBoot接收Date型入参和出参</h2><p>可以在JavaBean中对Date型数据加注解达到控制入参出参格式的作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">@JsonFormat(timezone = &quot;GMT+8&quot;,pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开这篇的起因是因为工作中真的遇到了很多大大小小的问题，平时有空我都会记录下来，但由于又不是很重要或者很难的东西，（一切都源于我菜才会有这些问题），不想为这些分别立一篇，但还是有记录的价值的！（记录了自己成长哈哈哈）&lt;/p&gt;
&lt;p&gt;我会按照内容来做标题，也会按照时间倒序，这篇
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>单例模式get</title>
    <link href="http://yoursite.com/2019/01/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fget/"/>
    <id>http://yoursite.com/2019/01/21/单例模式get/</id>
    <published>2019-01-21T12:06:06.000Z</published>
    <updated>2019-01-21T12:11:29.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式使用"><a href="#单例模式使用" class="headerlink" title="单例模式使用"></a>单例模式使用</h2><p>懒汉式：指全局的单例实例在第一次被使用时构建。</p><p>饿汉式：指全局的单例实例在类装载时构建。</p><p>直接来懒汉模式↓</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Single1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single1 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Single1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Single1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将构造器改为private的意义在于防止外部类直接调用<br>加同步锁的意义在于防止多个线程同时获取单例并判断是否为空之后都创新的对象</p><p><strong>双重检查（Double-Check）版本</strong></p><p>Version2代码相对于Version1代码的效率问题，其实是为了解决1%几率的问题，而使用了一个100%出现的防护盾。那有一个优化的思路，就是把100%出现的防护盾，也改为1%的几率出现，使之只出现在可能会导致多个实例出现的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Version 3 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single3 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Single3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Single3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这已经是一个比较完美的单例模式了，最近用大佬代码的时候看到了他这种用单例的方式，就找了<a href="https://www.cnblogs.com/dongyu666/p/6971783.html" target="_blank" rel="noopener">原文博客</a>学到了这种双重检查的方法</p><ul><li><p>第一个if (instance == null)，其实是为了解决Version2中的效率问题，只有instance为null的时候，才进入synchronized的代码段——大大减少了几率。</p></li><li><p>第二个if (instance == null)，则是跟Version2一样，是为了防止可能出现多个实例的情况。</p></li></ul><p>我以为就这样结束了？还有终极版本<strong>volatile</strong></p><p>为解决小概率会发生的原子性问题，</p><p>// Version 4 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (Single4.class) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    instance = <span class="keyword">new</span> Single4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式使用&quot;&gt;&lt;a href=&quot;#单例模式使用&quot; class=&quot;headerlink&quot; title=&quot;单例模式使用&quot;&gt;&lt;/a&gt;单例模式使用&lt;/h2&gt;&lt;p&gt;懒汉式：指全局的单例实例在第一次被使用时构建。&lt;/p&gt;
&lt;p&gt;饿汉式：指全局的单例实例在类装载时构建。&lt;/p
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="http://yoursite.com/2019/01/21/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/21/2018年终总结/</id>
    <published>2019-01-21T12:04:03.000Z</published>
    <updated>2019-01-21T12:05:04.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="年终总结"><a href="#年终总结" class="headerlink" title="年终总结"></a>年终总结</h2><p>hey 2018已经过去了9天了，南京今天下了大雪，从昨晚开始到现在还在下，我仿佛已经过了那个会好好欣赏雪的年纪？雪花很美，但是我只在意今天早上饶了路上班迟到以及鞋子袜子湿了一整天。</p><p>2018让我觉得走的太快，去年这个时候我大概在打包回家过寒假吧，那时候应该刚学完J2EE吧，消薄的一本小绿书，一个副业开滴滴的语速很快的程序员老哥是我们的外聘老师，还记得到期末课程设计的时候只剩下几个人能做的完老师布置得要求。当时感觉班上已经没有几个人还想学这门课了吧，我和男票早早地就完成了这边的作业，听说隔壁班的外聘老师很牛逼，在华为干过，我们就直接溜去了隔壁班听，接触了很多书本上没有的东西。现在想来，不过是一些新的工具，那时候才刚知道maven，强烈地感觉到学校里接触的东西太少了，也太老了</p><p>当时正处于迷茫期，不知道自己该不该考研，但又了解到很多新的东西自己还没学和用到，也不知道自己能不能做一个程序员。虽然没有真的学到什么深的地步吧，基本上也是三天打鱼两天晒网，但我很感谢有男票和我一块互相鼓励督促走了这么一路，起码没有把时间过得太浪费，当然也有很多个晚上我们是靠英雄联盟度过的，当时还为了一个限定的守卫皮肤不依不饶的求了好几个礼拜周末从早到晚做任务。</p><p>后来大四了，我这个班实习得比较早，被学校坑去培训机构后我就再也不相信学校能给我们校招推荐什么好单位了，早早地准备招聘，认真地在网上冲浪，了解行内现在流行的东西，在b站找视频，在论坛上贪婪地学习，另外也一起参加了一个现在觉得是无关紧要的比赛，有些艰难的拿了一个二等奖，之所以说无关紧要是因为选的题目当时完全不了解也没接触过，题目是基于分布式的运维管理平台？【完了 我已经忘记具体的名字了】天呐，选这个题目的时候我连分布式是什么意思都不知道，更别说运维了，我连linux都没学呢= =，但慢慢地这一年过来特别是实习了之后真的遇到了也懂了什么叫做分布式，我胡乱学的Python虽然可以用作比赛的一个小项目，用flask开发的，也知道了其实没什么人用它，java的地位还是不可动摇的，还了解了消息，那时候根本不了解什么是消息队列，【emm 我这一大段没啥语言逻辑，胡乱一打，胡乱一看就好，总之就是当时做了个没什么用的系统，但却是后来学习的敲门砖】</p><p>接下来就是实习，找实习我就基本上校招也去过，通过认识的学长介绍面试也去过，在这样一个小小的三流本科里，我面过的试比当时大多数人要多，大概有七八个吧，这对于6月份的在校大学生已经是很多了吧，一开始极度不自信和紧张，到后来也没那么胆怯了。</p><p>第一个工作我并不会把它作为我以后的工作经历，它将是我2018年最难受的经历之一，这是个校企合作的小外包公司，小到整个公司不如学校一间教室大【当然不是阶梯教室，连普通的小教室都不如】，老板加员工不到二十个人吧。当时一脸期待的我跟着同院的一批男生一块去复试，问了一些框架，第一次面试结结巴巴地但答得不是很糟糕吧，后来通知面试过了，就傻乎乎的去了，明确问了我的实习岗位是什么，答曰实习技术岗，去了之后让我做产品功能分析，座位在那位身兼数职的hr旁边，【还被一个“资深”程序媛嘲讽说坐角落就行，哼 我就是记仇】，而同行的男生都分配了开发的老哥们，唯独我正在下画原型图的工具，当时我就纳闷了，不是技术岗吗？为什么要我看功能需求又画原型的？？？问了之后身兼数职又怀了孕的hr带着公司老板把我拉到会议室，场景是这样的：<br>“我以后难道不敲代码了吗？”<br>“现在公司先这么安排，之后你的岗位事情做得出色了，想要有其他的需求呢，公司都是愿意培养的”<br>“不是说是技术岗吗？我和他们写的都一样，为什么只有我做UI？”<br>“女孩子做UI很吃香的，balabalabala…”<br>那天天气非常糟糕，心情也非常糟糕，下午吃了饭后和老爸商量了之后就直接去辞了，是的，我第一个实习岗位上了大半天的班就走了。</p><p>从第一份实习出来之后情绪很低落，男票是敢做敢说的性格，拿着我的简历到处投，一时之间我来不及低落，只能接受连环面试的轰炸。后来都通过了，毕竟是实习生的面试嘛，最后选了一家中等规模，不用加班，离学校近，做支付的公司。一开始也是被安排做产品，不知是考虑到我的性格不适合还是开发真的缺人打杂，我就顺利地被调去做我心仪的java，他们用自己原有的框架，且没有前后端分工，前端统一是jsp，后端统一是struts2，开发软件是一远古版本的eclipse，数据库是Oracle，当时我管不了这么多，觉得既然能敲代码就已经很感恩了，就高高兴兴地去了，入职三个月，唯一一个被安排的任务是，给22个品牌的汽车台账报表做导入导出与增删改查，且每个报表的格式都不一样，包含的内容也不太相同，却要塞进数据库同一张表里，除了22张报表是最麻烦的之外，其余的工作也都是在处理其他报表和调整报表的格式…其实花一个月就做好了，只是导师一直让我改，改了前后十几二十遍，我还是没能见到甲方看到初版，得到的回复都是你先这么做完，到时候等银行那边看了再协商【也难怪没人做了】上班环境有好有坏，好是非常整洁干净，桌子很大，坏在根本没人和我说话，在他们眼里我可能是个小孩子，我甚至不属于他们部门的人，更没有人教我做什么，我问他们有没有什么需要我做的或我可以了解的项目，看看文档也行，问过很多很多次，都没有，到最后就我全天开始上网冲浪学习其他东西依旧没人理我…于是一些机缘巧合我就又跳了槽</p><p>不，我觉得我并不是一个喜欢折腾的人，相反频繁地换工作让我自己也和难受，但当我意识到我的同龄人正在学习新的知识在你用struts2还整天游手好闲的时候的时候我就坐不住了，我只能靠换一个新的环境来让自己多练一些多学一些。好在第三份实习就是我要找的地方，我知道不能让自己闲下来，其他的管不了太多，可以说我没有明确的规划和方向，只是不能停下来就对了。这篇文章刚写到这，离开头的时候已经差了两个礼拜，中间一直有事情在忙，周末又回家，导致两周前的热情已经消散了，每一天写代码的时候都意识到自己有很多基础要好好扎实，并且要认识理解熟悉那些新的东西，讲道理我连Mybatis用起来还要一边看着百度，业务也是搞不清楚，来了两个多月了吧，能感觉到自己提升了不少，也感觉到自己不会的东西更多了，每一天都很紧迫地想要学习。当然一般遇到问题或不懂的应该问别人，但我又是一个非常胆小的人，能自己解决的就先自己解决，能不麻烦其他人就不麻烦其他人，能用钉钉或微信就绝对不开口，所以总是逮到人家很空闲的时候才敢悄悄问一两个问题，而这些问题可能是我酝酿了好几天的，也许我这个性格太怂了一点，是的我自己也很讨厌。</p><p>吧啦 也没啥想说的 新的一年的计划没有很具体，可以说是愿望吧，一是希望自己能够顺顺利利地度过实习期，学到不少东西，掌握手上用到的技术，二和一相关，希望家人能理解同意自己继续留在南京工作一两年，之后打算在25岁之前回到我的小三线城市找一个对口稳定的工作，三是希望自己存款破万，本来这应该是新年计划的，可是奈何公司组织了一趟深圳香港，给家里人也给自己买了点东西又加上房租和整牙的费用，导致现在离万元存款计划越来越远，吼如果存了万元就奖励自己去迪士尼玩，四是希望和男票开心地度过接下来的一年，待时机合适告诉爸妈自己有男朋友并且得到认可，嘻嘻(oﾟ▽ﾟ)o  ，噢还有五，给自己换一个好用点的电脑</p><p>|*´Å`)ﾉ 没有寒假了很不开心，已经算不清自己现在到底几岁了，感觉日子过得很快，没想到自己已经二十多岁了，哎，想放假</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;年终总结&quot;&gt;&lt;a href=&quot;#年终总结&quot; class=&quot;headerlink&quot; title=&quot;年终总结&quot;&gt;&lt;/a&gt;年终总结&lt;/h2&gt;&lt;p&gt;hey 2018已经过去了9天了，南京今天下了大雪，从昨晚开始到现在还在下，我仿佛已经过了那个会好好欣赏雪的年纪？雪花很美，
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>kafka浅谈</title>
    <link href="http://yoursite.com/2019/01/21/kafka%E6%B5%85%E8%B0%88/"/>
    <id>http://yoursite.com/2019/01/21/kafka浅谈/</id>
    <published>2019-01-21T12:02:28.000Z</published>
    <updated>2019-02-27T12:10:57.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>因为我遇到了Kafka，就记录Kafka的机制吧，先要了解一些概念：</p><p>1.producer &amp; consumer<br>​    消息生产者与消费者<br>2.broker<br>​    kafka集群中包含的服务器，每个broker是一个节点，也可以看做是消费者系统中的一个kafka进程<br>3.topic &amp; partition<br>​    topic相当于消息的key，属于消息的类别，一个topic包含一个或多个partition<br>4.replica<br>​    partition的副本<br>5.<strong>Zookeeper</strong><br>​    管理producer，broker，consumer的动态加入与离开，要用kafka必须启用Zookeeper</p><h3 id="Kafka的高可用性"><a href="#Kafka的高可用性" class="headerlink" title="Kafka的高可用性"></a>Kafka的高可用性</h3><p>Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制，每个partition不止直接给一个broker，而会生成自己的多个replica副本，所有的replica会选举出一个leader出来，所有的生产和消费与leader打交道，其余的replica就是follower。</p><p>写的时候，leader会负责把数据都同步到follower上，Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。<br>这么搞，就有所谓的<strong>高可用性</strong>了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的，如果这上面有某个 partition 的 leader，那么此时会从 follower 中<strong>重新选举</strong>一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p><p><strong>写数据</strong>的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p><p><strong>消费</strong>的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><h3 id="Kafka保证消息不被重复消费（保证消费的幂等性）"><a href="#Kafka保证消息不被重复消费（保证消费的幂等性）" class="headerlink" title="Kafka保证消息不被重复消费（保证消费的幂等性）"></a>Kafka保证消息不被重复消费（保证消费的幂等性）</h3><p>Kafka提供了两套consumer API，high-level API提供了更多的细节，offset能保证消息植被消费一次，每个消息被写的时候都有一个offset存在，代表消息的序号。当消费者消费了数据之后，每隔一段时间就会把自己消费过的消息的offset提交一下，若是要对系统做重启操作，就得冲上次消费到的offset来继续消费。</p><h3 id="Kafka保证消息可靠性（消息不会丢失）"><a href="#Kafka保证消息可靠性（消息不会丢失）" class="headerlink" title="Kafka保证消息可靠性（消息不会丢失）"></a>Kafka保证消息可靠性（消息不会丢失）</h3><p>既然有了offset，也知道offset会自动的刷给kafka，告诉它你已经消费了这些消息，但有一种情况可能是消费者虽自动提交了offset，但其实你刚准备处理这个消息，你还没来得及处理，自己就挂了，但此时kafka已经认为你消费过了。</p><p>那么可以关闭自动提交offset，当你认为处理完消息后再手动提交，但的确可能你处理完还没提交offset自己又挂了那就只能靠自己来保证了</p><p>文章中提到起码要设置下面四个参数：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置 <code>acks=all</code>：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kafka&quot;&gt;&lt;a href=&quot;#Kafka&quot; class=&quot;headerlink&quot; title=&quot;Kafka&quot;&gt;&lt;/a&gt;Kafka&lt;/h2&gt;&lt;p&gt;因为我遇到了Kafka，就记录Kafka的机制吧，先要了解一些概念：&lt;/p&gt;
&lt;p&gt;1.producer &amp;amp;
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="MQ" scheme="http://yoursite.com/tags/MQ/"/>
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>MQ入门</title>
    <link href="http://yoursite.com/2019/01/21/MQ%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/01/21/MQ入门/</id>
    <published>2019-01-21T11:58:03.000Z</published>
    <updated>2019-01-21T12:00:56.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mq"><a href="#Mq" class="headerlink" title="Mq"></a>Mq</h2><p>今天小菜鸡跟着<a href="https://doocs.github.io/advanced-java/#/?id=%e4%ba%92%e8%81%94%e7%bd%91-java-%e5%b7%a5%e7%a8%8b%e5%b8%88%e8%bf%9b%e9%98%b6%e7%9f%a5%e8%af%86%e5%ae%8c%e5%85%a8%e6%89%ab%e7%9b%b2" target="_blank" rel="noopener">Java进阶扫盲</a>好好了解了一下Mq，感觉人家分享的东西写的真的是好呀，我自己写的都是些啥呀，本来不想自己写了，但是害怕自己读了一遍会忘记，并且觉得自己写一遍理解得更好，所以还是想要重新来学习写一篇有关Mq的文章。</p><p>事实上我已经遇到了Activemq与Kafka，没有好好地思考其原理与优缺点，那么废话不多说开始吧。</p><h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><p>之前了解Activemq的时候粗略地了解了一下，当时只是觉得可能是因为处理速度比较快，另外还有一个词——解耦，ok，<strong>解耦</strong>是如何体现的呢？</p><p>倘若现在有一个消息生产者producer，有多个要获取这些消息的消费者，若使用调用接口的方式，producer发消息的同时万一遇到消费者挂了的情况呢？挂了要不要重发？这时候producer和其他需要消费的系统之间有高的耦合，这显然非常地麻烦。</p><p>于是 发布订阅的模式就解决了这一问题，producer只需要丢给Mq消息，消费者自行从Mq里订阅所需要的消息，同时这也解释了为什么用Mq肯定速度比较快，除了producer不需要考虑其他系统外，Mq可以<strong>异步</strong>地被多个消费者订阅。</p><p><strong>削峰</strong></p><p>生产中的消息不可能总是平缓地产生，有个什么活动或周末客户量较大很可能导致系统请求暴增，若依靠普通的基于MySQL不知道要多久，而先刷进Mq，一边等待数据库处理，等系统空闲比如深夜了没什么用户的时候，再慢慢处理Mq中的消息。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>并不是把一个大盒子的东西拆开来放进小盒子就完全没有弊端，万一Mq挂了消息丢了，或是消费者拿到消息后写数据库失败了呢，而且平白多了一个小盒子出来无疑是把整个过程复杂化了，对付这种一致性和可用性问题部分Mq有自己独到的优化方式。</p><h3 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>入门最早用Activemq，实际生产中RabbitMq和Kafka都是优选。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mq&quot;&gt;&lt;a href=&quot;#Mq&quot; class=&quot;headerlink&quot; title=&quot;Mq&quot;&gt;&lt;/a&gt;Mq&lt;/h2&gt;&lt;p&gt;今天小菜鸡跟着&lt;a href=&quot;https://doocs.github.io/advanced-java/#/?id=%e4%ba%92%
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="MQ" scheme="http://yoursite.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的key是否可以为null</title>
    <link href="http://yoursite.com/2018/12/16/HashMap%E7%9A%84key%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%B8%BAnull/"/>
    <id>http://yoursite.com/2018/12/16/HashMap的key是否可以为null/</id>
    <published>2018-12-16T02:58:03.000Z</published>
    <updated>2019-01-21T09:27:28.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap的key可以为null吗？"><a href="#HashMap的key可以为null吗？" class="headerlink" title="HashMap的key可以为null吗？"></a>HashMap的key可以为null吗？</h2><p>​    这问题太基础了，回答是<strong>可以</strong>，但不得不说很久时间不回顾，我已经忘了！前一段时间遇到的时候我想当然地以为不可以，可见当做考试记的东西忘得真的太容易了。</p><p>​    HashTable不可以而HashMap可以，HashMap可以存一个key为null的元素，若多个则后来的会覆盖原有的值，并且value均可为空。下面研究一下源码！这样就能加深印象了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>emm，粗粗地看一眼没有对key作null的限制，这个Node就是普通的Node，也没有对key做什么限制，这个hash()方法里返回为0，所以表示key为null时不会报错，是可行哒，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>并且get方法特别处理了值为null的情况</p><p>下面是HashTable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    先看到了value == null会抛空指针异常，下面取了key的hash值，如果此时key为null会有异常，因为他没有对null做特殊处理所以key为null的情况也是不允许的。</p><p>​    题外话看到下面做了个运算，这个&amp; 0x7FFFFFFF，32-bit 十六进制，代表int的最大正整数，二进制是全1。</p><p>​    吼啦  本文完 万恶的周五 让人一点学习的心思都没有 赶紧回宿舍啦</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HashMap的key可以为null吗？&quot;&gt;&lt;a href=&quot;#HashMap的key可以为null吗？&quot; class=&quot;headerlink&quot; title=&quot;HashMap的key可以为null吗？&quot;&gt;&lt;/a&gt;HashMap的key可以为null吗？&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Solr</title>
    <link href="http://yoursite.com/2018/12/16/Solr/"/>
    <id>http://yoursite.com/2018/12/16/Solr/</id>
    <published>2018-12-16T02:57:06.000Z</published>
    <updated>2019-01-21T09:29:16.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><p>​    是一个开源的搜索引擎工具，分布式搜索。说到分布式搜索几个字已经能大致了解他的优势和特点。在此要感谢公司的技术交流氛围，让我了解了不少新技术，但要是一直遇不到场景，难免会忘记，所以现在记录下来。</p><p>​    初印象是Solr的速度非常之快，他的原理大致为可以把关系型数据库的数据搬出来，基于数据的索引可进行增删改查（也是为什么它很快的一个原因），支持用户自定义的分词器，教程里写可以与Hadoop一起使用，但好吧我还不了解Hadoop…</p><p>​    上面说他把数据库的数据搬出来，Solr不仅支持查询，其实也是一个变相的数据库，没错他应该是算作NoSQL的，它是支持存储，可扩展的，处理大量数据的搜索引擎。</p><p>​    官方的教程已经非常详细，这边也不做多余的操作步骤，大概讲个流程。推荐教程，<a href="https://www.w3cschool.cn/solr_doc/solr_doc-1r4g2flx.html" target="_blank" rel="noopener">W3C</a>， <a href="https://www.yiibai.com/solr/apache_solr_terminology.html" target="_blank" rel="noopener">易百</a>，</p><p>​    导入数据需要在xml里配置数据库信息，开启Solr服务后有个可视化的仪表盘，可以看到Solr的占存、分片情况等，可以在查询面板里执行查询操作，有一些参数</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>q</td><td>这是<strong>Apache Solr</strong>的主要查询参数，文档根据它们与此参数中的术语的相似性来评分。</td></tr><tr><td>fq</td><td>这个参数表示<strong>Apache Solr</strong>的过滤器查询，将结果集限制为与此过滤器匹配的文档。查询结果被限制为仅搜索筛选器查询返回的结果。</td></tr><tr><td>start</td><td><code>start</code>参数表示页面的起始偏移量，此参数的默认值为<code>0</code>。</td></tr><tr><td>rows</td><td>这个参数表示每页要检索的文档的数量。此参数的默认值为<code>10</code>。</td></tr><tr><td>sort</td><td>这个参数指定由逗号分隔的字段列表，根据该列表对查询的结果进行排序。</td></tr><tr><td>fl</td><td>这个参数为结果集中的每个文档指定返回的字段列表。</td></tr><tr><td>wt</td><td>这个参数表示要查看响应结果的写入程序的类型。</td></tr></tbody></table><p>​    Solr索引（Document），它类似与关系型数据库表中的一条记录，可以包含多个字段（Field），每个字段包含name和value，通常文档都包含一个能唯一表示该数据的id字段，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">doc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span>company123<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"companycity"</span>&gt;</span>Atlanta<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"companystate"</span>&gt;</span>Georgia<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"companyname"</span>&gt;</span>Code Monkeys R Us, LLC<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"companydescription"</span>&gt;</span>we write lots of code<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"lastmodified"</span>&gt;</span>2013-06-01T15:26:37Z<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">doc</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Field座位构成Document的基本单元，除了name和value还有一些其他属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text_general"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Indexed：Indexed=true时，表示字段会加被Sorl处理加入到索引中，只有被索引的字段才能被搜索到。</li><li>Stored：Stored=true，字段值会以保存一份原始内容在在索引中，可以被搜索组件组件返回，考虑到性能问题，对于长文本就不适合存储在索引中。</li></ul><p><strong>核心（core）</strong>，封装单个物理索引。一个或多个组成集合的逻辑碎片(或片)。当数据量大的时候，需要分布式的solr，这时拆分后的数据就存放在一个个core中，一个collection下可以有一个或多个core，而core可以看做一个容器，是数据碎片所在的地方，但是担心一台机器里出故障，所以碎片有重复的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Solr&quot;&gt;&lt;a href=&quot;#Solr&quot; class=&quot;headerlink&quot; title=&quot;Solr&quot;&gt;&lt;/a&gt;Solr&lt;/h2&gt;&lt;p&gt;​    是一个开源的搜索引擎工具，分布式搜索。说到分布式搜索几个字已经能大致了解他的优势和特点。在此要感谢公司的技术交流氛
      
    
    </summary>
    
      <category term="搜索引擎" scheme="http://yoursite.com/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="搜索引擎" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="Solr" scheme="http://yoursite.com/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>关系型数据库与非关系型数据库</title>
    <link href="http://yoursite.com/2018/12/16/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/16/关系型数据库与非关系型数据库/</id>
    <published>2018-12-16T02:56:53.000Z</published>
    <updated>2019-01-21T09:30:46.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系型数据库与非关系型数据库"><a href="#关系型数据库与非关系型数据库" class="headerlink" title="关系型数据库与非关系型数据库"></a>关系型数据库与非关系型数据库</h2><p>​    先来了解一些概念，慢慢来：</p><p>​    <strong>NoSQL</strong></p><p>​    查百度真的是云里雾里的，好在知乎的老哥们说话都很好听，人家的名字叫<strong>Not Only SQL</strong>（不仅仅是SQL），缩写叫NoSQL，取名叫非关系型数据库，其他的我们等等再说</p><p>​    <strong>ACID</strong></p><p>​    事务的特性，【这可是我遇到的第一道面试题啊我怎么能忘了呢？】原子性、一致性、隔离性、持久性，照理来说关系型数据库都支持ACID，而NoSQL是让你在CAP（一致性，可用性，分区容忍度）中的任意两项做选择</p><p>​    <strong>面向对象与关系型</strong></p><p>​    好吧这个标题起的并不好，但我想用日常学和用的东西来理解什么是关系型，我们的Java是个面向对象的语言，关系型数据库也就是我们平时最常用的主流数据库，他们一般有固定的表结构、表与表的关系（对象间的关系）。关系数据库与SQL离不开，可以说关系数据库就是基于SQL而产生的，使用SQL语句使我们的认知与计算机所能理解的数据库衔接在一起。</p><p>​    【所以面向对象对应的就是关系型数据库…】</p><p>​    关系型数据库有很多优点呀比如易理解使用方便，毕竟操作起来是通过SQL的，我们通常把一个类的数据存在一张表里，那么为什么会发展出非关系型数据库呢？首先最严重的瓶颈是高并发与高频率，这个很好理解，比如网站每秒产生的数据量非常巨大，在海量的数据库表中做增删改查效率很低，还有一点就是难以扩展，比如当你有了很多数据之后，当我想对项目进行更新维护，难免要遇到数据迁移，或一个服务器内的这个数据库占得太大了，但我又没法方便快捷的对其进行升级与扩展，</p><p>​    那么NoSQL就衍生了，他以键值对存储，且结构不固定，没有固定的对象结构，你可以根据需要往同一个uid后面加上需要的与之相关的不同“字段”，那么其实一直学并用的关系型数据库的强大的SQL搜索能力是比NoSQL好得多，它不能像SQL一样通过where给很多条件进行多表查询，事实上他根本没有表的概念，但它的优点弥补了SQL几乎所有的缺点，事实上生产中我们应该避免过复杂的多表连接</p><p>​    上面说到传统关系型数据库支持ACID，特别是一致性，关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差，像微信微博等对消息高并发的应用来说一致性并没有这么重要，所以这就是“<strong>NoSQL是让你在CAP（一致性，可用性，分区容忍度）中的任意两项做选择</strong>”的意思</p><p>​    现在我已经理解了什么是关系型非关系型，比如关系型数据库有Oracle，MySQL，非关系型有redis，才疏学浅，其他的还不会用。</p><p>​    可能我言语间可能有强调非关系型数据库，因为看到的很多答案都是非关系型更好更快怎么样，这也许是这些回答的大佬们认为我们已经非常了解什么叫关系型吧，但其实这两个没有孰优孰劣，看到一篇文章中说这就像问轮船会不会取代汽车一样，现在NoSQL很火，那可能是因为我们需要他的时代来得相对晚一些，认为这是一个新的趋势，但完全替代还是不可能的，对不太需要后续增删改查的数据放进关系型数据库，对高并发需要扩展的数据采用非关系型数据库，对面向文档的数据存在MongoDB。</p><p>​    我真是太菜了呀，码这些字花了我好久时间啊哈哈！有哪里不对的还请指正呀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关系型数据库与非关系型数据库&quot;&gt;&lt;a href=&quot;#关系型数据库与非关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库与非关系型数据库&quot;&gt;&lt;/a&gt;关系型数据库与非关系型数据库&lt;/h2&gt;&lt;p&gt;​    先来了解一些概念，慢慢来：&lt;/p&gt;
      
    
    </summary>
    
      <category term="Nosql" scheme="http://yoursite.com/categories/Nosql/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>代码重构</title>
    <link href="http://yoursite.com/2018/12/16/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/"/>
    <id>http://yoursite.com/2018/12/16/代码重构/</id>
    <published>2018-12-16T02:56:35.000Z</published>
    <updated>2019-01-21T09:30:22.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h2><p>​    有一天部门里大哥跟我说要注意注释和优雅的代码，当然如果我知道怎么做的话我也很想写得非常清爽人性化。</p><h3 id="1-常量"><a href="#1-常量" class="headerlink" title="1.常量"></a>1.常量</h3><p>​    之前一个单位程序员的平均年龄有30+，用的东西也很古老但非常稳定，他们喜欢把常量都放在配置文件里，于是我也这么做并且我当时做的东西没有什么交互，所有功能都是我傻乎乎的用相似的代码模仿实现的。但现在我手上的是个springboot项目，观察里面的除了application.yml就没有其他的配置文件了，思考难道这种放在配置文件里的方式过时了吗？于是我现在把普通常量放在常量类里，而当我要调用别人接口的时候把url字符串放在枚举类中。</p><p>​    如果是常量类中，为了防止你的常量真真切切的为不会变的量，最好满足不会被继承的能力，即加final，但貌似也有其他方法如一般类加私有构造函数的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contants</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Contants</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String balabala = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    更优的方法是枚举，在之前我其实没实际接触过枚举，也是看到大哥的代码才知道枚举可以这么用，给枚举定个name和value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ContantsEnum&#123;</span><br><span class="line">    <span class="comment">//命名规则为第一个Bala为模块名，第二个是功能或方法名，XXX大写为常量名，我自己的规则哈也可以是别的</span></span><br><span class="line">    Bala_FunPrefix_XXX(<span class="string">"XXX"</span>,<span class="string">"https://balabala"</span>),</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContantsEnum(String name,String value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    感觉都说枚举更优是因为用起来很方便，直观吧。</p><h3 id="2-工具类"><a href="#2-工具类" class="headerlink" title="2.工具类"></a>2.工具类</h3><p>​    不想再重复劳动啦，那就自己写工具包吧，虽然写的时候真的要非常严谨，还要想好有哪些重载的方法，会遇到哪些参数，一旦有一点一句不清楚都要搞到清楚为止才敢往上写</p><p>​    提高代码的复用性，让IDEA旁边的黄色标记变少些，加油叭！</p><h3 id="3-长度"><a href="#3-长度" class="headerlink" title="3.长度"></a>3.长度</h3><p>​    这不仅有方法的长度还有类的长度，一个类里面已经装了七八个方法了，再写的时候就想想能不能分两个类，方法体不能太长也是不用说的了</p><p>最近在看《重构 改善及有代码的设计》，看到什么其他的再加</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代码重构&quot;&gt;&lt;a href=&quot;#代码重构&quot; class=&quot;headerlink&quot; title=&quot;代码重构&quot;&gt;&lt;/a&gt;代码重构&lt;/h2&gt;&lt;p&gt;​    有一天部门里大哥跟我说要注意注释和优雅的代码，当然如果我知道怎么做的话我也很想写得非常清爽人性化。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>我之所以做程序员</title>
    <link href="http://yoursite.com/2018/12/16/%E6%88%91%E4%B9%8B%E6%89%80%E4%BB%A5%E5%81%9A%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    <id>http://yoursite.com/2018/12/16/我之所以做程序员/</id>
    <published>2018-12-16T02:52:17.000Z</published>
    <updated>2019-03-03T02:47:37.216Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天还和往常一样早上没什么事的话打开v站和新闻翻翻，看到一个自己也很想问的帖子，<a href="https://www.v2ex.com/t/514101?p=1" target="_blank" rel="noopener">这个</a>，看了几个大佬们的博客，想起来自己有挺久不爱整博客了，仿佛也就刚建时一时兴起写了几篇，主要用途是像备忘录一样的东西，没什么要求也没什么标准，今天开始多一些生活和所见所闻叭。</p><p>​    这些天总体来说挺闲的，有很多想说的但是又有懒得缘故就没有记下来，也有一些新的东西叭。</p><h2 id="我之所以做程序员"><a href="#我之所以做程序员" class="headerlink" title="我之所以做程序员"></a>我之所以做程序员</h2><p>​    周一看到一篇文章标题实在是太吸引我了<a href="https://coolshell.cn/articles/6346.html" target="_blank" rel="noopener">【程序员因为女孩而美丽】</a>是在我一贯喜欢翻大佬们所有过去的文章时一眼看到的，看完后我立马想到身边刚放弃考研正在找工作但未果的小A，分享给了她(ﾉ”◑ ◑)ﾉ”(｡•́︿•̀｡)</p><p>​    -我为什么学这个呢？ -我是不是不适合做程序员我真的好菜啊。</p><p>​    大概每天下班的时候我都会有这种想法，好在我有个能听我说话也同样是程序员的男朋友，总是会鼓励我。</p><p>​    我选计算机其实是在一篮筐烂苹果里选了个比较好的。初中的时候刚开始成绩比较普通，后来遇到了个特别棒的老师，燃起了我对数学的激情，开始喜欢解大家都解不出来的难题，那个时候作业最后一题做到十二点钟睡觉还想着第二天起早和老爸一起讨论题目的日子真的特别难忘。在经历了艰苦又充实的初中后考了个当地最好的学校，在那之后我总是觉得自己的人生一路down，但可能那时候的拼劲影响了我选专业。我应该算比较内向的人，没人可以噼里啪啦的话就写日记吐槽给自己看，高中过得就好像一个白银选手不小心定级了钻石段位的感觉，过得比较浑浑噩噩，虽然也很认真地学习，却一点都没有了以前的快乐，<strong>不快乐的学习是不可能成功的！</strong>也阴差阳错去了文科班，本来英语和文言文就很差，去了之后感觉自己简直就是最差了，那感觉真的太可怕了。痛苦，痛苦到不想再体验一次了。</p><p>​    高考不出意外的考得很烂，因为到最后已经是被文科的课整的快崩溃了的边缘，当时感觉这辈子就要完了，从小到大都非常听话，除了学习也没有接触什么其他擅长的东西，觉得高考砸了一辈子都毁了的感觉。填志愿时第一次拿起了那本之前从来没翻过的招生册【一二本与三本专科是不同的招生册】，打开来是一些从来没听过名字的野鸡学院，专业也是非常单调，金融、经管、护理、师范，最后看到有个三本的计算机专业文理兼招，所以头三个选的都是计算机院的专业，当时只是一个原因：其他的都没意思，就这个有意思。</p><p>​    我接触计算机其实没什么天赋，时间也不长，家里的电脑除了用它来玩过游戏之外没干过别的，高一的时候进了一个人工智能的社团，但程度仅限于在面包板上连线路，复制一段老师给的现成的代码，改一下里面的数然后让小灯泡或小喇叭冒不同节奏的声响，但要理解他们简直是不可能的好嘛，我连自己功课都搞不定还来研究代码？</p><p>​    大学刚开始学c和java的时候我都能很快地入门吧，也不知道是不是其他人都不爱学反正我学的的确比他们好，大学第一个学期过二级和参加一些小竞赛，虽然学校不怎么样但老师也是有负责的，培养我们这群小废物还是很尽职尽责的，于是大一的时候经常上水课研究算法题，熬夜敲代码，有的时候到一两点。虽然熬夜对男生可能不算什么大事吧，但在女生宿舍我几乎就是个奇葩了，包括我还和班里男生一起打lol，深夜等大家睡了看惊悚片之类…不过很后悔自己爱上了打游戏，不然能省下不少时间学习。还有熬夜…后来开始慢慢地熬不了夜了，现在也维持着每天十一点多睡的习惯。</p><p>​    我开始慢慢喜欢敲代码吧，在为数不多的但是一个系所有16个女生里面，走到现在，唯一一个做开发的，感觉过得其实跟男孩子差不多。看到那篇文章里的很多分享，感同身受，找实习的过程比较艰辛，也许以后会更加艰辛，人家会自然而然觉得女生不行，尽管他们嘴上没说，但真的到我体会过来回想，会觉得非常不公平。</p><p>​    我知道刚实习跳来跳去不好，但在那些地方就是浪费时间，于是我出现在这里，一个网络公司，做java开发。大家还比较照顾我，尽管我还是那个一遇到问题心里就乱着急的萌新，做得东西还比较简单，总是遇到大大小小的bug，但每次自己找到哪错了和解决之后都很满足。</p><p>​    我还想学习，还想敲代码，因为很开心，就这样。也许有其他工作也会让我觉得快乐，但我正好碰到了一个还不错的，为什么不能试试呢？</p><h2 id="杂谈-12-14"><a href="#杂谈-12-14" class="headerlink" title="杂谈 12/14"></a>杂谈 12/14</h2><p>嘿哈，这里又是一个一天没有任务的逛知乎的实习生，想巴拉一些实习到现在的经历和感受。</p><p>​    前面也说过我是个渣渣本三的学计算机的，我的专业有点特殊，名字后面带了嵌入式，其实也就是校企合作的班级，算是试验班。学费比别人高一些，前三年学的课完全一样，差点就以为自己被坑了白多交钱了。直到大四才知道只有我们系和另两个抽出来的软工班，也就是院里面的一小部分学生可以提前出来实习，而且实习单位必须得是校企！</p><p>​    大四刚开始我们班上了六周课，补了一些数据库和网络通信方面的知识，就开始了长达四个月的被“安排”的日子。我们从学校被赶到培训机构（也算是大企业的培训机构）学习，这是我活到现在觉得最坑的事！原来我们多交的钱就是为了来这种地方培训！我不知道外面其他培训机构是什么样的，反正就我那个班去的地方真的很垃圾。老师以龟速从helloworld开始讲java基础，讲了两个月，接着又换了一个更差的老师从html，div+css开始讲网页设计。我并没有说基础不重要的意思，但是让一群就快要找实习了的CS班的人用龟速复习一堆比学校里学的还少的知识，还要每天做一堆明明就很简单的重复的作业，真的很侮辱人。我也第一次和学校老师反映这边的学习进度和老师都不ok，而第二天，机构这边的“老师”就知道我在他们背后打小报告了，开始“特别关注”我，第二周，院长跑到班上来考察我们的情况，看到我们班的嬉皮们在下面激烈鼓掌夸赞，我就明白了，自己还是太年轻。</p><p>​    其实我早该知道学校和机构这边就是合伙了把我们这群废物卖来补基础中的基础，我还妄想能学点新的东西，还妄想学校会顾忌自己抛出去的学生。<strong>有问题可以提意见的意思不是你真的可以提意见，而是你敢提意见吗</strong></p><p>​    很多人家里真的有矿，很多人真的不学习不努力也可以过得很好，做舔狗的下场并不是一无所有，而不做舔狗说不定会一无所有，当你发现你和周围的看法都不一样时，努力让自己换个环境就好了。但我也许现在一无所有，只能靠自己，防止自己堕入更差的环境中。</p><p>​    高中班主任有一次班会让我印象特别深，他说也许有很多人并没有大的目标和梦想，长大了就想做个普通人，上一个常白班，朝九晚五，回到家吃热的饭菜，周末好好休息，看个电影饭后散散步，即使是这样的生活，也需要你很努力很努力才能得到，并没有想象的这么简单。也许这是对我这样的家里没矿的人最真实的总结吧。</p><h2 id="今日乐子：Cookie的诞生"><a href="#今日乐子：Cookie的诞生" class="headerlink" title="今日乐子：Cookie的诞生"></a><strong>今日乐子：Cookie的诞生</strong></h2><p>刚出生的婴儿认为世界就是他能看到的东西组成的。你离开房间的时候，他觉得你消失了；你回来的时候，对他来说已经是一个全新的人。到四个月以后，它会在某个时间以上掉这个世界比他想象中更加稳定，每天早上喝晚上对他打招呼的你都是同一个人。也就是说婴儿们终于有Cookie了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    今天还和往常一样早上没什么事的话打开v站和新闻翻翻，看到一个自己也很想问的帖子，&lt;a href=&quot;https://www.v2ex.com/t/514101?p=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个&lt;/a&gt;，看了几个大佬们的博客
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>json型字符串取值</title>
    <link href="http://yoursite.com/2018/11/25/json%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%96%E5%80%BC/"/>
    <id>http://yoursite.com/2018/11/25/json型字符串取值/</id>
    <published>2018-11-25T02:48:07.000Z</published>
    <updated>2019-01-21T11:56:54.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="json型字符串取值"><a href="#json型字符串取值" class="headerlink" title="json型字符串取值"></a>json型字符串取值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        JSONObject object = JSON.parseObject(msg);</span><br><span class="line">        String resultMsg = object.getString(<span class="string">"data"</span>);</span><br><span class="line">        <span class="keyword">return</span> resultMsg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><p>​    都8012年了我还用这么原始的方法嘛，如果遇到了bean怎么办，有更好的工具：Gson和Jackson，这里只讲Gson。Gson提供了<code>fromJson()</code> 和<code>toJson()</code> 两个直接用于解析和生成的方法，前者实现<strong>反序列化</strong>，后者实现了<strong>序列化</strong>。</p><p>Serialization:序列化，使Java对象到Json字符串的过程。</p><p>Deserialization：反序列化，字符串转换成Java对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最简单的用法</span></span><br><span class="line"><span class="comment">//toJson：将对象转换为json字符串</span></span><br><span class="line">String jsonstr = <span class="keyword">new</span> Gson().toJson(user, User.class);</span><br><span class="line"><span class="comment">//fromJson：将就送字符串转化为对象</span></span><br><span class="line">User user = <span class="keyword">new</span> Gson().fromJson(jsonstr, User.class);</span><br></pre></td></tr></table></figure><p>​    但序列化和反序列化的过程中，期望的驼峰格式会被转成实际的下划线格式，解决这个问题可以用@SerializedName注解，在实体类定义属性的时候加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SerializedName</span>(<span class="string">"email_address"</span>)</span><br><span class="line"><span class="keyword">public</span> String emailAddress;</span><br></pre></td></tr></table></figure><p>​    如果接收的格式不止两种，还可加alternate参数，可以看做是给属性加多个“别称”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SerializedName</span>(value = <span class="string">"emailAddress"</span>, alternate = &#123;<span class="string">"email"</span>, <span class="string">"email_address"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> String emailAddress;</span><br></pre></td></tr></table></figure><p>​    除了Object，基本数据类型的json生成与解析也是可以的，只是意义不大。另外还可对List、Map、Set等，一一来研究：</p><p>​    <strong>温馨提示：如若需要频繁操作，直接创一个gson对象，以免不必要的资源浪费，但我比较懒，所以下面写的都是new Gson().balabala，后面我会总结一个工具类，这里就当个demo看看</strong></p><h3 id="List转化"><a href="#List转化" class="headerlink" title="List转化"></a>List转化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个带泛型的list，我们想把它转为json</span></span><br><span class="line">List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">list.add(user1);</span><br><span class="line">list.add(user2);</span><br><span class="line">list.add(user3);</span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> Gson().toJson(list);</span><br><span class="line"><span class="comment">//转回泛型list有点复杂，要用TypeToken</span></span><br><span class="line">List&lt;User&gt; resultlist = <span class="keyword">new</span> Gson().fromJson(str,<span class="keyword">new</span> TypeToken&lt;List&lt;User&gt;&gt;() &#123;&#125;.getType());</span><br></pre></td></tr></table></figure><h3 id="Map转化"><a href="#Map转化" class="headerlink" title="Map转化"></a>Map转化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个普通的Map，我们把key定义为string，value定义为一个Object</span></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"a"</span>,user1);</span><br><span class="line">map.put(<span class="string">"b"</span>,user2);</span><br><span class="line"><span class="comment">//把map转为json</span></span><br><span class="line">String str = <span class="keyword">new</span> Gson().toJson(map);</span><br><span class="line"><span class="comment">//换回map也要用TypeToken</span></span><br><span class="line">Map&lt;String, Object&gt; resultmap = <span class="keyword">new</span> Gson().fromJson(str,<span class="keyword">new</span> TypeToken&lt;Map&lt;String,Object&gt;&gt;() &#123;&#125;.getType());</span><br></pre></td></tr></table></figure><h3 id="Set转化"><a href="#Set转化" class="headerlink" title="Set转化"></a>Set转化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个简单的Set，里面存的是String</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">"bala"</span>);</span><br><span class="line">set.add(<span class="string">"balala"</span>);</span><br><span class="line"><span class="comment">//把set转为json</span></span><br><span class="line">String str = <span class="keyword">new</span> Gson().toJson(set);</span><br><span class="line"><span class="comment">//换回set</span></span><br><span class="line">Set&lt;String&gt; resultset = <span class="keyword">new</span> Gson().fromJson(str,<span class="keyword">new</span> TypeToken&lt;Set&lt;String&gt;&gt;() &#123;&#125;.getType());</span><br></pre></td></tr></table></figure><h3 id="GsonUtil"><a href="#GsonUtil" class="headerlink" title="GsonUtil"></a>GsonUtil</h3><p>吼啦，贴一个自己用的GsonUtil，只写了一个转化list的，因为我只用到了这个，以后用到了再加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.JsonObject;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.reflect.TypeToken;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: UnifiedBgManage</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Gson-处理json字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: WYuyin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-12-13 11:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(GsonUtil.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toJson</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gson.toJson(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toJson</span><span class="params">(Object o , Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gson.toJson(o,type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">toObject</span><span class="params">(String jsonstr , Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(jsonstr,type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 由于比较懒，直接把jsonstr里的值获取出来</span></span><br><span class="line"><span class="comment">     * 例："&#123;\"data\":[],\"desc\":\"1000\",\"pageNum\":1,\"status\":\"success\",\"total\":0&#125;"</span></span><br><span class="line"><span class="comment">     *  -&gt; "[]"</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [jsonstr, title]  title:key 比如"data","status"...</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: java.lang.String </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: WYuyin</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getData</span><span class="params">(String jsonstr , String title)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        JsonObject jsonObject = gson.fromJson(jsonstr,JsonObject.class);</span><br><span class="line">        String resultstr = <span class="string">""</span> + jsonObject.get(title);</span><br><span class="line">        <span class="keyword">return</span> resultstr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 将数组字符串转化为list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Param</span>: [liststr] </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: java.util.List&lt;T&gt; </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: WYuyin</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">toList</span><span class="params">(String liststr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;T&gt; resultlist = gson.fromJson(liststr, <span class="keyword">new</span> TypeToken&lt;List&lt;T&gt;&gt;() &#123;&#125;.getType());</span><br><span class="line">        <span class="keyword">return</span> resultlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##Jackson</p><p>大概一个月前整理了一个Gson的用法，但只会Gson怎么够呢，我得看得懂其他人的代码呀，嘿，事实上现在的我就是这样，不同的人给我他们的代码，让我加东西的时候我总要模仿他们的写法，比如有些人不爱写长注释，有些人用Gson而有些人用Jackson…</p><p>为了把json数据映射到对象上，你需要：有一个包含你需要的属性值的实体类，类的属性名称与json中的key一一对应，若遇到大小写混乱或下划线的用<strong>@JsonProperty(“xxx”)</strong>标在属性上</p><p>接下来，你可以包装一个jackson的工具类，主要用Jackson ObjectMapper对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonJsonUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Jackson ObjectMapper对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">object2String</span><span class="params">(Object object)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectMapper.writeValueAsString(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">string2Object</span><span class="params">(String jsonString, Class&lt;T&gt; classType)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectMapper.readValue(jsonString, classType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">string2List</span><span class="params">(String jsonString, Class&lt;T&gt; valueClassType)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectMapper.readValue(jsonString, objectMapper.getTypeFactory().constructParametricType(ArrayList.class, valueClassType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;json型字符串取值&quot;&gt;&lt;a href=&quot;#json型字符串取值&quot; class=&quot;headerlink&quot; title=&quot;json型字符串取值&quot;&gt;&lt;/a&gt;json型字符串取值&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>工具类HttpClientUtil</title>
    <link href="http://yoursite.com/2018/11/25/%E5%B7%A5%E5%85%B7%E7%B1%BBHttpClientUtil/"/>
    <id>http://yoursite.com/2018/11/25/工具类HttpClientUtil/</id>
    <published>2018-11-25T02:45:47.000Z</published>
    <updated>2019-01-21T11:55:39.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HttpClientUtil"><a href="#HttpClientUtil" class="headerlink" title="HttpClientUtil"></a>HttpClientUtil</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jinbei.common.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.NameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.ClientProtocolException;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity.UrlEncodedFormEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.utils.URIBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message.BasicNameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: UnifiedBgManage</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: HttpClient工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: WYuyin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-11-22 13:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CloseableHttpClient client = HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url, Map&lt;String, String&gt; param,Map&lt;String,String&gt; headers)</span> </span>&#123;</span><br><span class="line">        String resultString = <span class="string">""</span>;</span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URIBuilder uri = <span class="keyword">new</span> URIBuilder(url);</span><br><span class="line">                <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                        uri.addParameter(key, param.get(key));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            HttpGet get = <span class="keyword">new</span> HttpGet(uri.build());</span><br><span class="line">                <span class="keyword">if</span> (headers != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (String key :headers.keySet()) &#123;</span><br><span class="line">                        get.setHeader(key,headers.get(key));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                response = client.execute(get);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>)&#123;</span><br><span class="line">                    resultString = EntityUtils.toString(response.getEntity(), <span class="string">"UTF-8"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (response != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    response.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doGet(url,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url, Map&lt;String, String&gt; param)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doGet(url,param,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, Map&lt;String, String&gt; param,Map&lt;String,String&gt; headers)</span></span>&#123;</span><br><span class="line">        String resultString = <span class="string">""</span>;</span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span>)&#123;</span><br><span class="line">                List&lt;NameValuePair&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">                    paramList.add(<span class="keyword">new</span> BasicNameValuePair(key, param.get(key)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 模拟表单</span></span><br><span class="line">                UrlEncodedFormEntity entity = <span class="keyword">new</span> UrlEncodedFormEntity(paramList,<span class="string">"utf-8"</span>);</span><br><span class="line">                httpPost.setEntity(entity);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (headers != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (String key :headers.keySet()) &#123;</span><br><span class="line">                    httpPost.setHeader(key,headers.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            response = client.execute(httpPost);</span><br><span class="line">            resultString = EntityUtils.toString(response.getEntity(),<span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, Map&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doPost(url,param,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doPost(url,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好使用doPost，doGet不太安全</p><h3 id="HttpClient的精简用法"><a href="#HttpClient的精简用法" class="headerlink" title="HttpClient的精简用法"></a>HttpClient的精简用法</h3><p>之前学习了HttpClient的用法，也自己包了一个工具类，前两天看了大佬的代码，</p><p><img src="/2018/11/25/工具类HttpClientUtil/C:/Users\Administrator\AppData\Roaming\Typora\typora-user-images\1546915517113.png" alt="1546915517113"></p><p>我称其为HttpClient的精简用法吧，这省了很多事情，起码自己不用去归纳一套流程了，熟练了也是非常方便的，而且还适应了各种情景：加请求头，参数，编码，timeout时间，真的是非常便捷了，emm 请忽略我截图里面多了一个bodyForm的操作。</p><p>改响应数据编码为utf-8我找了好久，最后就在自动显示的所有方法里看到有个加Charset参数的，开心(<em>^▽^</em>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HttpClientUtil&quot;&gt;&lt;a href=&quot;#HttpClientUtil&quot; class=&quot;headerlink&quot; title=&quot;HttpClientUtil&quot;&gt;&lt;/a&gt;HttpClientUtil&lt;/h2&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>@Transactional</title>
    <link href="http://yoursite.com/2018/11/25/Transactional/"/>
    <id>http://yoursite.com/2018/11/25/Transactional/</id>
    <published>2018-11-25T02:43:24.000Z</published>
    <updated>2019-01-21T09:29:44.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h2><p>标注在方法上可以实现一个事务</p><p>Spring事务管理有编程式和声明式两种，前者通过编码方式，后者基于AOP，代码逻辑不受污染，使用的也较多。声明式事务有两种实现方式，一种是在xml里做相关声明，另一种就是用@Transactional。</p><p>但使用时，若在同一个类中，若其中的方法1调用了方法2，且两者都被标注了@Transactional则只被看成一个事务，方法2不会被Spring的事务拦截器拦截，解决方法可以分两个类写或者用AspectJ取代AOP，但我没有做验证。</p><p>另外该注解可以有属性值</p><p><strong>value/transactionManager</strong></p><p>这两个是一个意思，指定事务的名字</p><p><strong>propagation</strong></p><p>可选的值有：</p><p>Propagation.REQUIRED</p><p>如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。</p><p>Propagation.SUPPORTS</p><p>如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</p><p>Propagation.MANDATORY</p><p>如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</p><p>Propagation.REQUIRES_NEW</p><p>重新创建一个新的事务，如果当前存在事务，暂停当前的事务。</p><p>Propagation.NOT_SUPPORTED</p><p>以非事务的方式运行，如果当前存在事务，暂停当前的事务。</p><p>Propagation.NEVER</p><p>以非事务的方式运行，如果当前存在事务，则抛出异常。</p><p>Propagation.NESTED</p><p>和 Propagation.REQUIRED 效果一样。</p><p><strong>isolation</strong></p><p>事务的隔离级别</p><p>还有一些感觉不太会用到吧不多啰嗦了用到再查</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Transactional&quot;&gt;&lt;a href=&quot;#Transactional&quot; class=&quot;headerlink&quot; title=&quot;@Transactional&quot;&gt;&lt;/a&gt;@Transactional&lt;/h2&gt;&lt;p&gt;标注在方法上可以实现一个事务&lt;/p&gt;
&lt;p&gt;Sp
      
    
    </summary>
    
      <category term="spring boot" scheme="http://yoursite.com/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo入门</title>
    <link href="http://yoursite.com/2018/11/25/Dubbo%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/11/25/Dubbo入门/</id>
    <published>2018-11-25T02:41:53.000Z</published>
    <updated>2019-03-03T02:40:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dubbo是什么"><a href="#Dubbo是什么" class="headerlink" title="Dubbo是什么"></a>Dubbo是什么</h2><p>Dubbo是：</p><ul><li>一款分布式服务框架</li><li>高性能和透明化的RPC远程服务调用方案</li><li>SOA服务治理方案</li></ul><h2 id="Dubbo角色说明"><a href="#Dubbo角色说明" class="headerlink" title="Dubbo角色说明"></a>Dubbo角色说明</h2><p><strong>Provider</strong>: 暴露服务的服务提供方。<br><strong>Consumer</strong>: 调用远程服务的服务消费方。<br><strong>Registry</strong>: 服务注册与发现的注册中心。<br><strong>Monitor</strong>: 统计服务的调用次数和调用时间的监控中心。</p><h2 id="Dubbo注册中心"><a href="#Dubbo注册中心" class="headerlink" title="Dubbo注册中心"></a>Dubbo注册中心</h2><p>你可能兼备服务方与消费方，通过将服务统一管理，来有效的优化对服务发布/使用的流程，<strong>Dubbo提供的注册中心有如下几种类型可供选择</strong>：</p><ul><li>Multicast注册中心</li><li>Zookeeper注册中心</li><li>Redis注册中心</li><li>Simple注册中心</li></ul><h2 id="Dubbo优缺点"><a href="#Dubbo优缺点" class="headerlink" title="Dubbo优缺点"></a>Dubbo优缺点</h2><p>优点：</p><p>1.透明化的远程方法调用 </p><p>​    像调用本地方法一样调用远程方法；只需简单配置，没有任何API侵入。</p><p>2.软负载均衡及容错机制<br>​    可在内网替代nginx lvs等硬件负载均衡器。</p><p>3.服务注册中心自动注册 &amp; 配置管理<br>​    不需要写死服务提供者地址，注册中心基于接口名自动查询提供者ip。<br>​    使用类似zookeeper等分布式协调服务作为服务注册中心，可以将绝大部分项        目配置移入zookeeper集群。</p><p>4.服务接口监控与治理<br>​    Dubbo-admin与Dubbo-monitor提供了完善的服务接口管理与监控功能，针对不同应用的不同接口，可以进行 多版本，多协议，多注册中心管理。</p><p>缺点：</p><p>只支持JAVA语言</p><h2 id="Demo-Zookeeper"><a href="#Demo-Zookeeper" class="headerlink" title="Demo-Zookeeper"></a>Demo-Zookeeper</h2><p><a href="https://blog.csdn.net/hellozpc/article/details/78575773" target="_blank" rel="noopener">https://blog.csdn.net/hellozpc/article/details/78575773</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dubbo是什么&quot;&gt;&lt;a href=&quot;#Dubbo是什么&quot; class=&quot;headerlink&quot; title=&quot;Dubbo是什么&quot;&gt;&lt;/a&gt;Dubbo是什么&lt;/h2&gt;&lt;p&gt;Dubbo是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一款分布式服务框架&lt;/li&gt;
&lt;li&gt;高性能和透明
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>ehcache</title>
    <link href="http://yoursite.com/2018/11/04/ehcache/"/>
    <id>http://yoursite.com/2018/11/04/ehcache/</id>
    <published>2018-11-04T09:09:42.000Z</published>
    <updated>2019-01-21T09:27:09.116Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<a href="https://blog.csdn.net/vbirdbest/article/details/72763048" target="_blank" rel="noopener">https://blog.csdn.net/vbirdbest/article/details/72763048</a></p><h4 id="ehcache与redis比较"><a href="#ehcache与redis比较" class="headerlink" title="ehcache与redis比较"></a>ehcache与redis比较</h4><ul><li>ehcache通常和redis一块使用</li><li>ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。</li><li>redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多， 处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。</li></ul><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>1.pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--EhCache--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.增加配置，可以再resource文件夹下增加</p><p>默认情况下Ehcache会自动加载classpath根目录下名为ehcache.xml文件，也可以将该文件放到其他地方在使用时指定文件的位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"http://ehcache.org/ehcache.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 磁盘缓存位置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir/ehcache"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 默认缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxEntriesLocalDisk</span>=<span class="string">"10000000"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence</span> <span class="attr">strategy</span>=<span class="string">"localTempSwap"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- helloworld缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"HelloWorldCache"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToIdleSeconds</span>=<span class="string">"5"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToLiveSeconds</span>=<span class="string">"5"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以直接写在文件里，Ehcacheconfig.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EhCacheConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ehCacheManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CacheConfiguration cacheConfig = <span class="keyword">new</span> CacheConfiguration();</span><br><span class="line">        cacheConfig.setName(<span class="string">"course"</span>);</span><br><span class="line">        cacheConfig.setMemoryStoreEvictionPolicy(<span class="string">"LRU"</span>);</span><br><span class="line">        cacheConfig.setMaxEntriesLocalHeap(<span class="number">1000</span>);</span><br><span class="line">        cacheConfig.setEternal(<span class="keyword">true</span>);</span><br><span class="line">        net.sf.ehcache.config.Configuration config = <span class="keyword">new</span> net.sf.ehcache.config.Configuration();</span><br><span class="line">        config.addCache(cacheConfig);</span><br><span class="line">        CacheManager cacheManager = CacheManager.newInstance(config);</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.这里对cache做简单的封装：</p><p>先对Cache api做下了解，</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>add(request)</td><td>添加一个请求到缓存</td></tr><tr><td>addAll(List requesets)</td><td>添加一系列请求到缓存</td></tr><tr><td>delete(request,[oprions])</td><td>options可选择如何处理匹配的缓存，有ignoreSearch、ignoreMethod、ignoreVary</td></tr><tr><td>keys(request,[options])</td><td>参数和delete一样，该方法返回一个Promise，即一个Cache键的数组</td></tr><tr><td>match(request,[options])</td><td>request为想要在cache中查找的Promise对象</td></tr><tr><td>matchAll(List requests,[options])</td><td>同上</td></tr><tr><td>put(request,response)</td><td>允许将键值对存到当前缓存</td></tr></tbody></table><hr><p>工具类-EhCacheService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EhCacheService</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建缓存管理器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CacheManager cacheManager = EhCacheConfig.cacheManager();</span><br><span class="line"><span class="comment">//缓存对象</span></span><br><span class="line">    <span class="keyword">private</span> Cache cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EhCacheService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = cacheManager.getCache(<span class="string">"course"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>   获取 ehCache value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCache</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//获取cache中的元素</span></span><br><span class="line">        Element element = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(element == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object object = element.getObjectValue();</span><br><span class="line">        <span class="comment">//转成jsonObject，json-&gt;value,result-&gt;key&amp;value(json)</span></span><br><span class="line">        JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        JSONObject json = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(object != <span class="keyword">null</span>)&#123;</span><br><span class="line">            json = JSONObject.parseObject(object.toString());</span><br><span class="line">            result.put(Contants.TYPE,key);</span><br><span class="line">            result.put(Contants.DATA,json);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>   添加 chCache</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCache</span><span class="params">(String key,String data)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Element element = <span class="keyword">new</span> Element(key,data);</span><br><span class="line">        cache.put(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>   获取cache中所有的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getCacheAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        List&lt;String&gt; keys = cache.getKeys();</span><br><span class="line">        Map&lt;Object, Element&gt; elements = cache.getAll(keys);</span><br><span class="line">        <span class="keyword">for</span> (String key: keys) &#123;</span><br><span class="line">            Element element = elements.get(key);</span><br><span class="line">            JSONObject result = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            <span class="keyword">if</span>(element != <span class="keyword">null</span>)&#123;</span><br><span class="line">                Object object = element.getObjectValue();</span><br><span class="line">                <span class="keyword">if</span>(object != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    JSONObject json = JSONObject.parseObject(object.toString());</span><br><span class="line">                    result.put(Contants.TYPE,key);</span><br><span class="line">                    result.put(Contants.DATA,json);</span><br><span class="line">                    list.add(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>   删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeCache</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>   批量添加缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCacheList</span><span class="params">(List&lt;Element&gt; elements)</span></span>&#123;</span><br><span class="line">        cache.putAll(elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><p>这里拿一个现成的redisConsumer的例子来使用ehcache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * activemq 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(ActiveMqConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EhCacheService ehCacheService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Sub</span></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"$&#123;activemq.topic&#125;"</span> , containerFactory = <span class="string">"topicListenerFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(TextMessage text)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"subscribe : "</span>+ text.getText());</span><br><span class="line">            <span class="keyword">if</span>(text != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//只获取其中的type、data和操作符command</span></span><br><span class="line">                JSONObject json = JSONObject.parseObject(text.getText());</span><br><span class="line">                String key = json.getString(Contants.TYPE);</span><br><span class="line">                String data = json.getString(Contants.DATA);</span><br><span class="line">                String command = json.getString(Contants.COMMAND);</span><br><span class="line">                <span class="keyword">switch</span> (command)&#123;</span><br><span class="line">                    <span class="keyword">case</span> Contants.ADD:</span><br><span class="line">                        <span class="comment">//将消息数据存入ehcache</span></span><br><span class="line">                        ehCacheService.addCache(key,data);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Contants.UPDATE:</span><br><span class="line">                        ehCacheService.addCache(key,data);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Contants.DELETE:</span><br><span class="line">                        ehCacheService.removeCache(key);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        logger.info(<span class="string">"method is not found ..... command:"</span>+command);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"JSM订阅解析异常!  :"</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考链接：&lt;a href=&quot;https://blog.csdn.net/vbirdbest/article/details/72763048&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/vbirdbest/ar
      
    
    </summary>
    
      <category term="缓存" scheme="http://yoursite.com/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="ehcache" scheme="http://yoursite.com/tags/ehcache/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>redis入门与springboot集成</title>
    <link href="http://yoursite.com/2018/11/04/redis%E5%85%A5%E9%97%A8%E4%B8%8Espringboot%E9%9B%86%E6%88%90/"/>
    <id>http://yoursite.com/2018/11/04/redis入门与springboot集成/</id>
    <published>2018-11-04T09:07:58.000Z</published>
    <updated>2019-01-21T09:28:59.012Z</updated>
    
    <content type="html"><![CDATA[<p>安装与客户端的使用：<a href="https://blog.csdn.net/qq_35038153/article/details/79675728" target="_blank" rel="noopener">https://blog.csdn.net/qq_35038153/article/details/79675728</a></p><p>其他参考链接：<a href="https://www.jianshu.com/p/7bf5dc61ca06/" target="_blank" rel="noopener">https://www.jianshu.com/p/7bf5dc61ca06/</a></p><p><a href="https://blog.csdn.net/w501631338/article/details/73555908" target="_blank" rel="noopener">https://blog.csdn.net/w501631338/article/details/73555908</a></p><p>Redis五大类型:字符串（String）、哈希/散列/字典（Hash）、列表（List）、集合（Set）、有序集合（sorted set）</p><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td>String</td><td>可以是字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作；对象和浮点数执行自增(increment)或者自减(decrement)</td></tr><tr><td>List</td><td>一个链表，链表上的每个节点都包含了一个字符串</td><td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或者多个元素；根据值来查找或者移除元素</td></tr><tr><td>Set</td><td>包含字符串的无序收集器(unorderedcollection)，并且被包含的每个字符串都是独一无二的、各不相同</td><td>添加、获取、移除单个元素；检查一个元素是否存在于某个集合中；计算交集、并集、差集；从集合里卖弄随机获取元素</td></tr><tr><td>Hash</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；获取所有键值对</td></tr><tr><td>Zset(有序的Set)</td><td>字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定</td><td>添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素</td></tr></tbody></table><p><strong>其中String和Hash用的较多。</strong><a href="http://www.runoob.com/redis/redis-commands.html" target="_blank" rel="noopener">redis api命令</a></p><p>Spring 封装了<strong>RedisTemplate</strong>来进行对redis的各种操作，支持所有redis原生的api</p><h4 id="redisTemplate"><a href="#redisTemplate" class="headerlink" title="redisTemplate"></a>redisTemplate</h4><p>Controller:@Resource RedisTemplate&lt;String, String&gt; redisTemplate;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue();<span class="comment">//操作字符串</span></span><br><span class="line">redisTemplate.opsForHash();<span class="comment">//操作hash</span></span><br><span class="line">redisTemplate.opsForList();<span class="comment">//操作list</span></span><br><span class="line">redisTemplate.opsForSet();<span class="comment">//操作set</span></span><br><span class="line">redisTemplate.opsForZSet();<span class="comment">//操作有序set</span></span><br><span class="line"><span class="comment">//redisTemplate的超时设置</span></span><br><span class="line">redisTemplate.expire((key,timeout,timeunit)<span class="comment">//timeout:key的生存时间，timeunit：时间单位（小时，分钟，秒…)(TimeUnit.SECONDS)</span></span><br><span class="line">redisTemplate.getExpire(key, [timeunit])<span class="comment">//获得超时时间</span></span><br><span class="line"><span class="comment">//注意：以上设置超时的方法只适用于key对应的值不再更新的问题，set方法会丢失key的生存时间，忽略而变为永久。</span></span><br><span class="line">redisTemplate.delete(key)<span class="comment">//redis的String删除操作</span></span><br><span class="line">redisTemplate.set(key,value,[timeout],[timeunit])<span class="comment">//redis的String添加操作，但不推荐，最好结合opsForValue()对字符串操作</span></span><br></pre></td></tr></table></figure><p><strong>注意：如果使用RedisTemplate需要更改序列化方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RedisSerializer&lt;String&gt; stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        template.setKeySerializer(stringSerializer );</span><br><span class="line">        template.setValueSerializer(stringSerializer );</span><br><span class="line">        template.setHashKeySerializer(stringSerializer );</span><br><span class="line">        template.setHashValueSerializer(stringSerializer );</span><br></pre></td></tr></table></figure><h4 id="StringRedisTemplate（Redis的String数据结构）"><a href="#StringRedisTemplate（Redis的String数据结构）" class="headerlink" title="StringRedisTemplate（Redis的String数据结构）"></a>StringRedisTemplate（Redis的String数据结构）</h4><p>StringRedisTemplate（推荐使用）与RedisTemplate的区别：</p><ul><li><p>StringRedisTemplate继承RedisTemplate</p></li><li><p>两者数据不可通，可以看做两种数据类型</p></li><li><p>SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。</p><p>StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。</p><p>RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</p></li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String:</span><br><span class="line"><span class="number">1</span>.redisTemplate.opsForValue().set(key,value)); </span><br><span class="line"><span class="number">2</span>.redisTemplate.opsForValue().get(key)); </span><br><span class="line"><span class="number">3</span>.redisTemplate.opsForValue().get(key, start, end);</span><br><span class="line"><span class="number">4</span>.redisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line"><span class="number">5</span>.redisTemplate.opsForValue().getBit(key, offset);</span><br><span class="line"><span class="number">6</span>.redisTemplate.opsForValue().multiGet(keys);</span><br><span class="line"><span class="number">7</span>.redisTemplate.opsForValue().setBit(key, offset, value);<span class="comment">//通过ascii码设置String</span></span><br><span class="line"><span class="number">8</span>.redisTemplate.opsForValue().set(K key, V value, <span class="keyword">long</span> timeout, TimeUnit unit);<span class="comment">//详见下</span></span><br><span class="line"><span class="number">9</span>.redisTemplate.opsForValue().setIfAbsent(key, value);<span class="comment">//详见下</span></span><br><span class="line"><span class="number">10</span>.redisTemplate.opsForValue().set(K key, V value, <span class="keyword">long</span> offset);<span class="comment">//详见下</span></span><br><span class="line"><span class="number">11</span>.redisTemplate.opsForValue().size(key));</span><br><span class="line"><span class="number">12</span>.redisTemplate.opsForValue().multiGet(Collection&lt;K&gt; keys);</span><br><span class="line"><span class="number">13</span>.redisTemplate.opsForValue().multiSetIfAbsent(Map&lt;? extends K, ? extends V&gt; m);</span><br><span class="line"><span class="number">14</span>.同<span class="number">8</span></span><br><span class="line"><span class="number">15</span>\<span class="number">16</span>\<span class="number">17</span>\<span class="number">18</span>\<span class="number">19</span>.redisTemplate.opsForValue().increment(K key, <span class="keyword">long</span> delta);或.increment(K key, <span class="keyword">double</span> delta);</span><br><span class="line"><span class="number">20</span>.redisTemplate.opsForValue().append(key, value);<span class="comment">//在key键对应值的右面追加值value</span></span><br><span class="line"><span class="number">21</span>.redisTemplate.opsForValue().getOperations().delete(key);<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><ul><li>8.redisTemplate.opsForValue().set(K key, V value, long timeout, TimeUnit unit);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用：redisTemplate.opsForValue().set(<span class="string">"name"</span>,<span class="string">"tom"</span>,<span class="number">10</span>, TimeUnit.SECONDS); </span><br><span class="line">结果：redisTemplate.opsForValue().get(<span class="string">"name"</span>)<span class="comment">//由于设置的是10秒失效，十秒之内查询有结果，十秒之后返回为null</span></span><br></pre></td></tr></table></figure><ul><li>9.redisTemplate.opsForValue().setIfAbsent(key, value);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用：System.out.println(redisTemplate.opsForValue().setIfAbsent(<span class="string">"multi1"</span>,<span class="string">"multi1"</span>));<span class="comment">//false  multi1之前已经存在</span></span><br><span class="line">       System.out.println(redisTemplate.opsForValue().setIfAbsent(<span class="string">"multi111"</span>,<span class="string">"multi111"</span>));<span class="comment">//true  multi111之前不存在</span></span><br><span class="line">结果：<span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><ul><li><p>10.redisTemplate.opsForValue().set(K key, V value, long offset);</p><p>该方法是用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用：redisTemplate.opsForValue().set(<span class="string">"key"</span>,<span class="string">"hello world"</span>);</span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">"key"</span>,<span class="string">"redis"</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">"********"</span>+redisTemplate.opsForValue().get(<span class="string">"key"</span>));</span><br><span class="line">结果：********hello redis</span><br></pre></td></tr></table></figure><ul><li>6.redisTemplate.opsForValue().multiGet(keys);</li><li>12.redisTemplate.opsForValue().multiGet(Collection<k> keys);</k></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用：Map&lt;String,String&gt; maps = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        maps.put(<span class="string">"multi1"</span>,<span class="string">"multi1"</span>);</span><br><span class="line">        maps.put(<span class="string">"multi2"</span>,<span class="string">"multi2"</span>);</span><br><span class="line">        maps.put(<span class="string">"multi3"</span>,<span class="string">"multi3"</span>);</span><br><span class="line">        redisTemplate.opsForValue().multiSet(maps);</span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        keys.add(<span class="string">"multi1"</span>);</span><br><span class="line">        keys.add(<span class="string">"multi2"</span>);</span><br><span class="line">        keys.add(<span class="string">"multi3"</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().multiGet(keys));</span><br><span class="line">结果：[multi1, multi2, multi3]</span><br></pre></td></tr></table></figure><ul><li><p>redisTemplate.opsForValue().increment(K key, long delta)</p></li><li><p>redisTemplate.opsForValue().increment(K key, double delta)</p><p>原子递增</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().increment(key,<span class="number">1</span>)<span class="comment">//1</span></span><br><span class="line">redisTemplate.opsForValue().increment(key,<span class="number">1.2</span>) <span class="comment">//2.2</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>编号</th><th>命令</th><th>描述说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.yiibai.com/redis/strings_set.html" target="_blank" rel="noopener">SET key value</a></td><td>此命令设置指定键的值。</td></tr><tr><td>2</td><td><a href="http://www.yiibai.com/redis/strings_get.html" target="_blank" rel="noopener">GET key</a></td><td>获取指定键的值。</td></tr><tr><td>3</td><td><a href="http://www.yiibai.com/redis/strings_getrange.html" target="_blank" rel="noopener">GETRANGE key start end</a></td><td>获取存储在键上的字符串的子字符串。</td></tr><tr><td>4</td><td><a href="http://www.yiibai.com/redis/strings_getset.html" target="_blank" rel="noopener">GETSET key value</a></td><td>设置键的字符串值并返回其旧值。</td></tr><tr><td>5</td><td><a href="http://www.yiibai.com/redis/strings_getbit.html" target="_blank" rel="noopener">GETBIT key offset</a></td><td>返回在键处存储的字符串值中偏移处的位值。</td></tr><tr><td>6</td><td><a href="http://www.yiibai.com/redis/strings_mget.html" target="_blank" rel="noopener">MGET key1 [key2..]</a></td><td>获取所有给定键的值</td></tr><tr><td>7</td><td><a href="http://www.yiibai.com/redis/strings_setbit.html" target="_blank" rel="noopener">SETBIT key offset value</a></td><td>存储在键上的字符串值中设置或清除偏移处的位</td></tr><tr><td>8</td><td><a href="http://www.yiibai.com/redis/strings_setex.html" target="_blank" rel="noopener">SETEX key seconds value</a></td><td>使用键和到期时间来设置值</td></tr><tr><td>9</td><td><a href="http://www.yiibai.com/redis/strings_setnx.html" target="_blank" rel="noopener">SETNX key value</a></td><td>设置键的值，仅当键不存在时</td></tr><tr><td>10</td><td><a href="http://www.yiibai.com/redis/strings_setrange.html" target="_blank" rel="noopener">SETRANGE key offset value</a></td><td>在指定偏移处开始的键处覆盖字符串的一部分</td></tr><tr><td>11</td><td><a href="http://www.yiibai.com/redis/strings_strlen.html" target="_blank" rel="noopener">STRLEN key</a></td><td>获取存储在键中的值的长度</td></tr><tr><td>12</td><td><a href="http://www.yiibai.com/redis/strings_mset.html" target="_blank" rel="noopener">MSET key value [key value …]</a></td><td>为多个键分别设置它们的值</td></tr><tr><td>13</td><td><a href="http://www.yiibai.com/redis/strings_msetnx.html" target="_blank" rel="noopener">MSETNX key value [key value …]</a></td><td>为多个键分别设置它们的值，仅当键不存在时</td></tr><tr><td>14</td><td><a href="http://www.yiibai.com/redis/strings_psetex.html" target="_blank" rel="noopener">PSETEX key milliseconds value</a></td><td>设置键的值和到期时间(以毫秒为单位)</td></tr><tr><td>15</td><td><a href="http://www.yiibai.com/redis/strings_incr.html" target="_blank" rel="noopener">INCR key</a></td><td>将键的整数值增加<code>1</code></td></tr><tr><td>16</td><td><a href="http://www.yiibai.com/redis/strings_incrby.html" target="_blank" rel="noopener">INCRBY key increment</a></td><td>将键的整数值按给定的数值增加</td></tr><tr><td>17</td><td><a href="http://www.yiibai.com/redis/strings_incrbyfloat.html" target="_blank" rel="noopener">INCRBYFLOAT key increment</a></td><td>将键的浮点值按给定的数值增加</td></tr><tr><td>18</td><td><a href="http://www.yiibai.com/redis/strings_decr.html" target="_blank" rel="noopener">DECR key</a></td><td>将键的整数值减<code>1</code></td></tr><tr><td>19</td><td><a href="http://www.yiibai.com/redis/strings_decrby.html" target="_blank" rel="noopener">DECRBY key decrement</a></td><td>按给定数值减少键的整数值</td></tr><tr><td>20</td><td><a href="http://www.yiibai.com/redis/strings_append.html" target="_blank" rel="noopener">APPEND key value</a></td><td>将指定值附加到键</td></tr></tbody></table><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Hash:</span><br><span class="line"><span class="number">1</span>.redisTemplate.opsForHash().delete(H key, Object... hashKeys);<span class="comment">//...表示可以传入多个map的key，用，隔开。或用数组传值</span></span><br><span class="line"><span class="number">2</span>.redisTemplate.opsForHash().hasKey(key, hashKey)；</span><br><span class="line"><span class="number">3</span>.redisTemplate.opsForHash().get(key, hashKey)；</span><br><span class="line"><span class="number">4</span>.redisTemplate.opsForHash().entries(key);<span class="comment">//返回map集合</span></span><br><span class="line"><span class="number">5</span>、<span class="number">6</span>.redisTemplate.opsForHash().increment(H key, HK hashKey, <span class="keyword">long</span> delta);<span class="comment">//或increment(H key, HK hashKey, double delta);；</span></span><br><span class="line"><span class="number">7</span>.redisTemplate.opsForHash().keys(key)；<span class="comment">//返回map的key集合Set</span></span><br><span class="line"><span class="number">8</span>.redisTemplate.opsForHash().size(key)；</span><br><span class="line"><span class="number">9</span>.redisTemplate.opsForHash().multiGet(H key, Collection&lt;HK&gt; hashKeys);</span><br><span class="line"><span class="number">10</span>.redisTemplate.opsForHash().putAll(H key, Map&lt;? extends HK, ? extends HV&gt; m)；</span><br><span class="line"><span class="number">11</span>.redisTemplate.opsForHash().put(key, hashKey, value);</span><br><span class="line"><span class="number">12</span>.redisTemplate.opsForHash().putIfAbsent(key, hashKey, value)；</span><br><span class="line"><span class="number">13</span>.redisTemplate.opsForHash().values(key);<span class="comment">//返回map中的value集合List；</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.yiibai.com/redis/hashes_hdel.html" target="_blank" rel="noopener">HDEL key field2 [field2]</a></td><td>删除一个或多个哈希字段。</td></tr><tr><td>2</td><td><a href="http://www.yiibai.com/redis/hashes_hexists.html" target="_blank" rel="noopener">HEXISTS key field</a></td><td>判断是否存在散列字段。</td></tr><tr><td>3</td><td><a href="http://www.yiibai.com/redis/hashes_hget.html" target="_blank" rel="noopener">HGET key field</a></td><td>获取存储在指定键的哈希字段的值。</td></tr><tr><td>4</td><td><a href="http://www.yiibai.com/redis/hashes_hgetall.html" target="_blank" rel="noopener">HGETALL key</a></td><td>获取存储在指定键的哈希中的所有字段和值</td></tr><tr><td>5</td><td><a href="http://www.yiibai.com/redis/hashes_hincrby.html" target="_blank" rel="noopener">HINCRBY key field increment</a></td><td>将哈希字段的整数值按给定数字增加</td></tr><tr><td>6</td><td><a href="http://www.yiibai.com/redis/hashes_hincrbyfloat.html" target="_blank" rel="noopener">HINCRBYFLOAT key field increment</a></td><td>将哈希字段的浮点值按给定数值增加</td></tr><tr><td>7</td><td><a href="http://www.yiibai.com/redis/hashes_hkeys.html" target="_blank" rel="noopener">HKEYS key</a></td><td>获取哈希中的所有字段</td></tr><tr><td>8</td><td><a href="http://www.yiibai.com/redis/hashes_hlen.html" target="_blank" rel="noopener">HLEN key</a></td><td>获取散列中的字段数量</td></tr><tr><td>9</td><td><a href="http://www.yiibai.com/redis/hashes_hmget.html" target="_blank" rel="noopener">HMGET key field1 [field2]</a></td><td>获取所有给定哈希字段的值</td></tr><tr><td>10</td><td><a href="http://www.yiibai.com/redis/hashes_hmset.html" target="_blank" rel="noopener">HMSET key field1 value1 [field2 value2 ]</a></td><td>为多个哈希字段分别设置它们的值</td></tr><tr><td>11</td><td><a href="http://www.yiibai.com/redis/hashes_hset.html" target="_blank" rel="noopener">HSET key field value</a></td><td>设置散列字段的字符串值</td></tr><tr><td>12</td><td><a href="http://www.yiibai.com/redis/hashes_hsetnx.html" target="_blank" rel="noopener">HSETNX key field value</a></td><td>仅当字段不存在时，才设置散列字段的值</td></tr><tr><td>13</td><td><a href="http://www.yiibai.com/redis/hashes_hvals.html" target="_blank" rel="noopener">HVALS key</a></td><td>获取哈希中的所有值</td></tr></tbody></table><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List：</span><br><span class="line"></span><br><span class="line">redisTemplate.opsForList().leftPush(key, value);<span class="comment">//从左向右存压栈</span></span><br><span class="line">redisTemplate.opsForList().leftPop(key);<span class="comment">//从左出栈</span></span><br><span class="line">redisTemplate.opsForList().size(key);<span class="comment">//队/栈长</span></span><br><span class="line">redisTemplate.opsForList().range(key, start, end);<span class="comment">//范围检索,返回List</span></span><br><span class="line">redisTemplate.opsForList().remove(key, i, value);<span class="comment">//移除key中值为value的i个,返回删除的个数；如果没有这个元素则返回0 </span></span><br><span class="line">redisTemplate.opsForList().index(key, index);<span class="comment">//检索</span></span><br><span class="line">redisTemplate.opsForList().set(key, index, value);<span class="comment">//赋值</span></span><br><span class="line">redisTemplate.opsForList().trim(key, start, end);<span class="comment">//裁剪,void,删除除了[start,end]以外的所有元素  </span></span><br><span class="line">redisTemplate.opsForList().rightPopAndLeftPush(String sourceKey, String destinationKey);<span class="comment">//将源key的队列的右边的一个值删除，然后塞入目标key的队列的左边，返回这个值</span></span><br><span class="line">注意:要缓存的对象必须实现Serializable接口,因为 Spring 会将对象先序列化再存入 Redis,否则报异常nested exception is java.lang.IllegalArgumentException: DefaultSerializer <span class="keyword">requires</span> a Serializable……</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.yiibai.com/redis/lists_blpop.html" target="_blank" rel="noopener">BLPOP key1 [key2 ] timeout</a></td><td>删除并获取列表中的第一个元素，或阻塞，直到有一个元素可用</td></tr><tr><td>2</td><td><a href="http://www.yiibai.com/redis/lists_brpop.html" target="_blank" rel="noopener">BRPOP key1 [key2 ] timeout</a></td><td>删除并获取列表中的最后一个元素，或阻塞，直到有一个元素可用</td></tr><tr><td>3</td><td><a href="http://www.yiibai.com/redis/lists_brpoplpush.html" target="_blank" rel="noopener">BRPOPLPUSH source destination timeout</a></td><td>从列表中弹出值，将其推送到另一个列表并返回它; 或阻塞，直到一个可用</td></tr><tr><td>4</td><td><a href="http://www.yiibai.com/redis/lists_lindex.html" target="_blank" rel="noopener">LINDEX key index</a></td><td>通过其索引从列表获取元素</td></tr><tr><td>5</td><td><a href="http://www.yiibai.com/redis/lists_linsert.html" target="_blank" rel="noopener">LINSERT key BEFORE/AFTER pivot value</a></td><td>在列表中的另一个元素之前或之后插入元素</td></tr><tr><td>6</td><td><a href="http://www.yiibai.com/redis/lists_llen.html" target="_blank" rel="noopener">LLEN key</a></td><td>获取列表的长度</td></tr><tr><td>7</td><td><a href="http://www.yiibai.com/redis/lists_lpop.html" target="_blank" rel="noopener">LPOP key</a></td><td>删除并获取列表中的第一个元素</td></tr><tr><td>8</td><td><a href="http://www.yiibai.com/redis/lists_lpush.html" target="_blank" rel="noopener">LPUSH key value1 [value2]</a></td><td>将一个或多个值添加到列表</td></tr><tr><td>9</td><td><a href="http://www.yiibai.com/redis/lists_lpushx.html" target="_blank" rel="noopener">LPUSHX key value</a></td><td>仅当列表存在时，才向列表添加值</td></tr><tr><td>10</td><td><a href="http://www.yiibai.com/redis/lists_lrange.html" target="_blank" rel="noopener">LRANGE key start stop</a></td><td>从列表中获取一系列元素</td></tr><tr><td>11</td><td><a href="http://www.yiibai.com/redis/lists_lrem.html" target="_blank" rel="noopener">LREM key count value</a></td><td>从列表中删除元素</td></tr><tr><td>12</td><td><a href="http://www.yiibai.com/redis/lists_lset.html" target="_blank" rel="noopener">LSET key index value</a></td><td>通过索引在列表中设置元素的值</td></tr><tr><td>13</td><td><a href="http://www.yiibai.com/redis/lists_ltrim.html" target="_blank" rel="noopener">LTRIM key start stop</a></td><td>修剪列表的指定范围</td></tr><tr><td>14</td><td><a href="http://www.yiibai.com/redis/lists_rpop.html" target="_blank" rel="noopener">RPOP key</a></td><td>删除并获取列表中的最后一个元素</td></tr><tr><td>15</td><td><a href="http://www.yiibai.com/redis/lists_rpoplpush.html" target="_blank" rel="noopener">RPOPLPUSH source destination</a></td><td>删除列表中的最后一个元素，将其附加到另一个列表并返回</td></tr><tr><td>16</td><td><a href="http://www.yiibai.com/redis/lists_rpush.html" target="_blank" rel="noopener">RPUSH key value1 [value2]</a></td><td>将一个或多个值附加到列表</td></tr><tr><td>17</td><td><a href="http://www.yiibai.com/redis/lists_rpushx.html" target="_blank" rel="noopener">RPUSHX key value</a></td><td>仅当列表存在时才将值附加到列表</td></tr></tbody></table><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set：</span><br><span class="line">redisTemplate.opsForValue().getAndSet(key, value)</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.yiibai.com/redis/sets_sadd.html" target="_blank" rel="noopener">SADD key member1 [member2]</a></td><td>将一个或多个成员添加到集合</td></tr><tr><td>2</td><td><a href="http://www.yiibai.com/redis/sets_scard.html" target="_blank" rel="noopener">SCARD key</a></td><td>获取集合中的成员数</td></tr><tr><td>3</td><td><a href="http://www.yiibai.com/redis/sets_sdiff.html" target="_blank" rel="noopener">SDIFF key1 [key2]</a></td><td>减去多个集合</td></tr><tr><td>4</td><td><a href="http://www.yiibai.com/redis/sets_sdiffstore.html" target="_blank" rel="noopener">SDIFFSTORE destination key1 [key2]</a></td><td>减去多个集并将结果集存储在键中</td></tr><tr><td>5</td><td><a href="http://www.yiibai.com/redis/sets_sinter.html" target="_blank" rel="noopener">SINTER key1 [key2]</a></td><td>相交多个集合</td></tr><tr><td>6</td><td><a href="http://www.yiibai.com/redis/sets_sinterstore.html" target="_blank" rel="noopener">SINTERSTORE destination key1 [key2]</a></td><td>交叉多个集合并将结果集存储在键中</td></tr><tr><td>7</td><td><a href="http://www.yiibai.com/redis/sets_sismember.html" target="_blank" rel="noopener">SISMEMBER key member</a></td><td>判断确定给定值是否是集合的成员</td></tr><tr><td>8</td><td><a href="http://www.yiibai.com/redis/sets_smove.html" target="_blank" rel="noopener">SMOVE source destination member</a></td><td>将成员从一个集合移动到另一个集合</td></tr><tr><td>9</td><td><a href="http://www.yiibai.com/redis/sets_spop.html" target="_blank" rel="noopener">SPOP key</a></td><td>从集合中删除并返回随机成员</td></tr><tr><td>10</td><td><a href="http://www.yiibai.com/redis/sets_srandmember.html" target="_blank" rel="noopener">SRANDMEMBER key [count]</a></td><td>从集合中获取一个或多个随机成员</td></tr><tr><td>11</td><td><a href="http://www.yiibai.com/redis/sets_srem.html" target="_blank" rel="noopener">SREM key member1 [member2]</a></td><td>从集合中删除一个或多个成员</td></tr><tr><td>12</td><td><a href="http://www.yiibai.com/redis/sets_sunion.html" target="_blank" rel="noopener">SUNION key1 [key2]</a></td><td>添加多个集合</td></tr><tr><td>13</td><td><a href="http://www.yiibai.com/redis/sets_sunionstore.html" target="_blank" rel="noopener">SUNIONSTORE destination key1 [key2]</a></td><td>添加多个集并将结果集存储在键中</td></tr><tr><td>14</td><td><a href="http://www.yiibai.com/redis/sets_sscan.html" target="_blank" rel="noopener">SSCAN key cursor [MATCH pattern] [COUNT count]</a></td><td>递增地迭代集合中的元素</td></tr></tbody></table><h3 id="String…与String-的区别"><a href="#String…与String-的区别" class="headerlink" title="String…与String[]的区别"></a>String…与String[]的区别</h3><p>类型后面三个点(String…)，是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表，其语法就是类型后跟 <strong>…</strong>，表示此处接受的参数为<strong>0到多个</strong>Object类型的对象，或者是一个Object[]。所以如果你有了xxx(String… strs)就不能再有xxx(String[])，三个点的写法包含了第二种。</p><hr><p>2018/12/11更新</p><h2 id="spring-data-redis"><a href="#spring-data-redis" class="headerlink" title="spring-data-redis"></a>spring-data-redis</h2><p>​    上面介绍了StingRedisTemplate的一些基本方法，上周末喜提一个新的项目，(<em>^▽^</em>) 项目比之前的大，功能很多，而且创始者还不爱打注释！这真的让我非常头疼</p><p>​    好了回归主题，我看到代码里有一段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BoundHashOperations&lt;String, Object, Object&gt; <span class="title">hashOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stringRedisTemplate.boundHashOps(<span class="string">"sutSub"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    看到StringRedisTemplate有些熟悉，刚入职的时候学了，是Redis的String数据结构，boundHashOps()没见过啊，这其实是一个RedisTemplate的方法，而StringRedisTemplate继承自它，所以告诉我他与get()的区别？ </p><p>​    好像只是为了简化opsForValue()一步，好吧似乎真的只是这样而已，spring-data-redis提供了对key的“bound”便捷化API，为啥要用bound这个名字呢emmm… 可以通过bound封装指定的key操作redis里的数据，有</p><p>BoundValueOperations<br>BoundSetOperations<br>BoundListOperations<br>BoundSetOperations<br>BoundHashOperations</p><p>注意，这个spring-data-redis和put普通的spring-redis有一小点区别，jar包名字的区别…s一个叫spring-boot-data-redis，一个叫spring-boot-start-redis，都是基于Jedis的，所以其实没区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装与客户端的使用：&lt;a href=&quot;https://blog.csdn.net/qq_35038153/article/details/79675728&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_35
      
    
    </summary>
    
      <category term="Nosql" scheme="http://yoursite.com/categories/Nosql/"/>
    
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ</title>
    <link href="http://yoursite.com/2018/11/04/ActiveMQ/"/>
    <id>http://yoursite.com/2018/11/04/ActiveMQ/</id>
    <published>2018-11-04T08:54:04.000Z</published>
    <updated>2019-01-21T09:26:33.653Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>休息了大概一个礼拜，到一个新的单位重新开始，大佬列了很多新人技术清单，其中有很多只是听说过但没有学习和接触过，得赶紧学习啦，^-^</p><p>另外最近使用的是来自大傻逼推荐的一个md编辑器Typora，非常好看还带大纲，比markdownPad好用很多</p></blockquote><p>Activemq学习来源：<a href="https://www.cnblogs.com/cyfonly/p/6380860.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyfonly/p/6380860.html</a></p><p><a href="https://www.cnblogs.com/jaycekon/p/6225058.html" target="_blank" rel="noopener">https://www.cnblogs.com/jaycekon/p/6225058.html</a></p><p><a href="https://blog.csdn.net/Ouyzc/article/details/79643387" target="_blank" rel="noopener">https://blog.csdn.net/Ouyzc/article/details/79643387</a></p><p>首先了解我初步要学到的内容，理解JMS规范-理解点对点，发布订阅模式，理解生产者与消费者</p><p>ok，我的环境是win，没有在虚拟机里装，但一般用在Linux的好像比较多，来看看activemq是个什么东西吧：它是一个面向<strong>消息中间件</strong>（MOM Message-oriented middleware）【MOM 的总体思想是它作为消息发送器和消息接收器之间的消息中介,这种中介提供了一个全新水平的松耦合。】</p><p>JMS(Java Message Service)java消息服务</p><p>activemq就是JMS的一种体现，再了解消息的传递方式-<strong>包括点对点P2P和发布/订阅两种</strong>，nice 这似乎是我需要get的第一个知识点。</p><h4 id="P2P与Pub-Sub"><a href="#P2P与Pub-Sub" class="headerlink" title="P2P与Pub/Sub"></a>P2P与Pub/Sub</h4><p><strong>P2P</strong> （点对点）消息域使用 queue 作为 目标，消息可以被<strong>同步或异步</strong>的发送和接收，每个消息只会给一个 Consumer 传送一次。</p><p>Consumer 可以使用 MessageConsumer.receive() 同步地接收消息，也可以通过使用MessageConsumer.setMessageListener() 注册一个 MessageListener 实现异步接收。</p><p>多个 Consumer 可以注册到同一个 queue 上，但一个消息只能被一个 Consumer 所接收，然后由该 Consumer 来确认消息。并且在这种情况下，Provider 对所有注册的 Consumer 以<strong>轮询的方式</strong>发送消息。</p><p><strong>Pub/Sub</strong>（发布/订阅，Publish/Subscribe）消息域使用 topic 作为 Destination，发布者向 topic 发送消息，订阅者注册接收来自 topic 的消息。发送到 topic 的任何消息都将自动传递给所有订阅者。接收方式（同步和异步）与 P2P 域相同。<br>除非显式指定，否则 topic 不会为订阅者保留消息。当然，这可以通过持久化（Durable）订阅来实现消息的保存。这种情况下，当订阅者与 Provider 断开时，Provider 会为它存储消息。当持久化订阅者重新连接时，将会受到所有的断连期间未消费的消息。</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><ul><li>获取连接工厂</li><li>使用连接工厂创建连接</li><li>启动连接</li><li>从连接创建会话</li><li>获取 Destination</li><li>创建 Producer，或<ul><li>创建 Producer</li><li>创建 message</li></ul></li><li>创建 Consumer，或发送或接收message发送或接收 message<ul><li>创建 Consumer</li><li>注册消息监听器（可选）</li></ul></li><li>发送或接收 message</li><li>关闭资源（connection, session, producer, consumer 等)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--ActiveMQ所需要的jar包 --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 添加ActiveMQ的pool包 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-pool<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第一种P2P模式：</strong></p><p>①消息生产者给消息中间件（队列）发送消息</p><p>②消息消费者接收消息中间件（队列）的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//activamq默认用户名 密码和地址，获取连接的三个必要参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BORKEN_URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Atomic原子类型，保证该int一时间只被单线程操作</span></span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//获取连接工厂</span></span><br><span class="line">    ConnectionFactory connectionFactory;</span><br><span class="line">    <span class="comment">//创建连接对象</span></span><br><span class="line">    Connection connection;</span><br><span class="line">    <span class="comment">//事务管理</span></span><br><span class="line">    Session session;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;MessageProducer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;MessageProducer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(USERNAME,PASSWORD,BORKEN_URL);</span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            connection.start();</span><br><span class="line">            session = connection.createSession(<span class="keyword">true</span>,Session.SESSION_TRANSACTED);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String disname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取消息队列</span></span><br><span class="line">            Queue queue =  session.createQueue(disname);</span><br><span class="line">            MessageProducer messageProducer = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (threadLocal.get() !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//若不为空则从线程中获取，若为空则用session创建</span></span><br><span class="line">                messageProducer = threadLocal.get();</span><br><span class="line">                <span class="comment">//消息过期设置</span></span><br><span class="line">                <span class="comment">//messageProducer.setTimeToLive(1000);</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                messageProducer = session.createProducer(queue);</span><br><span class="line">                threadLocal.set(messageProducer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始创建消息</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">int</span> num = count.getAndIncrement();</span><br><span class="line">                TextMessage textMessage = session.createTextMessage(Thread.currentThread().getName()+<span class="string">"我正在生产消息,num"</span>+num);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"我正在生产消息,num"</span>+num);</span><br><span class="line">                <span class="comment">//发送消息</span></span><br><span class="line">                messageProducer.send(textMessage);</span><br><span class="line">                <span class="comment">//提交事务</span></span><br><span class="line">                session.commit();</span><br><span class="line">                <span class="keyword">if</span> (num&gt;<span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"消息发送结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: activemq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试Activemq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: WYuyin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-11-01 15:45</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMq</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Producter producter = <span class="keyword">new</span> Producter();</span><br><span class="line">        producter.init();</span><br><span class="line">        TestMq testMq = <span class="keyword">new</span> TestMq();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Thread 1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        <span class="comment">//Thread 2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        <span class="comment">//Thread 3</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        <span class="comment">//Thread 4</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">        <span class="comment">//Thread 5</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testMq.new ProductorMq(producter)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductorMq</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Producter producter;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProductorMq</span><span class="params">(Producter producter)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.producter = producter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    producter.sendMessage(<span class="string">"Jaycekon-MQ"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: activemq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: WYuyin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-11-01 16:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Comsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BORKEN_URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line">    <span class="comment">//获取连接工厂</span></span><br><span class="line">    ConnectionFactory connectionFactory;</span><br><span class="line">    <span class="comment">//创建连接对象</span></span><br><span class="line">    Connection connection;</span><br><span class="line">    <span class="comment">//事务管理</span></span><br><span class="line">    Session session;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;MessageConsumer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;MessageConsumer&gt;();</span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(USERNAME,PASSWORD,BORKEN_URL);</span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            connection.start();</span><br><span class="line">            session = connection.createSession(<span class="keyword">true</span>,Session.SESSION_TRANSACTED);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">getMessage</span><span class="params">(String disname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Queue queue = session.createQueue(disname);</span><br><span class="line">            MessageConsumer consumer = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(threadLocal.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                consumer = threadLocal.get();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                consumer = session.createConsumer(queue);</span><br><span class="line">                threadLocal.set(consumer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">                TextMessage msg = (TextMessage) consumer.receive();</span><br><span class="line">                <span class="keyword">if</span>(msg!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    msg.acknowledge();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">": Consumer:我是消费者，我正在消费Msg"</span>+msg.getText()+<span class="string">"---&gt;"</span>+count.getAndIncrement());</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: activemq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试Mq消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: WYuyin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-11-01 16:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCustomer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Comsumer comsumer = <span class="keyword">new</span> Comsumer();</span><br><span class="line">        comsumer.init();</span><br><span class="line">        TestCustomer testCustomer = <span class="keyword">new</span> TestCustomer();</span><br><span class="line">        <span class="keyword">new</span> Thread(testCustomer.new ConsumerMq(comsumer)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testCustomer.new ConsumerMq(comsumer)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testCustomer.new ConsumerMq(comsumer)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testCustomer.new ConsumerMq(comsumer)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerMq</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Comsumer comsumer;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerMq</span><span class="params">(Comsumer comsumer)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.comsumer = comsumer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    comsumer.getMessage(<span class="string">"Jaycekon-MQ"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种Pub/Sub模式</strong></p><p>①消息生产者（发布者）给消息中间件发送话题（topic）</p><p>②消息消费者（订阅者）接收消息中间件的发送话题</p><p>消息生产者（发布者）代码与第一种P2P模式的消息生产者代码几乎一样，只是在创建生产者时，创建的是话题并不是队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取session注意参数值mytopic是一个服务器的topic，须在在ActiveMq的console配置  </span></span><br><span class="line">topic = session.createTopic(<span class="string">"mytopic"</span>);  </span><br><span class="line"><span class="comment">// 得到消息生成者【发送者】  </span></span><br><span class="line">producer = session.createProducer(topic);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">TextMessage message = session.createTextMessage(<span class="string">"我给你发话题"</span>);  </span><br><span class="line">System.out.println(<span class="string">"Sender发送消息："</span> + <span class="string">"topic:"</span> + i);  </span><br><span class="line">producer.send(message);</span><br></pre></td></tr></table></figure><p>订阅者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">session = connection.createSession(Boolean.FALSE,Session.AUTO_ACKNOWLEDGE);  </span><br><span class="line"><span class="comment">// 获取session注意参数值mytopic是一个服务器的topic，须在在ActiveMq的console配置  </span></span><br><span class="line">destination = session.createTopic(<span class="string">"mytopic"</span>);  </span><br><span class="line">consumer = session.createConsumer(destination);</span><br></pre></td></tr></table></figure><h4 id="什么情况下使用ActiveMQ"><a href="#什么情况下使用ActiveMQ" class="headerlink" title="什么情况下使用ActiveMQ?"></a>什么情况下使用ActiveMQ?</h4><ol><li>多个项目之间集成<br>(1) 跨平台<br>(2) 多语言<br>(3) 多项目</li><li>降低系统间模块的耦合度，解耦<br>(1) 软件扩展性</li><li>系统前后端隔离<br>(1) 前后端隔离，屏蔽高安全区</li></ol><h3 id="SpringBoot集成Activemq"><a href="#SpringBoot集成Activemq" class="headerlink" title="SpringBoot集成Activemq"></a>SpringBoot集成Activemq</h3><p>即JMS在Springboot中的应用</p><p>[<a href="https://blog.csdn.net/Ouyzc/article/details/79756574" target="_blank" rel="noopener">https://blog.csdn.net/Ouyzc/article/details/79756574</a></p><p>下面按照上面这个链接中的代码进行分析：</p><p><strong>生产者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1生产者发送消息(发送信息到队列)P2P</span></span><br><span class="line"><span class="comment"> * 根据实例化Destination目的地参数的类型的对象决定是点对点队列的形式，还是广播的形式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">5000</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个目的地（队列类型）</span></span><br><span class="line">Destination queue = <span class="keyword">new</span> ActiveMQQueue(<span class="string">"mytest.queue"</span>);  </span><br><span class="line">jmsTemplate.convertAndSend(queue, <span class="string">"myname is Oyzc"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2生产者发送消息(发送信息到话题)Pub</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">5000</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topicSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个目的地（队列类型）</span></span><br><span class="line">Destination topic = <span class="keyword">new</span> ActiveMQTopic(<span class="string">"mytest.topic"</span>); </span><br><span class="line">jmsTemplate.convertAndSend(topic, <span class="string">"myname is Oyzc"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3生产者发送出去消息之后，可以马上监听指定消费者的反馈信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@JmsListener</span>(destination=<span class="string">"out.queue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerMessage</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"从out.queue队列收到的回复报文为:"</span>+text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者生产说明：</p><p>//P2P创建队列，参数为队列名</p><p>Destination queue = new ==ActiveMQQueue==(“mytest.queue”);</p><p>//Pub定义topic，参数为topic名称</p><p>Destination topic = new ==ActiveMQTopic==(“mytest.topic”); </p><p>//jms发送队列/话题信息，第一个参数为队列/topic，第二个参数为发送的内容，可以是字符串或实体或json</p><p>==jmsTemplate.convertAndSend(topic, “myname is Oyzc”);==</p><p><strong>消费者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用JmsListener配置消费者监听的队列，其中text是接收到的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者接收信息1(接收队列为mytest.queue的信息，并马上回复信息到out.queue队列中)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 使用JmsListener配置消费者监听的队列，其中text是接收到的消息  </span></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"mytest.queue"</span>) </span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"out.queue"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">receiveQueue1</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"消费者1收到目的地为mytest.queue发来的信息"</span>+text);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"mytest.queue接收到你的信息了"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者说明：</p><p>//@JmsListener开启监听，接受名为”mytest.queue”的队列/话题信息</p><p>@JmsListener(destination = “mytest.queue”) </p><p>//返回给生产者的队列</p><p>@SendTo(“out.queue”)  </p><p>在队列和话题同时存在的情况下，Jms默认支持队列，解决方式：</p><p>在配置文件中添加 <strong>spring.jms.pub-sub-domain=true</strong>，使得队列和话题同时发送成功，但消费者只接受topic。</p><p>正确解决方式：</p><p>① Jms配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJms</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsFactoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;activemq.ClientId&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String ClientId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JmsListenerContainerFactory&lt;?&gt; topicListenerFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        <span class="comment">//订阅发布</span></span><br><span class="line">        factory.setPubSubDomain(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//消息持久化</span></span><br><span class="line">        factory.setSubscriptionDurable(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//链接超时</span></span><br><span class="line">        factory.setReceiveTimeout(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">//接收者id</span></span><br><span class="line">        factory.setClientId(ClientId);</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JmsListenerContainerFactory&lt;?&gt; queueListenerFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        <span class="comment">//队列</span></span><br><span class="line">        factory.setPubSubDomain(<span class="keyword">false</span>);</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改消费者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JmsListener</span>(destination = <span class="string">"$&#123;activemq.topic&#125;"</span> , containerFactory = <span class="string">"topicListenerFactory"</span>)</span><br></pre></td></tr></table></figure><p>//使监听器处理话题/队列信息</p><p>containerFactory = “topicListenerFactory/queueListenerFactory”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;休息了大概一个礼拜，到一个新的单位重新开始，大佬列了很多新人技术清单，其中有很多只是听说过但没有学习和接触过，得赶紧学习啦，^-^&lt;/p&gt;
&lt;p&gt;另外最近使用的是来自大傻逼推荐的一个md编辑器Typora，非常好看还带大纲，比markdownPad
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="activemq" scheme="http://yoursite.com/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot(一)</title>
    <link href="http://yoursite.com/2018/10/22/Spring-Boot-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/10/22/Spring-Boot-一/</id>
    <published>2018-10-22T01:54:18.000Z</published>
    <updated>2018-11-04T09:41:03.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>上一节写HelloWorldDemo时主程序类被修饰了一个<strong>@SpringBootApplication</strong>，【顾名思义-SpringBoot应用注解】标注在某各类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用，是一个组合注解。</p><p>这个组合注解中包含Spring里的<strong>@Configuration</strong>、<strong>@Import、@EnableAutoConfiguration、@ComponentScan</strong>等底层注解，之前也说SpringBoot有自动配置的优点，那么只要你在主程序配置了<strong>@SpringBootApplication</strong>，其所在包及其中子包里所有的组件都扫描到Spring容器，这是其中的<strong>@AutoConfigurationPackage</strong>【自动配置包】的作用</p><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p><strong>@RestController</strong>标注在Controller类上，也是一个组合注解，主要包含<strong>@Controller</strong>和<strong>@ResponseBody</strong></p><p>@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中,页面不会发生跳转。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>新建Spring Initializer项目时会生成一个application.properties，除了这个properties文件还支持yml格式的配置文件，两者的书写格式有所不同，yml更加的清爽适合用来作为配置文件。</p><p>在建博客的时候遇到的配置文件都是yml类型，所以已经有些熟悉。</p><h3 id="值的格式"><a href="#值的格式" class="headerlink" title="值的格式"></a>值的格式</h3><p>k: v    //k和v之间一定要有空格</p><p><strong>普通的值：数字，字符串，布尔</strong><br>字符串不用加引号，但如果字符串中含有空格或特殊字符，要用单引号括起来，否则会被转义。<br>布尔类型：用on、1、true来表示true，off、0、false来表示false</p><p><strong>对象、Map、数组</strong><br>对象的值就在下一行写对象的属性值，注意缩进。</p><pre><code>friends:     lastName: zhangsan    age: 20</code></pre><p>行内写法：【也是Map的写法】</p><pre><code>frends: {lastName: zhangsan,age: 20}</code></pre><p>数组：用”- “隔开</p><pre><code>pets: - cat - dog</code></pre><p>数组的行内写法：<br>​<br>    pets: [dog,cat]</p><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>在配置文件中写好值后，如何获取参数？</p><h3 id="ConfigurationProperties-1"><a href="#ConfigurationProperties-1" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>最常见的方法有将对象以映射的方式，将配置信息封装成一个类，创建一个class，在类上修饰：<strong>@Component</strong> 和 <strong>@ConfigurationProperties(prefix=”xxx”)</strong>,前者是将类变成一个JavaBean，后者表示前缀为xxx的配置信息被绑定</p><p>我们可以导入<strong>配置文件处理器</strong>，写配置文件时会有相应包下bean的自动提示：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>JavaBean：</p><pre><code>@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person {    private String name;    private Integer age;    private List&lt;Object&gt; list;</code></pre><p>yml配置文件：</p><pre><code>person:  age: 20  name: Zhangsan  list:     - miao    - wang</code></pre><p>如果是properties文件要将文件编码改为ASCII码，否则会出现乱码，设置步骤为：Settings-File Encodings-√Transparent native-to-ascii conversion</p><h2 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h2><p>同Spring一样@Value(“${xxx}”)</p><p>其中引号中可以用EL表达式表示#{xxx}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringBootApplication&quot;&gt;&lt;a href=&quot;#SpringBootApplication&quot; class=&quot;headerlink&quot; title=&quot;@SpringBootApplication&quot;&gt;&lt;/a&gt;@SpringBootApplication
      
    
    </summary>
    
      <category term="spring boot" scheme="http://yoursite.com/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
      <category term="java ee" scheme="http://yoursite.com/tags/java-ee/"/>
    
  </entry>
  
  <entry>
    <title>被IE支配的恐惧</title>
    <link href="http://yoursite.com/2018/10/18/%E8%A2%ABIE%E6%94%AF%E9%85%8D%E7%9A%84%E6%81%90%E6%83%A7/"/>
    <id>http://yoursite.com/2018/10/18/被IE支配的恐惧/</id>
    <published>2018-10-18T02:44:02.000Z</published>
    <updated>2019-01-21T09:26:02.389Z</updated>
    
    <content type="html"><![CDATA[<p> 这两天改前端，平时习惯拿谷歌和opera调试，今天突然想到有个表格的宽没定好，有点丑，就打开几个浏览器一同看效果，然后就被IE整崩溃了，总是出现 属性“xxx”的值为 null、未定义或不是 Function 对象这个错，简单的一个onclick=”xxx()”都没有效果。</p><p>首先，我的js代码绝对没问题，因为其他浏览器正常都没问题，而且就算清除方法内容单单写一个alert也还是报一样的错。后来我改了方法名，重新刷新，刷新一下之后短暂地不报错并且成功走了我的js代码，但一切换或刷新又报错，一开始我以为是ie8的问题，切换调试工具为ie11发现的确ie11不报错，但也没有走我的方法，只是它没找到方法直接跳转到下一页面并且没有告诉你它没找到，真的是太草率了一点吧这个IE？？？</p><p>花了半天时间解决了这个问题，总结归纳如下几步：</p><p>1)确保js代码无误，方法名没有写错，或是方法里有什么语法错误。</p><p>2)判断问题是出在IE8兼容上还是IE的通病，通过F12右上角一个下拉选项可以切换调试版本，默认是8，这也是最蛋疼的一点。<br><img src="/2018/10/18/被IE支配的恐惧/20180831_1.png"></p><p>3)若是ie8独有的问题，那么就自行百度如何处理吧，如果是所有版本都存在的问题，或是像我一样时灵时不灵的情况，这是浏览器缓存导致的，js代码修改过但是浏览器只加载最初的js，这个靠刷新是没有效果的，</p><p><strong>清缓存步骤</strong>：设置-Internet选项-常规-删除，就会跳出删除浏览历史记录的窗口，把下载历史记录、表单数据都勾上，确认删除，等待几秒后就会弹出“Internet Explorer已完成删除所选的浏览历史记录”，这时再刷新就一切恢复正常了。</p><blockquote><p>后续：经过反复清缓存又重跑代码，最终觉得还是有代码本身的问题，页面上的表单用s标签提交，而我却欲用ajax，并把事件触发在submit上，感觉可能是冲突了，【我不信！那为啥什么也不写只有一句alert还是会报错@-@，还是要靠清缓存】，总之这个问题第二天在我放弃了ajax提交之后就悄悄地解决了，也没有发生昨天的情况，程序员的谎言：“我真的没有改代码！”orz</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 这两天改前端，平时习惯拿谷歌和opera调试，今天突然想到有个表格的宽没定好，有点丑，就打开几个浏览器一同看效果，然后就被IE整崩溃了，总是出现 属性“xxx”的值为 null、未定义或不是 Function 对象这个错，简单的一个onclick=”xxx()”都没有效果
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>spring boot入门</title>
    <link href="http://yoursite.com/2018/10/12/spring-boot%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/10/12/spring-boot入门/</id>
    <published>2018-10-12T02:22:06.000Z</published>
    <updated>2018-10-22T05:56:16.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>虽然工作用不到springboot，甚至没有用到spring，但这也就是为什么我有了强烈的危机感，现在许多地方应该会用到吧，或许标题应该是从零开始学springboot。跟着尚硅谷的springboot视频学习，如有侵权请留言或发<a href="9005837@qq.com">邮箱</a>告诉我</p></blockquote><p>spring boot是用于简化spring开发的框架，是基于spring再封装的一个框架<br>优点：</p><ul><li>快速创建独立运行的Spring项目以及与主流框架集成</li><li>使用嵌入式的Servlet容器，应用无需打成WAR包</li><li>starters自动依赖与版本控制</li><li>大量的自动配置，简化开发，也可修改默认值</li><li>无需配置XML，无代码生成，开箱即用</li><li>准生产环境的运行时应用监控</li><li>与云计算的天然集成<br>这里的无需配置配置文件，和starters自动依赖真的是很吸引人，想想用spring的时候从各种配置开始学真的有些繁琐。</li></ul><h2 id="环境约束"><a href="#环境约束" class="headerlink" title="环境约束"></a>环境约束</h2><ul><li>jdk1.8</li><li>maven3.x</li><li>IDEA2018</li><li>SpringBoot1.5.9</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.在apache-maven-3.3.9\conf\settings.xml中检查：</p><pre><code>&lt;profiles&gt;  &lt;profile&gt;            &lt;id&gt;jdk18&lt;/id&gt;            &lt;activation&gt;                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;                &lt;jdk&gt;1.8&lt;/jdk&gt;            &lt;/activation&gt;            &lt;properties&gt;                &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;                &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;                &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;            &lt;/properties&gt;         &lt;/profile&gt;  </code></pre><p>2.将IDEA的Maven环境修改为当前1.8版本，IDEA自带Maven<br><img src="/2018/10/12/spring-boot入门/20181012145508.png"></p><h2 id="HelloWorldDemo"><a href="#HelloWorldDemo" class="headerlink" title="HelloWorldDemo"></a>HelloWorldDemo</h2><p>流程：浏览器发送请求，服务器接收后处理并响应HelloWorld</p><ol><li><p>创建一个Maven工程<br>(也可以创建一个SpringInitializr工程，下面会讲到)<br><img src="/2018/10/12/spring-boot入门/20181012150010.png"><br>右下角会出现一个AutoImport<br><img src="/2018/10/12/spring-boot入门/20181012151419.png"><br>如果你和我一样很不幸的点了×但是又不想重来一遍,那么就在settings中设置Maven-importing<br><img src="/2018/10/12/spring-boot入门/20181012151700.png"><br>这个设置呢就意味着IDEA会自动帮我们导入依赖</p></li><li><p>导入依赖，在pom.xml中加入：</p><pre><code>   &lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></li></ol><p>就可以看到右下角在自动下载jar包</p><ol start="3"><li><p>写HelloWorld，在main里新建一个HelloWorld的class</p><pre><code>import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/*@SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorld {public static void main(String[] args){SpringApplication.run(HelloWorld.class,args);}}</code></pre></li><li><p>编写相关的Controller</p><pre><code>@Controllerpublic class HelloWorldController {@ResponseBody@RequestMapping(&quot;/hello&quot;)public String hello(){return &quot;Hello World&quot;;}}</code></pre></li></ol><blockquote><p>补习：@ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。<a href="https://www.cnblogs.com/daimajun/p/7152970.html" target="_blank" rel="noopener">来源</a></p></blockquote><ol start="5"><li>运行main方法<br><img src="/2018/10/12/spring-boot入门/20181012160811.png"></li></ol><blockquote><p>可以看到整个过程是非常简单的，也就只有注入依赖、写主程序和控制器就没了，回顾一下springMVC应用的流程，配置bean 创建Ioc容器 在程序中获取bean实例 还有SpringMVC的ModelAndView，（虽然我SpringMVC只是学了个大概，没有实践过），SpringBoot的出现一定是为了我这样的懒人减少配置的步骤才出现的吧</p></blockquote><ol start="6"><li><p>打包，加一个插件就可以做到</p> <!-- 这个插件可以将应用打包成一个可执行的jar包 --><pre><code>&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre></li></ol><p>无需再目标服务器安装tomcat环境,接着在右侧看到Maven Projects点开，点package让他装<br><img src="/2018/10/12/spring-boot入门/20181012162729.png"><br>打包好的jar包存在于target文件夹下<br><img src="/2018/10/12/spring-boot入门/20181012163051.png"><br>用cmd执行<code>java -jar jar包名称</code>就可以一样把应用跑起来，这就是SpringBoot对部署带来的便捷</p><h2 id="quickDemo"><a href="#quickDemo" class="headerlink" title="quickDemo"></a>quickDemo</h2><p>可使用Spring Initializer快速创建SpringBoot项目</p><p>IDE都支持使用Spring快速创建向导来开启一个SpringBoot项目</p><p>步骤：<strong>New- Project- Spring Initializer</strong><br>在Dependencies下选择你要的依赖，然后向导会自动联网帮你配好这些依赖<img src="/2018/10/12/spring-boot入门/20181022111750.png">把不要的东西去掉。</p><p>新建完成后会发现主程序已经帮你创好了，接下来只要写逻辑就可以了。</p><p>Controller中的一个注解<strong>@RestController</strong>包含@Controller和@ResponseBody，ResponseBody在上面已经回顾过。标注在Controller上代表这是一个Controller类。</p><pre><code>@RestControllerpublic class HelloController {@RequestMapping(&quot;/hello2&quot;)public String hello(){return &quot;quick hello&quot;;}}</code></pre><p>这下一个quickDemo就完成了，不仅比原先少写主配置文件和依赖，自动生成的目录结构也将静态资源和配置文件生成好了</p><pre><code>-main---java------com.quickdemo.demo---------DemoApplication---resources------static    这个放静态资源------templates    这个保存所有的模态页面------application.properties    配置文件</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;虽然工作用不到springboot，甚至没有用到spring，但这也就是为什么我有了强烈的危机感，现在许多地方应该会用到吧，或许标题应该是从零开始学springboot。跟着尚硅谷的springboot视频学习，如有侵权请留言或发&lt;a href=&quot;
      
    
    </summary>
    
      <category term="spring boot" scheme="http://yoursite.com/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="http://yoursite.com/tags/spring-boot/"/>
    
      <category term="java ee" scheme="http://yoursite.com/tags/java-ee/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题汇总</title>
    <link href="http://yoursite.com/2018/10/11/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/10/11/Java面试题汇总/</id>
    <published>2018-10-11T03:23:53.000Z</published>
    <updated>2019-01-21T09:27:41.493Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有可能不全是Java的知识，只是时间一长感觉这些知识会忘了，就把我遇到的和我了解的先列列看吧。其中会出现许多来自百度、知乎、CSDN等处的内容，就不一一列出来了。</p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="private、protected、public、default的区别"><a href="#private、protected、public、default的区别" class="headerlink" title="private、protected、public、default的区别"></a>private、protected、public、default的区别</h4><p><img src="https://images2015.cnblogs.com/blog/690292/201609/690292-20160923095944481-1758567758.png"></p><p>private 的访问权限仅限于类的内部，是一种封装的体现，大多数成员变量都是private的，使它不能被任何外部的类访问。</p><p>不写时默认为default，即同一包内、类内。</p><h4 id="封装、继承、多态、抽象"><a href="#封装、继承、多态、抽象" class="headerlink" title="封装、继承、多态、抽象"></a>封装、继承、多态、抽象</h4><p>众所周知的面向对象的特征。</p><p>封装：把对象的属性、方法结合成一个独立的整体，这也就是模块化的思想</p><p>继承：一个类可以继承(extends) 父类，就变成了他的子类，继承了父类所有的非私有的方法与属性，哪些内容会被继承见上面的图，继承的方法一般可以重写，继承与重载的权限如下图所示</p><p><img src="https://pic1.zhimg.com/80/v2-a836e010f9e147509844b79529f5a176_hd.jpg"></p><p>多态：不同的对象对同一消息做出不一样的响应，采取不同的方法。最直观的例子就是一个实体类可以有多个构造方法。</p><p>抽象：有相同特性的类抽象出共同的部分，用abstract修饰，抽象类的意义可以用三句话来概括：1.为其它子类提供一个公共的类型 2.封装子类中重复定义的内容 3.定义统一抽象方法，</p><p>抽象方法没有方法体。</p><h4 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h4><p>抽象和接口通常被放在一起比较</p><p><strong>实现方式</strong>：抽象类用extends继承，接口用implements，需要提供接口中所有声明的实现。</p><p><strong>是否可以被实例化</strong>：抽象类不可以，接口则是完全不同的类型，接口不是类，更不能被实例化</p><p><strong>构造器：</strong>抽象类中可以有构造器，接口不能</p><p><strong>修饰符：</strong>抽象方法可以有public、protected、default修饰，接口默认为public，不能被其他修饰符修饰</p><p><strong>是否可以多继承</strong>：抽象类有传递性质，但只能继承一个父类，却可以同时实现多个接口</p><p><strong>构造方法</strong>：接口没有构造方法</p><p>接口的意义在于规范，扩展，回调</p><h4 id="Overload和Override的区别"><a href="#Overload和Override的区别" class="headerlink" title="Overload和Override的区别"></a>Overload和Override的区别</h4><p>重写Override，子类覆盖父类的方法，将子类传与父类的引用调用的还是子类的方法。<br>重载Overloading，一个类多个方法，名称相同，参数个数类型不同，返回值的类型也可不同。<br>两者都是Java多态性的不同表现。</p><h4 id="Final有什么作用"><a href="#Final有什么作用" class="headerlink" title="Final有什么作用"></a>Final有什么作用</h4><p>修饰的属性为常量<br>修饰的方法不可以重写<br>修饰的类不可以继承</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>this()和super()的意义</p><p>什么是不可变对象</p><p>Object有哪些公共方法？（equals(),clone(),getClass(),notify(),notifyAll(),wait(),toString()）</p><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h4><p>ArrayList:线程不安全，速度快<br>Vector:线程安全，速度慢(synchoronized)<br>两者都实现了List接口，都是有序的集合，允许重复和null</p><p>LikedList: 以单链表的方式存储，增、删快，查、改慢</p><h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h4><p>HashMap与Hashtable都实现的Map接口,HashTable线程安全，HashMap线程不安全。</p><h4 id="Collection-和-Collections的区别"><a href="#Collection-和-Collections的区别" class="headerlink" title="Collection 和 Collections的区别"></a>Collection 和 Collections的区别</h4><p>Collection是集合的根接口，其下有set（无序）及list（有序）<br>Collections是集合的算法。</p><p>Map不继承于Collection，是无序的键值对的集合，不允许重复</p><h4 id="Enumeration和Iterator接口的区别"><a href="#Enumeration和Iterator接口的区别" class="headerlink" title="Enumeration和Iterator接口的区别"></a>Enumeration和Iterator接口的区别</h4><p>Enumeration比Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。</p><p>Iterator能够删除元素，Enumeration不能。</p><h4 id="ArrayList集合加入1万条数据，应该怎么提高效率"><a href="#ArrayList集合加入1万条数据，应该怎么提高效率" class="headerlink" title="ArrayList集合加入1万条数据，应该怎么提高效率"></a>ArrayList集合加入1万条数据，应该怎么提高效率</h4><p>ArrayList的默认初始容量为10，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了10万条数据了，我们可以直接在初始化的时候就设置ArrayList的容量！</p><h4 id="HashMap的key值要是为类对象则该类需要满足什么条件？"><a href="#HashMap的key值要是为类对象则该类需要满足什么条件？" class="headerlink" title="HashMap的key值要是为类对象则该类需要满足什么条件？"></a>HashMap的key值要是为类对象则该类需要满足什么条件？</h4><p>转载自<a href="https://segmentfault.com/a/1190000014403696#articleHeader11" target="_blank" rel="noopener">这里</a></p><p>需同时重写该类的hashCode()方法和它的equals()方法。</p><p>一般来说，我们会认为：只要两个对象的成员变量的值是相等的，那么我们就认为这两个对象是相等的！因为，Object底层比较的是两个对象的地址，而对我们开发来说这样的意义并不大~这也就为什么我们要重写equals()方法</p><p>重写了equals()方法，就要重写hashCode()的方法。因为equals()认定了这两个对象相同，而同一个对象调用hashCode()方法时，是应该返回相同的值的</p><h4 id="与equals"><a href="#与equals" class="headerlink" title="== 与equals"></a>== 与equals</h4><p>==：主要用于基本数据类型（byte、int、char、long、float、double、boolean和short）及引用<br>equals()：用于对象及引用，（String一般用equals）</p><h2 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h4><p>事务是是并发控制单位，要么全部做要么劝都不做。如果你自己不去控制事务，数据库默认一条sql语句就处在自己单独的事务当中。以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。</p><h4 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h4><p>（呃啊这需要理解到位，第一次面试遇到过的题目）<br><strong>原子性、一致性、隔离性、持久性</strong><br>链接：<a href="https://blog.csdn.net/leprovision/article/details/81021675" target="_blank" rel="noopener">什么是事务,事务的四个特性是什么</a><br>⑴ 原子性（Atomicity）<br>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p>⑵ 一致性（Consistency）<br>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><p>⑶ 隔离性（Isolation）</p><p>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><p>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p><p>⑷ 持久性（Durability）</p><p>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><p>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p><p>　　以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p><p>1，脏读</p><p>　　脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p><p>　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下</p><p>update account set money=money+100 where name=’B’; (此时A通知B) update account set money=money - 100 where name=’A’;</p><p>　　当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p><p>2，不可重复读</p><p>　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p><p>　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p><p>　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p><p>　　在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</p><p>3，虚读(幻读)</p><p>　　幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p><p>　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有可能不全是Java的知识，只是时间一长感觉这些知识会忘了，就把我遇到的和我了解的先列列看吧。其中会出现许多来自百度、知乎、CSDN等处的内容，就不一一列出来了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Java&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>获取指定行所在的列</title>
    <link href="http://yoursite.com/2018/10/10/%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%89%80%E5%9C%A8%E7%9A%84%E5%88%97/"/>
    <id>http://yoursite.com/2018/10/10/获取指定行所在的列/</id>
    <published>2018-10-10T07:27:02.000Z</published>
    <updated>2019-01-21T09:31:39.588Z</updated>
    
    <content type="html"><![CDATA[<p>每次前端的问题都能把我整好久，看来当时网页这门课没学好，今天遇到的问题是不知道如何获取table下某一列的所有数值，校验后并对它所在的行的其他兄弟节点进行操作。</p><p>html：</p><pre><code>&lt;table class=&quot;datatbl&quot;&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;td&gt;xxx&lt;/td&gt;            &lt;td&gt;xxx&lt;/td&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;        &lt;s:iterator value=&quot;list&quot;&gt;            &lt;td class=&quot;a&quot;&gt;&lt;s:property value=&quot;a&quot;/&gt;&lt;/td&gt;            &lt;td class=&quot;compareFlag&quot;&gt;&lt;s:property value=&quot;b&quot;/&gt;&lt;/td&gt;        &lt;/s:iterator&gt;    &lt;/tbody&gt;&lt;/table&gt;</code></pre><p>思路：为了操作步骤方便，我直接将要获取的那一列加上class，本来想从table一步步往下找，但是不知道怎么.childern不太会用，索性直接根据class找所有的元素。<br>​<br>    $(“.compareFkStatus”).each(function(){<br>        console.log($(this).html());<br>    });</p><p>然后获取此td所在的tr，也就是其父节点</p><pre><code>$(&quot;.compareFkStatus&quot;).each(function(){    console.log($(this).html());    var parent = $(this).parent();    var a = parent.find(&quot;[class=&apos;a&apos;]&quot;).html();    console.log(&quot;a:&quot;+a);});</code></pre><p>这里parent就是所在列，a就是所在列。</p><p>总结一下，也就是子元素与父元素的获取<br>​<br>    $(子元素).parent() #获取父元素<br>    $(父元素).children(selector) #获取子元素<br>    $(xxx).find(“[class=’a’]”)    #与上面相似，此处的意思为xxx下的class为a的元素</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每次前端的问题都能把我整好久，看来当时网页这门课没学好，今天遇到的问题是不知道如何获取table下某一列的所有数值，校验后并对它所在的行的其他兄弟节点进行操作。&lt;/p&gt;
&lt;p&gt;html：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table class=&amp;quot;datatb
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>搭建博客步骤</title>
    <link href="http://yoursite.com/2018/10/10/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%AD%A5%E9%AA%A4/"/>
    <id>http://yoursite.com/2018/10/10/搭建博客步骤/</id>
    <published>2018-10-10T01:42:31.000Z</published>
    <updated>2019-01-21T09:31:23.314Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面，这其实不是我第一次搭博客，之前尝试过一次但是兴致冲冲地找了很多教程做到后来发现hexo装的就有些问题，并不是网上的教程不详细，但是东看西看容易出错，这里重头再来一遍，把之前的坑都补上</p></blockquote><h3 id="安装Nexo"><a href="#安装Nexo" class="headerlink" title="安装Nexo"></a>安装Nexo</h3><p>前提：安装好了node.js和git</p><p>1)新建一个空的文件夹，用于存放你的项目，在其中打开Git Bash</p><p>2)依次执行以下命令：<br>​<br>​    npm install hexo-cli -g<br>​    hexo init blog<br>​    cd blog<br>​    npm install<br>​    hexo server</p><p>其中第一步可能会等的久一点，耐心等待。</p><p>3)浏览器打开4000端口，可以在本地看到原始的hexo博客，ctrl+c关闭，每次想预览可以再输入 <code>hexo server (hexo s)</code></p><p>如果4000端口占用，可用<code>hexo server -p 其他端口号</code>，也可以找方法把4000端口的服务关掉</p><p>这一步有问题一定要解决，hexo运行正常才是搭一个githubio的前提</p><h3 id="部署到GitHub-Pages"><a href="#部署到GitHub-Pages" class="headerlink" title="部署到GitHub Pages"></a>部署到GitHub Pages</h3><p>1) 在GitHub新建一个仓库，Repository name必须得是 <strong>账户名.github.io</strong> </p><p>这时你已经可以访问 <a href="https://xxx.github.io/了" target="_blank" rel="noopener">https://xxx.github.io/了</a></p><p>2) 回到你的blog文件夹下，执行：<br>​<br>​    $ git config –global user.name “yourname”<br>​    $ git config –global user.name “<a href="mailto:youremail@xx.com" target="_blank" rel="noopener">youremail@xx.com</a>“</p><p>3) 找到_config.yml，在最后找到下面的内容并修改：<br>​<br>​    deploy:<br>​    type: git<br>​    repository: <a href="https://github.com/WYuyin/WYuyin.github.io.git" target="_blank" rel="noopener">https://github.com/WYuyin/WYuyin.github.io.git</a><br>​    branch: master</p><p>4) 执行命令 <code>hexo d -g</code> 就可完成部署</p><p>等待一会会让你输入GitHub用户名和密码，再访问<a href="http://xxx.github.io就可以看到你的主页" target="_blank" rel="noopener">http://xxx.github.io就可以看到你的主页</a></p><blockquote><p>这里 搭建和部署是两个命令，第一次部署需要用hexo g，安装完插件后每次要提交只需hexo d即可，如果出错可以hexo clean + hexo d -g</p></blockquote><h3 id="使用NexT"><a href="#使用NexT" class="headerlink" title="使用NexT"></a>使用NexT</h3><p>1) 安装</p><pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>2) 启用，修改_config.yml:<br>​<br>​    theme: next</p><p>3) 开启服务后再访问你的主页就可以看到NexT了</p><pre><code>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d -g$ hexo g &amp;&amp; hexo s   #如需本地预览，执行这一条</code></pre><p>提交了后并不是立马刷新的，稍微等十几秒钟才能更新</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>这里根据个人喜好装饰博客，我之前其实已经做完了这些工作，一些配置就直接复制的之前的配置文件，这里区分两个配置文件，一个是安装hexo时生成的，还有一个是next主题中的，位置blog\themes\next_config.yml，修改样式主要在这两个中，另外如果想修改NexT的css样式，直接添加进\blog\themes\next\source\css_custom\custom.styl<br>​<br>样式的修改参考了<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">大佬的博客</a></p><p>下面就一些我遇到的坑记录解决方法</p><h4 id="字数与阅读时长"><a href="#字数与阅读时长" class="headerlink" title="字数与阅读时长"></a>字数与阅读时长</h4><p>链接：<a href="https://www.jianshu.com/p/baea8c95e39b" target="_blank" rel="noopener">Hexo添加字数统计、阅读时长</a></p><h4 id="代码块高亮颜色"><a href="#代码块高亮颜色" class="headerlink" title="代码块高亮颜色"></a>代码块高亮颜色</h4><p>在配置文件中找到：</p><p>highlight_theme: normal，注释显示有五种显示主题可用，分别是：</p><ul><li>normal</li><li>night</li><li>night eighties</li><li>night blue</li><li>night bright</li></ul><h4 id="创建分类与标签"><a href="#创建分类与标签" class="headerlink" title="创建分类与标签"></a>创建分类与标签</h4><p>链接：<a href="https://blog.csdn.net/ganzhilin520/article/details/79047249" target="_blank" rel="noopener">hexo设置 关于 标签 分类 归档</a></p><h4 id="博客icon更替"><a href="#博客icon更替" class="headerlink" title="博客icon更替"></a>博客icon更替</h4><p>1) 找一个尽量长宽比相等的小图标，什么图片格式都可以</p><p>2) 百度，在线将你的图片转成ico格式</p><p>3) 将图标放在 blog\themes\next\source\images 文件夹下</p><p><img src="/2018/10/10/搭建博客步骤/20181010112351.png"></p><p>4) 修改 blog\themes\next_config.yml</p><p><img src="/2018/10/10/搭建博客步骤/20181010112817.png"></p><h4 id="在博客中添加图片"><a href="#在博客中添加图片" class="headerlink" title="在博客中添加图片"></a>在博客中添加图片</h4><p>链接：<a href="https://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="noopener">hexo生成博文插入图片</a></p><p>之前我用的是一种比较笨的方法，每次上传到github然后再添加打开，但是github加载的速度大家也知道，相当的慢，经常出不来，于是找到了这个hexo的插件：<code>npm install hexo-asset-image --save</code></p><p>当生成一个新的博客时会多出一个同名的文件夹，将图片放进去然后用<code>&lt;img src=&quot;xxxx/图片名.png&quot;&gt;</code>就可以实现了，当然，如果你想贴的是网上现成的图，直接写网址就ok</p><h4 id="首页不显示全文"><a href="#首页不显示全文" class="headerlink" title="首页不显示全文"></a>首页不显示全文</h4><p>在配置文件中找到 auto_excerpt ，并修改：</p><pre><code>auto_excerpt:  enable: true    #这里修改为true  length: 150</code></pre><h4 id="评论与其他"><a href="#评论与其他" class="headerlink" title="评论与其他"></a>评论与其他</h4><p>上面收集的是一些我开博客遇到的问题，另外有一些样式上的问题比较简单。评论我用了<a href="https://livere.com/introduce" target="_blank" rel="noopener">来必力</a>，网上有很多其他的第三方评论平台都已经停了，所以只能暂时用这个，还算方便快捷。</p><p>这里就告一段落啦，如果有问题欢迎留言讨论，不过我也还是一个小菜鸡呀</p><hr><p>10.18日更新</p><h4 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h4><pre><code>$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save</code></pre><p>然后在文章顶部+<code>top: true</code>就可以啦。另外还找到一个方法是改js，设置top的优先级，还未试过，这边给出<a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="noopener">链接</a></p><h4 id="菜单点击出现的小图案"><a href="#菜单点击出现的小图案" class="headerlink" title="菜单点击出现的小图案"></a>菜单点击出现的小图案</h4><p>总的来说看上去还是一个标标准准的Next风格，其实想变得与众不同一些我在一些小细节上还是做了很多改动的！比如这个点击菜单出现的喵喵图案，改起来其实并不难。<br>第一步，找一个背景透明，缩小看也不失真的图片，我是用ps调整的图片大小，【用画图工具的话好像会留白】，调整大小为30px*30px<br>第二步，将图片放在blog\themes\next\source\images目录下，和改icon的目录一致<br>第三步，修改\blog\themes\next\source\css_custom\custom.styl文件，添加：</p><pre><code>//菜单.menu-item-active a:after {    width: 30px;    height: 30px;    background: url(&quot;../images/miao2.png&quot;);    margin-top: -12px;//调整好位置}</code></pre><p>第四步，预览并调试图片的位置，上面的margintop是我调整后觉得合适的边距，主题不一样可能位置有偏差，用浏览器的开发者工具调整到一个最佳的角度就ok，效果：<img src="/2018/10/10/搭建博客步骤/20181018145958.png"></p><h4 id="加速博客浏览速度"><a href="#加速博客浏览速度" class="headerlink" title="加速博客浏览速度"></a>加速博客浏览速度</h4><p>找到一个好的博客真的是很难得，<a href="https://blog.csdn.net/linshuhe1/article/details/71170499" target="_blank" rel="noopener">河乐不为的CSDN</a>，<strong>重点！重点</strong>这里的操作完全和文中的一样，且没有遇到坑，惊喜</p><ul><li>注册Coding.net账号：<br>打开<a href="https://coding.net/" target="_blank" rel="noopener">Coding.net官网</a>，注册一个个人账号</li><li>新建项目<br>注意项目名与注册用的账户名一致，这里我用的是WYuyin：</li><li>添加公钥<br>上面设置完毕之后点击创建项目，然后点击设置-&gt;部署公钥-&gt;新建部署公钥，之前部署到Github上的时候，本地目录 C\User(中文为用户)(电脑用户名).ssh 目录下会有 github.rsa.pub 公钥文件，打开然后复制里面的内容，直接贴在这里的公钥框中：<br><img src="/2018/10/10/搭建博客步骤/20181018151019.png"><br><img src="/2018/10/10/搭建博客步骤/20181018151145.png"><blockquote><p>记得要勾选 授予推送权限 ，否则在后面运行hexo d时会提示错误：<br>  Coding.net Tips : [Deploy key is not allowed to push!]<br>  fatal: Could not read from remote repository.<br>原因就是没有推送权限。</p></blockquote></li></ul><p>打开Git命令窗口，输入以下指令：</p><pre><code>ssh -T git@git.coding.NET</code></pre><p>假如出现以下输出结果，表示公钥绑定成功：</p><pre><code>The authenticity of host &apos;git.coding.net (118.25.166.124)&apos; can&apos;t be established.RSA key fingerprint is SHA256:jok3FH7q5LJ6qvE7iPNehBgXRw51ErE77S0Dn+Vg/Ik.Are you sure you want to continue connecting (yes/no)? yPlease type &apos;yes&apos; or &apos;no&apos;: yesWarning: Permanently added &apos;git.coding.net,118.25.166.124&apos; (RSA) to the list of known hosts.Coding 提示: Hello WYuyin, You&apos;ve connected to Coding.net via SSH. This is a deploy key.WYuyin，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个部署公钥</code></pre><ul><li><p>修改hexo配置<br>打开hexo本地的配置文件 _config.yml，修改 deploy 的配置内容，这里设置了运行hexo d之后部署的目的地址，原本只有Github地址，现在添加多Coding.net的地址，其中WYuyin是注册该平台的 用户名：</p><pre><code>deploy:  type: git  repository: github: https://github.com/WYuyin/WYuyin.github.io.gitcoding: git@git.coding.net:WYuyin/WYuyin.git,master  branch: master</code></pre></li><li><p>正式部署到Coding.net：<br>打开命令行窗口，定位到当前hexo项目的根目录下，运行以下指令将本地博客部署到Github和Coding.net上：</p><pre><code>hexo g  hexo d</code></pre></li><li><p>设置Coding Page：<br><img src="/2018/10/10/搭建博客步骤/20181018152156.png"><br>设置成功后是这个样子<br><img src="/2018/10/10/搭建博客步骤/20181018152406.png"></p></li></ul><p>然后访问<a href="http://wyuyin.coding.me/" target="_blank" rel="noopener">http://wyuyin.coding.me/</a>就可以啦，无需等待立马就可以见到效果,访问的速度比之前快了一倍，另外我也对next的js做了一些调整，这里参考<a href="https://blog.csdn.net/Domino_b/article/details/81704118" target="_blank" rel="noopener">Soul_wwb的CSDN</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;写在前面，这其实不是我第一次搭博客，之前尝试过一次但是兴致冲冲地找了很多教程做到后来发现hexo装的就有些问题，并不是网上的教程不详细，但是东看西看容易出错，这里重头再来一遍，把之前的坑都补上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安
      
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
